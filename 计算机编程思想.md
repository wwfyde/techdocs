# 编程思想



## 理解

## 分解

元思维, 

认知,判断, 重复

## 重构

## 复用

## 分层

分多个层面描述同一个问题, 同一个概念可以有多种表现形式

## 抽象

## 结构化

## 模块化

## 自动化

# 编程的本质



> Programming, at its essence, is the process of instructing a computer to perform specific tasks. It involves designing, writing, testing, debugging, and maintaining the source code of computer programs. This source code is written in a programming language, the means by which a programmer precisely defines the actions to be carried out by the system.
> The essence of programming can be distilled into a few key elements:
> **Problem Solving**: Programming is fundamentally about solving problems. At its core, a programmer’s job involves taking a problem, breaking it down into manageable parts, figuring out a solution to those parts, and then translating those solutions into code.
>
> **Communication**: Programming is also a form of communication. Not only is the programmer communicating with the computer via code, but also with others (including future self) who might read or maintain the code.
>
> **Abstraction**: Programming often involves building abstract models of real-world scenarios in code, and manipulating those models to achieve desired results.
>
> **Automation**: Programming enables automation of tasks, which can save time, reduce errors, and increase efficiency. This could be anything from simple scripts to complex systems.
>
> **Creativity**: Although programming is a highly technical skill, it also involves a great deal of creativity. Finding innovative solutions to problems, designing algorithms, or crafting an elegant piece of code, can all be highly creative tasks.
>
> Programming is an ever-evolving field, and its essence lies in its ability to adapt to new challenges, technologies, and paradigms. Having a mindset that embraces these features is crucial to being a successful programmer.

编程, 本质上是一个指示计算机执行特定任务的过程. 该过程涉及到计算机程序源代码的设计, 编写, 测试, 调试和维护. 源代码由某种编程语言编写, 这意味着程序员通过这种方式精确定义可由计算机系统执行的操作.

编程的本质可以提炼成以下几种关键元素:

- **问题解决**(Problem Solving): 编程从根本上讲就是解决问题. 作为核心, 程序员的任务涉及到提取任务,分解成可管理的部分, 理解并得出(figure out)这些部分的解决方案, 然后将解决方案转译成代码. 
- **沟通**(Communication: 编程也是一种沟通形式. 不仅通过代码与计算机进行沟通, 而且与可能阅读和维护代码的人(包括将来的自己)进行沟通.
- **抽象**(Abstraction): 编程经常涉及到用代码构建现实场景的抽象模型, 然后操作这些模型以实现期望中的结果.
- **自动化**(Automation): 编程使得任务自动化, 这可以节省时间, 减少错误, 提升效率. 这可以是任何从简单脚本到复杂系统的过程.
- **创造性**(Creativity): 尽管编程时一种高度技术化的技能, 编程也涉及到大量的创造力(idea of creativity). 寻找问题的创新性解决方案, 设计算法或编写一段优雅的代码, 都是高度创造性的任务.

编程是一个持续不断发展的领域, 它的本质取决于采纳新挑战, 技术和范例的能力. 保持拥抱这些重要特性的观念(mindset)以成为一个成功的程序员. 

# 高质量代码的特征

- 20230723: 
    - 数据和逻辑分离, 数据和逻辑之间通过模型来交互, 即高度抽象化
    - 可批量处理, 不需要人为干预即可自动运行, 即高度自动化
    - 可配置与控制, 通过简单的参数修改来干涉预期结果, 即高度参数化
    - 可维护性, 通过代码组织,添加代码注释等方式提升可读性, 高度结构化
- 

# 函数

## 函数中声明函数

```go
func ExampleWithCancel() {
	// gen generates integers in a separate goroutine and
	// sends them to the returned channel.
	// The callers of gen need to cancel the context once
	// they are done consuming generated integers not to leak
	// the internal goroutine started by gen.
	gen := func(ctx context.Context) <-chan int {
		dst := make(chan int)
		n := 1
		go func() {
			for {
				select {
				case <-ctx.Done():
					return // returning not to leak the goroutine
				case dst <- n:
					n++
				}
			}
		}()
		return dst
	}

	ctx, cancel := context.WithCancel(context.Background())
	defer cancel() // cancel when we are finished consuming integers

	for n := range gen(ctx) {
		fmt.Println(n)
		if n == 5 {
			break
		}
	}
	// Output:
	// 1
	// 2
	// 3
	// 4
	// 5
}
```



# 程序设计思想与方法

[官方文档](https://wizardforcel.gitbooks.io/sjtu-cs902-courseware/content/)

## 计算与计算思维



* * *

## 计算基本概念

* * *

### 计算机

* **程序**
  *  --指令序列
* **CPU**
  * 计算机所做的所有神奇的事情,都是靠一步一步执行的,平凡而乏味的简单指令序列做到的.  计算机一点也不神奇,它唯一会做的事情 就是机械地执行预定的指令序列. 
* **存储器**
  * CPU只能访问存储器
    **输入/输出设备**    
* 输入和输出设备提供了人与计算机进行交互的手段
  **寄存器**
  是CPU里面的高速存储部件

### 计算概念

* 针对一个问题,设计出解决问题的程序(指令序列), 并由计算机来执行这个程序,这就是计算(computation)
* 通过计算,使得只会执行简单操作的计算机能够完成神奇的复杂任务, 所以计算机的神奇表现其实都是计算的威力. 
* 计算机就是通过这样的计算来解决所有复杂问题的. 执行大量简单指令组成的程序 虽然枯燥繁琐, 但计算机作为一种机器,其特长在于机械地, 忠实地, 不厌其烦地执行大量简单指令

### 计算机语言

高级语言相对于机器语言和汇编语言具有很多优点：

* 第一，高级语 言吸收了人们熟悉的自然语言（英语）和数学语言的某些成分，因此非常易学、易用、易读； 
* 第二，高级语言在构造形式和意义方面具有严格定义，从而避免了语言的歧义性；
* 第三，高级语言与计算机硬件没有关系，用高级语言写的程序可以移植到各种计算机上执行。

高级语言之所以具有前面提到的可移植性，正是因为高级语言的这种先翻译后执行的特点。只要一台计算机上有合适的编译器或解释器，用某种高级语言编写的程序可以在该计算 机上执行。

编译器和解释器本身也是程序，这种程序所执行的计算就是将别的程序 翻译成机器能够理解的指令。
为了让一台计算机能够执行某种高级语言程序，必须先在该计 算机上安装特定高级语言的编译器或解释器程序！



**计算机的通用性**

计算机具备通用性的基础能力是计算,诀窍在于程序.通过不同的程序(指令序列)封装,就能实现不同的功能,解决不同的问题
计算机科学家思考的一个根本问题:到底什么问题是计算机可计算的?
所有计算机的计算能力都是一样的,计算机都在做同样的事情,但是性能会有不同

**计算机科学**

> 为了更好地利用计算机解决问题，人们深入研究了关于计算的理论、方法和技术，形成 了专门研究计算的学问——计算机科学（computer science）
> 计算机科学包含很多内容，本书的主题是计算机科学家在用计算机解决问题时建立的一 些思想和方法，这些思想和方法普遍存在于计算机科学的各个分支之中。





### 算法

程序是解决某个问题的指令序列。编程解决一个问题时，首先要找出解决问 题的方法，该解决方法一般先以非形式化的方式表述为由一系列可行的步骤组成的过程，然后才用形式化的编程语言去实现该过程。这种解决特定问题的、由一系列明确而可行的步骤 组成的过程，称为算法（algorithm）。算法表达了解决问题的核心步骤，反映的是程序的解题逻辑。
算法是由一系列步骤构成的计算过程，但并不是随便用一些步骤都能构成合格的算法的。我们对算法有两个要求：第一，每个步骤必须具备明确的可操作性；第二，构成算法的所有步骤必须能在有限时间内完成(明确开始和结束,序列性)。

### 实现

给定一个问题，当我们找到解决问题的算法后，接着就需要用某种计算机语言将这个算法表达出来， 最终 得到一 个能 被计算 机执 行的程 序(格式化)（或代 码 ），这 个 过程称 为 实现（implementation），或者俗称为写代码（coding）。 严格地说，算法与程序是不同的：**算法是用非形式化方式表述的解决问题的过程，程序则是用形式化编程语言表述的精确代码**。这样，**算法设计和算法实现就分别指计算机解决问题时的两个不同阶段**。但我们经常在宽泛的意义上使用“程序”和“程序设计”这两个术语， 前者泛指算法和代码，后者泛指从问题分析直到编码实现的全过程。
设计算法是创造性的活动，要求设计者具备问题求解能力和想象力，能从宏观视野把握 问题的求解逻辑；而编码实现算法则是相对机械的活动，要求程序员具有严谨细致的作风，  能在微观层次关注细枝末节。

### 学习程序的好处

* 第一，计算机已经成为我们生活、学习和工作中普遍使用的 工具，学会编程能使我们成为计算机的主人，使计算机按我们的意志做事。
* 第二，程序设计 能够培养我们抽象、分析和问题求解的能力，这种能力对日常生活和工作也是很重要的。
* 第三，编程也是一种充满乐趣的智力活动，许多人将编程当作一种爱好，发现巧妙的算法和程 序运行成功后的那种成就感令人乐此不疲。


## 计算思维概念


> 计算机科学家在用**计算机解决问题**时也有自己独特的**思维方式和解决方法**，我们统称之为计算思维（computational thinking）。
> 从问题的计算机表示、算法设计直到编程实现，计算思维贯穿于 计算的全过程。**学习计算思维，就是学会像计算机科学家一样思考和解决问题**。

### 计算思维的基本原则

计算思维建立在计算机的能力和限制之上。
用计算机解决问题时必须遵循的基本思考原则是：既要充分利用计算机的计算和存储能力，又不能超出计算机的能力范围。
我们不能要求计算机去执行无法化归为简单操作的复杂任务. 

涉及磁盘数据的应用程序必须寻求高效的索引和缓冲方法来处理数据，以避免频繁读写磁盘。

虽然**计算思维**有自己的**独特性**，但它同时也**吸收**了**其他领域**的一些**思维方式**。

* 计算机科学家像数学家一样建立现实世界的**抽象模型**，使用**形式语言表达思想**；
* 像工程师一样  设计、制造、组装与现实世界打交道的产品，寻求更好的**工艺流程**来提高产品质量；
* 像自然   科学家一样观察系统行为，形成理论，并通过预测**系统**行为来检验**理论**；
* 像经济学家一样**评估代价与收益**，权衡多种选择的利弊；
* 像手工艺人一样追求作品的**简洁、精致、美观**，并在 作品中打上体现本人**风格**的烙印。

计算思维是**人的思想和方法**，旨在**利用计算机解决问题**，而不是使人类像计算机一样做事。
作为“思想和方法”，**计算思维是一种解决问题的能力**，一般不是可以机械地套用的，只能通过 学习和实践来培养。

计算机虽然机械而笨拙，但人类的思想赋予计算机以活力，装备了计算机的人类利用自己的计算思维能够解决过去无法解决的问题、建造过去无法建造的系统。

#### 问题表示

**抽象**(abstraction) 是用于**问题表示**的重要**思维工具**. 
一般意义上的抽象，就是指这种忽略研究对象的具体的或无关的特性，而抽取其一般的或相关的特性。
计算机科学中的抽象包括**数据抽象**和**控制抽象**，简言之就是将现实世界中的各种数量关系、空间关系、逻辑关系和处理过程等表示成计算机世界中的**数据结构**（数值、字符串、列表、堆栈、树等） 和**控制结构**（基本指令、顺序执行、分支、循环、模块等），或者说建立实际问题的计算模型。
另外，抽象还用于在不改变意义的前提下隐去或减少过多的具体细节，以便每次只关注少数  几个特性，从而有利于理解和处理复杂系统。
显然，通过抽象还能发现一些看似不同的问题的共性，从而建立相同的**计算模型**。
总之，抽象是计算机科学中广泛使用的思维方式， 只要有可能并且合适，程序员就应当使用抽象。
在不同层次上对数据和控制进行抽象，**不同抽象层级**对问题进行不同颗粒度或详细程度的描述。**我们经常在较低抽象级之上再建立一个较高的抽象级，以便隐藏低抽象级的复杂细节，提供更简单的求解方法**。
[电子电路-门逻辑-二进制-机器语言指令-高级语言程序]    这样一个**由低到高的抽象层次**
**我们之所以在高级语言程序这个层次上学习计算，当然是为了隐藏那些低抽象级的繁琐细节**。

#### 算法设计

问题得到表示之后，接下来的关键是找到问题的解法——算法。算法设计是计算思维大显身手的领域，计算机科学家采用多种思维方式和方法来发现有效的算法。
对于大型问题和复杂系统，很难得到直接的解法，这时计算机科学家会设法将原问题重新表述，降低问题难度，常用的方法包括**分解、化简、转换、嵌入、模拟**等。如果一个问题过于复杂难以得到精确解法，或者根本就不存在**精确解法**，计算机科学家不介意退而求其次，  寻求能得到**近似解法**，通过**牺牲精确性**来换取**有效性和可行性**，尽管这样做的结果可能 导致问题解是不完全的，或者结果中混有错误。

#### 编程技术

找到了解决问题的算法，接下来就要用**编程语言来实现算法**，这个领域同样是各种思想和方法的宝库。

**类型化与类型检查方法**

将待处理的数据划分为不同的数据类型，编译器 或解释器借此可以发现很多编程错误，这和自然科学中的量纲分析的思想是一致的。

**结构化编程方法**

使用规范的控制流程来组织程序的处理步骤，形成层次清晰、边界分明的结构 化构造，每个构造具有单一的入口和出口，从而使程序易于理解、排错、维护和验证正确性。

**模块化编程方法**

采取从全局到局部的自顶向下设计方法，将复杂程序分解成许多较小的 模块，解决了所有底层模块后，将模块组装起来即构成最终程序。

**面向对象编程方法**

以数据和操作融为一体的**对象为基本单位**来描述复杂系统，通过对象之间的相互协作和交互实现系统的功能。

程序设计不能只关注程序的**正确性和执行效率**，还要考虑良好的**编码风格**（包括变量命名、注释、代码缩进等提高程序易读性的要素）和程序美学问题。

编程范型（programming paradigm）是指计算机编程的总体风格，不同范型对编程要素（如数据、语句、函数等）有不同的概念，计算的流程控制也是不同的。
早期的**命令式**（或 称过程式）语言催生了**过程式**（procedural）范型，即一步一步地描述解决问题的过程。后来发明了面向对象语言，数据和操作数据的方法融为一体（对象），对象间进行交互而实现系统 功能，这就形成了**面向对象**（object-oriented）范型。逻辑式语言、函数式语言的发明催生了 **声明式**（declarative）范型——只告诉计算机“做什么”，而不告诉计算机“怎么做”。

### 可计算性与算法复杂性

* 在用计算机**解决问题**时，不仅要找出**正确的解法**，还要考虑解法的复杂度。**可能性,可行性,有效性**.

* **计算机科学的根本任务可以说是从本质上研究问题的可计算性**。

* 虽然很多问题对于计算机来说难度太高甚至是不可能的任务，但计算思维具有灵活、变通、实用的特点，对这样的问题可以去寻求不那么严格但现实可行的实用解法。

* 计算机所做的一切都是由确定性的程序决定的，以同样的输入执行程序必然得到同样的结果，因 此不可能实现真正的“随机性”。
* 但这并不妨碍我们利用确定性的“**伪随机数**”生成函数来**模拟现实**世界的**不确定性、随机性**。
* 当计算机有限的内存无法容纳复杂问题中的海量数据时，这个问题是否就不可解了呢？当然不是，计算机科学家设计出了**缓冲方法来分批处理数据**。
* 当许多用户共享并竞争 某些系统资源时，计算机科学家又利用**同步、并发控制**等技术来避免竞态和僵局。

**日常生活中的计算思维**

* 人们在日常生活中的很多做法其实都和计算思维不谋而合，也可以说计算思维从生活中吸收 了很多有用的思想和方法。
* **过程化, 函数化, 模块化, 结构化, 类型化**
* 读者在学习用计算机解决问题的时候，如果经常思考生活中遇到类似问题时的做法，一定会对找出问题解决方案有所帮助。

**Python简介**

* Python 语言最重要的设计理念是追求高度的可读性。与大多数语言不同，Python 语言的语法要求程序代码具有整齐而有条理的形式，代码的外在形式与内在意义紧密 相关。这样做的好处是：**外观不整齐的代码属于编程错误，从而提醒编程人员避免 很多错误。**
* Python 语言的另一个设计理念是尽量避免“这件事可以有多种做法”，因此语言中 冗余的成分很少，程序员经常只有唯一的也是最好的语言构造可用。
* Python 语言同时支持过程式、面向对象式和函数式等多种编程范型，拥有丰富的标 准库来支持应用开发所需的各种功能。
* Python 是解释型语言，Python 语句或程序（.py 文件）首先被解释器翻译成字节码（byte code），然后再由 Python 虚拟机来直接执行。


## 用数据表示现实世界

> 计算是利用计算机解决问题的过程
> 实现计算的程序相应地也要做两件事情：
> 第一，用特定**数据类型和数据结构**将**信息表示**出来；
> 第二，用**控制结构**将**信息处理过程表示**出来。

## 数据和数据类型数据

是对**现实的抽象**,抽象是对问题进行简化的重要手段。计算领域，我们将现实世界中的事实或信息用编程语言提供的符号化手段进 行表示，这种符号化表示称为数据（data）。为了用计算机解决一个问题，必须先对该问题进行抽象，定义问题在计算机中的数据表示。数据表示的选择，必须依据将对数据施加的操作来考虑，以便将来能够方便、高   效地处理数据。常量与变量数据类型字符的计算机内表示方法(编码)

### 数据处理的流程控制

>结构化程序设计方法的基本思想是只用顺序、条件分支和循环三种控制结构来编制程序， 并使整个程序由具有唯一入口和唯一出口的语句块相互串联、嵌套而成。这样的程序具有结 构清晰、易理解、易验证和易维护等优点。


### 顺序控制结构

![45991017276dca6f8b3fe177903c915f.png](en-resource://database/7715:1)

* 程序是一个语句序列，执行程序就是按特定的次序执行程序中的语句。**程序中执行点的变迁称为控制流程**，当**执行到程序中的某一条语句时，也说控制转到了该语句**。
* 由于复杂问 题的解法可能涉及复杂的执行次序，因此编程语言必须提供表达复杂控制流程的手段，称为编程语言的控制结构。
* 程序的控制流程可以用**流程图（flowchart）**来形象地表示。流程图采用标准化的图形符 号来描述程序的执行步骤，是一种常用的程序设计工具。
* 在较低的抽象级上，流程图中的每一个步骤可能都是单条语句，而在较高的抽象级上，每个步骤都可以是由多条语句构成的语句块。
* 命令式（或过程式）编程语言。 函数式和逻辑式编程语言中没有这里所说的控制流语句。
* **将若干低级别步骤看成整体并构成一个高级别步骤**的做法也是抽象的一种形式，是程序设计中广泛使用的思维方式

### 分支控制结构

编程语言中提供了根据条件来选择执行路径的控制结构，称为分支控制结构，也 称为条件或判断结构


单分支结构----两路分支结构----多路分支结构

### 循环控制结构




计算机是以一步一步执行指令的方式来解决问题的，程序员要做的事情就是将问题的解决方案表达成一步一步执行的指令序列。在解决问题的指令序列中，经常会遇到需要重复执 行的一组操作。

### 结构化程序设计

在设计阶段,我们经常要使用两种设计工具:程序**流程图**和**伪代码**. 对于复杂程序还需要适用于其他的工具,如**层次图**和**结构图** . 
软件开发中还有一件重要的事情，那就是**文档化**(包括程序注释)。

### 结构化程序设计的基本内容

* 一般来说，好的**程序**不但要能正确地**解决问题**，   而且还应该是执行**效率高、易理解、易维护、可扩展**的。
* 计算机科学家证明了所谓“**结构化定理**”：任何程 序逻辑都可以只用**顺序**、**条件分支**、**循环**这三种基本控制结构来实现。
* 我们在开发程序时，应该只使用这些基本控制结构，并将它们**串联**、**嵌套**在一起，从而搭建出整个程序。
* 单入口单出口的程序块: 编程语言的单条语句可以看成是只有一个入口和一个出口，因此前后相继的语句序列构成了单入口单出口的顺序控制结构。
* **程序设计的首要任务是找到正确的算法**，然后就应当去追求清晰的**程序结构**、代码的**执行效率**、功能的可扩展性、良好的风格等目标。
* 设计程序时应该多考虑如何使**程序更一般化**，毕竟**一般化程序**有可能**应用更多问题解决**当中。
* 当你所要解决的问题看起来很普通，可能有很多人已经遇到过这个问题，那么你就可以试着寻找该问题的**现成解法**。
* 初学编程时可以尽量自己从头开始设计一个算法，但**职业程序员都懂得借鉴、重用代码**。






## 模块化编程

>模块化编程（modular programming）是一种软件设计技术，它将软件分解为若干**独立的**、**可替换的**、具有**预定功能的**模块，每个模块实现一个功能，各模块通过接口（输入输出 部分）组合在一起，形成最终程序。

## 模块化编程基本概念

### 模块化编程的优点

* **易设计**：较大的**复杂问题** **分解**为若干较小的**简单问题**，使我们可以从抽象的模块功能角度而非具体的实现角度去理解软件系统，从而整个系统的结构非常清晰、容易  理解，设计人员在设计之初可以更加关注系统的顶层逻辑而非底层细节。
* **易实现**：模块化设计适合**团队开发**，因为每个团队成员不需要了解系统全貌，只需  关注所分配的小任务。另外团队可以灵活地增加人手，新人只需直接接手某个模块，  不会影响系统其他模块的开发。
* **易测试**：每个模块不但可以独立开发，也可以独立测试，最后组装时再进行联合测试。
* **易维护**：如果需要修改系统或者扩展系统功能，只需针对特定模块进行修改或者添加新模块。
* **可重用**：很多模块的代码都可以不加修改地用于其他程序的开发。

模块化编程实际上是一条**抽象设计原则**的具体体现，即**分离关注点**（Separation of Concerns，缩写为 SoC）原则。
所谓关注点，是指设计者关心的某个系统特性或行为；而分离关注点是指将系统分解为互不重叠的若干单元，每个单元对应于一个关注点。
在模块化编程中，**以程序的各个功能作为关注点**，模块划分就是分离关注点的结果。
**一个模块可以使用另一个模块来实现自己的功能**，但除此之外模块之间最好没有交互，这是 SoC 原则的理想目标。

### 编程语言对模块化编程的支持

**模块化编程的语言构造**

* 子程序(subprogram)  # Python 中不经常使用这一概念  因为 过程 和函数被统称为函数 就是一种子程序
* 过程（procedure）
* 函数（function）
* 模块(module)
* 包（package）

**Python中 子程序通常指的是函数**

子程序是指程序中的一段代码，它执行特定任务，并且与同一程序中的其他部分是相对独立的。

顾名思义，子程序也是程序，也是由许多计算步骤构成的指令序列；但抽象地看， 可以将一个子程序视为一个操作或高级指令，可以作为更大的程序中的一个简单步骤来使用。
在程序的一次执行中，可以多次、多处执行子程序。子程序概念虽然仍然有避免重复代码、减小程序大小的作用，但其更重要的目的是使程序更加模块化。

**子程序构造**一般涉及以下一些内容：

子程序的创建：定义子程序的名字和代码（程序体）。

子程序的调用和返回：调用就是要求执行子程序，而子程序执行完毕应当将控制返 回给调用者。

参数：相当于子程序所需的输入数据，一般需要预先声明参数的类型和个数，并在  调用时提供具体的参数值。

返回值：相当于子程序的输出数据，一般需要预先声明返回值的类型。

局部变量：子程序中定义的变量在子程序外部是不可见的，亦即子程序构成了一个 私有名字空间。这是子程序独立性的一种表现。

全局变量：子程序外部定义的变量如果被声明为全局变量，那么所有子程序都可以 共享使用、操作该变量。

**Python要求函数必须具有返回值，“过程”其实是返回某种特殊值（如Python 中的 None）的函数**

子程序是传统的过程式语言中的模块化构造。

模块化编程方法经过多年发展，又派生出 了面向对象编程方法。

在面向对象语言中，对象实际上就是模块概念的推广，传统模块之间 的调用接口相应地发展成了对象之间的消息传递接口。

### 用函数改善程序结构(减少重复代码和模块化)

### 用函数增强程序的通用性(参数化,一般性)


## 自顶向下设计

**设计和实现的思考模型是相反的**
一般到特殊
从简单到复杂 

分解嵌套 树形结构 所有路子都是通路, 无限分解和细分 总会越来越简单
自顶向下设计具有两个特征：

第一，要求设计者一开始就对整个系统有清楚的理解，否则第一步的分解就无法进行；
第二，任何子系统在足够细化之前无法开始编码实现，因而必须等到所有子系统都足够细化，才可能对系统编码实现及测试。

分解过程总是导致越来越小的程序部件，   最终必然达到“足够简单”的层次，因此不可能无限分解下去。

自顶向下设计中经常使用一种设计工具——结构图（或称模块层次图），其中用矩形表   示程序模块，用两个矩形之间的连线表示模块间的调用关系，在连线旁边用箭头和标注来指 明模块之间的界面信息。各模块分别处于不同层次，高层模块是调用模块（或控制模块）， 低层模块是被调用模块（或受控模块）。结构图最顶层就主程序（总控模块）。例如，calendar   程序的顶层设计可以用如图 4.7 所示的结构图来表示。
![0a7d892899c0c978c238855a13eed091.png](en-resource://database/6168:1)
在结构图中，越处于下层的模块，其细节程度就越高，即更加精化。

### 自底向上实现与单元测试

自顶向下设计设计是创建层次化的模块结构的过程，而从实现的角度看，我们又是采取了相 反的过程，即自底向上的实现。
从结构图的底层开始实现每一个函数，然后上一层模块自然得到实现。
就这样自底向上，直至主程序得到完全的实现。
在模块化编程中，测试程序最适合采用单元测试技术，即先分别测试每一个小模块，然后再逐步测试较大的模块，直至最后测试完整程序。
单元测试技术独立地测试每一个函数，这样能更容易定位程序错误。
如果较小模块都正确， 那么由它们组成的较大模块出现错误的可能性也就较小。最终测试完整程序时，就更有 希望通过测试。

### 开发过程小结

当面临一个复杂 问题而感到无从下手的时候，可以尝试将原始问题分解为若干个子问题，然后再去考虑每个子问题的解决方案。
这个分解过程可以重复进行，从结构图的顶层开始，自顶向下逐步求精， 直至得到所有子问题的精确代码。

**自顶向下设计过程可以概括为以下四个步骤**：

* 将**问题分解**为若干**子问题**；
* 为每个子问题设计一个**函数接口**；
* 将原问题的算法用各子问题对应的函数接口来表达；
* 对每个子问题重复（1）〜（3）的过程。 

模块化设计和单元测试都是分离关注点原则的具体体现，前者使我们能够设计复杂程序，后者使我们能够调试复杂程序。
作为初学者，应当不断地实践模块化方法，让模块化思想和方法变成自己的本能思维方式。

最后要说明一点，自顶向下设计是非常强大的编程技术，但并非唯一的编程技术，有时这种设计方法并不可行。
例如，自顶向下设计的第一步是对整个系统进行任务分解，然而在开发某些应用时，可能无法对整个系统的需求先有充分的理解，只能随着开发的进行，逐渐获得对系统的理解，这时就不可能采用自顶向下设计。


## Python模块

在 Python 语言中，模块对应于 Python 程序文件，即每个 Python 程序文件就是一个模块。
模块是 Python 程序的最高层结构单元，用于组织程序的代码和数据，以便能被同一程序的其他模块甚至被其他程序重用。
一个模块可以导入其他模块，导入后就可以使用其他模块中定义的函数、类等对象。


### Python程序架构

简单程序可以只用一个程序文件实现，但对绝大多数 Python 程序，一般都是由多个源 文件（即模块）组成的，其中每个源文件都是包含 Python 语句的文本文件。

具体来说，Python 程序通常是由一个顶层主文件和多个模块文件组成的。
顶层主文件 定义了程序的主控制流，是执行应用程序时的启动文件；模块文件则是“工具”库，用于汇集顶层文件和其他模块需要用到的函数等部件。
顶层文件使用模块文件中定义的工具来完成 应用功能，同时一个模块也可使用别的模块定义的工具。
**任何模块文件都可以从任何其他模块文件导入定义**
**除了作为最高层结构单元，模块还是代码重用的最高层形式**

### 标准库模块

应用程序要导入的模块大多来自 Python 语言提供的标准库。
Python 标准库实现了很多 常见功能（如操作系统功能、GUI 构建、网络与互联网编程等），对应用程序设计提供了强 大的支持。
标准库并不是 Python 语言本身的一部分，而是由专业程序员预先编好并随语言 提供给用户使用的。
Python 的标准安装都会自动安装标准库。
如果想了解随着 Python 安装的标准库中有哪些模块，可以使用 Python 的联机帮助命令。 在
Python 解释器提示符下键入 help()，可以进入联机帮助环境

在 Python 中，要想编写有用的或有趣的应用程序，往往**并不需要自己写很多代码**，**标准库中有大量的现成代码**可用。
读者需要时可自行查阅有关 Python 标准模块的资料，以求事半功倍。


## 图形编程(未完成)

>在现实中，人们经常利用直观的图形来表达抽象的思想，图形可以帮助人们设计产品、 理解数据、洞察规律。
>同样地，在用计算机解决问题时，也经常需要绘制图形。
>有些应用本  身就是图形图像应用，而另一些应用只是利用图形来使计算可视化。
>由于图形是复杂数据，对复杂数据的表示和操作最适合采用面向对象方法。


## 概述

### 计算可视化

可视化（visualization）是指将抽象事物和过程转变成视觉可见的、形象直观的图形图像表示。
计算可视化就是在用计算机解决问题的过程中，使用图形图像来表达数据和操作。  
图形图像所具有的直观性能使我们更有效地传达信息，即使这信息是非常抽象的。

### 数据可视化

数据可视化是指利用计算机图形学和图像处理技术，将海量数据转化为数据图像，以便帮助人们直观地观察数据。
对于多维数据（例如人事数据包含姓名、性别、学位、收入等多 种维度），利用数据图像还可以从不同的维度观察数据。
一般认为，数据、信息、知识构成  由低到高的三个层次，因此从数据可视化可以进而发展到更高层次的信息可视化（发现数据 中隐藏的模式、关联或趋势）和知识可视化（促进知识的传播）。

可视化最常见的应用当属图形用户界面（GUI）

计算机图形技术极大地增强了人们利用计算机解决问题的能力

### 图形是复杂数据

图形编程就是编写能创建和处理图形的程序。从一般的意义上说，图形也是数据，只不过与数值、字符串、列表等类型的数据相比，图形数据是非常复杂的数据。 
一个图形包含的信息是复杂的。

在编程语言中如何表示图形这一类的复杂数据、如何操作这类复杂数据呢？编程 语言一般没有内建的图形数据类型和对图形的操作，但会提供标准图形库用于支持图形编 程。
使用 Python 语言的标准图形库 Tkinter 来进行图形编程。现代的图形库一般都是采用面向对象技术来实现图形数据类型的。

### 用对象表示复杂数据

程序是对数据进行操作的过程，因此数据表示和操作过程是编程时要考虑的两大问题。 
先考虑数据的表示，然后再考虑对数据的操作，这就是迄今为止我们在编程序时常用的 思考方式。
然而还有另一种思考方式，那就是**将数据和对数据的操作视为不可分离的**，并将两者组合在一起形成一个实体——**对象**（object）。
对象是对传统“数据”概念的发展：**传统数据**只是**存储**一些**信息**，而对象中不但存储了一些信息，而且还掌握了对这些信息的操作。  在面向对象术语中，**对象的数据称为属性，对象的操作称为方法**。
一个对象不但知道一些信息，并且还负责操作这些信息。
要想对对象的数据执行特定操作，只需向对象发出请求消息，由对象来执行所需的方法。  
对象概念通常并不是用来描述如上例那样的简单数据的。
事实上，对象概念主要用于描述复杂数据、设计复杂系统。
**对象**将若干相关数据连同若干操作组合在一起，形成一种**结构单元**，从而复杂系统可以方便地设计成由许多对象组成，对象之间通过交互、协作来完成系统功能。
图形应用程序涉及图形这样的复杂数据以及对图形的各种操作，因此非常适合采用面向 对象概念。许多语言的图形库都是面向对象风格的


## 大量数据的表示和处理

>简单数据一般指单个数据，并且没有内部结构，  不可分割。
>复杂数据正相反，可在两方面呈现复杂性：
>一是数量多，即待处理的数据是由大量相互关联的成员数据组成的；
>二是有内部结构，即数据在内部由若干分量组成，每个分量  本身可能又由更小的分量组成。
>对于大量数据，可以用集合体数据类型来表示；对于数据的  内部结构，可以利用面向对象中的类来刻画。

## 概述

实际应用中所处理的数据经常是“大量同类型数据的集合”，例如一次物理实验获得的 大量实验数据、一篇文章中的所有单词、一幅画布上的所有图形等等，
这几个例子分别展示  了大量数值的集合、大量字符串的集合和大量对象的集合。
为了表示和处理大量数据，编程 语言提供了集合体数据类型，如 Python 中的列表（list）、元组（tuple）、字典（dict）、集合（set）和文件（file）等。 
一个问题中的大量数据通常是“相关的”，即数据之间存在特定的逻辑联系。
表示相关的大量数据时，必须将它们之间的逻辑联系也表示出来。
在程序设计中，    为了方便、高效地 处理大量相关数据，常将各数据按照某种合适的存储结构组织在一起，以便反映各数据之间的逻辑联系。
**数据结构**（data structure）是计算机科学的一个分支，专门研究如何将大量相关数据按特定的逻辑结构组织起来，以及如何高效地处理这些数据。
**存储数据**的**目的**是为了将来**处理数据**，故**存储结构**一定要适应将来的数据处理。对字符 串数据而言，将相关的一组字符存储为一个连续序列就是合适的，因为这种序列结构非常适 合取字符、取子串、合并等字符串操作。
编程语言通常都以“连续存储序列”的逻辑  结构来组织多个字符组成的数据，并将字符串作为基本类型提供给程序员使用。
如果不将组成复杂数据的大量数据项按照合适的逻辑关系组织起来，那么就无法对复杂数据进行方便、高效的处理。
合适的数据结构往往是设计有效算法的关键。
**算法 + 数据结构 ＝ 程序** 这足以说明数据结构的重要性。

## 有序/无序的数据集合体

> 大量数据按次序排列而形成的集合体称为序列（sequence）。
> 这里所说的“次序”是指各成员数据之间有位置的前后，并非指成员数据按值的大小来排列。就像一群人站成一 排即成序列，并不一定要按高矮顺序排列。
> Python 中的字符串、列表和元组数据类型都是序列
> **Python 序列其实都是以面向对象方式实现的，因此对序列的处理可以通过对序列对象的方法进行调用而实现。**
> **Python 中，每个字符串实际上都是一个对象，因而可以通过向字符串对象发送方法请求的方式来实现对字符串的操作。**

## 文件

CPU 只能读写内存，因此当程序运行时，程序所处理的数据必须存储在内  存中。
当程序结束或关机、掉电时，内存中的数据就会消失。
为了永久保存数据，必须将数   据存储在磁盘、光盘、闪存盘等不依赖于电源的外部存储器上。
另外，与外部存储器相比， 内存的容量小而价格高，不适合海量数据存储。
计算机问题求解必须考虑如何处理外  部存储器上的大量数据的问题。
列表、元组、字典等类型虽然可以用于表示大量数据，但它们都属于内存数据类型，是对内存数据的组织方式。
编程语言另外提供了**文件类型**来支持**大量数据**的**存储**和**处理**。

### 文件的基本概念

>外部存储器上的数据是以文件形式进行组织的。
>一组相关数据存储在一起便构成一个文件（file），每个文件被赋予一个文件名，程序通过文件名来访问文件。
>文件名通常由主名 和扩展名构成，后者用来描述文件内容，如常见的.txt、.jpg、.doc 等等。
>当外存上存储了大 量文件时，为便于管理，常将文件分组，构成一个个文件夹（或称目录）；
>如果每个文件夹 中的文件还是很多，则可以继续分组构成子文件夹（子目录），最终形成一个树形层次式目 录结构。

**目录路径**

**文件格式**

文件中存储的数据可以有不同的格式。
最简单的文件是文本文件，其中存储的数据是无格式的字符串，因此对文本文件的处理可以逐字符（字节）地进行。
另一种文件格式是二进 制文件，其中存储的数据是二进制串，这种二进制串当然不能按一个字节对应一个字符的方式来解释，例如存储图像、音频信息的.jpg、.mp3 文件就是常见的二进制文件。
至于.doc、.xls 和.ppt 等格式的文件各自具有独特的文件结构，也可以归入二进制文件类别，只能用专门的程序来处理。

在信息管理应用中，大量信息的组织通常都采用“**字段－记录－文件**”的层次格式。
**字段**是最基本的不可分割的数据项，如学号、姓名、年龄等；
**记录**是若干个相关字段结合在一 起形成的数据，例如将某个学生的基本信息组合起来就构成形如（5120309001，张三，18） 的记录；
大量同类型的记录即构成了**文件**，例如全体学生记录存储在磁盘上即构成一个学生 数据文件。

### 文件操作

常用计算机的人都知道，许多应用软件（如 Word、媒体播放器等）都需要处理文件， 并且都需要经过打开文件、读写文件、关闭文件的步骤，这其实是程序设计中文件处理的一   般过程的反映。

**打开文件**

在读写文件之前首先需要“打开”文件，这个步骤可以简单地理解为对磁盘文件进行必 要的初始化，至于其底层细节则无需了解。
Python 中的文件处理是面向对象风格的，即文件是一个对象，通过文 件对象的方法来实现文件操作        
Python 提供了函数 open 用于文件打开

**读取文件**

Python 中的文件采用类似的顺序读写过程：打开文件后，当前 读写位置就是文件开始处；随着读写命令的执行，当前读写位置不断改变，直至到达文件末 尾。

**写文件**

当文件以写方式打开时，可以向文件中写入文本内容。与读文件一样，写入位置也是由 “当前读写位置”决定的。

**关闭文件**

文件处理结束后需要关闭文件，这个步骤大体上涉及释放分配给文件的系统资源，以便 分配给其他文件使用。通过调用文件对象的 close 方法来关闭文件

即使程序中没有关闭文件，Python 程序结束时也会自动关闭所有打开的文件。
然而好的做法是由程序自己关闭文件，否则有可能因程序意外终止而导致文件数据丢失。
例如，以写方式打开文件时，如果向文件中写入了文本但还没有关闭文件，那么所写内容是不会存盘的。这时再以读方式打开同一文件，read()命令返回的是空串。

**文件处理程序的常见结构**

许多应用程序的算法结构都属于直接了当的 IPO（输入－处理－输出）模式. 

### 缓冲

利用计算机解决问题时，经常需要将大量数据从一个地方传送到另一个地方，并且一次 性地传送所有数据会遇到种种限制。
这时，可以在内存中建立一个缓冲区（buffer），用做传 送数据的临时过渡。通过缓冲区，就可以将大量数据以一小批一小批的方式传送到目的地。
处理一个很大的磁盘文件时，由于内存容量有限，无法一次性将文件内容全部读 入内存，只好在内存中建立一个缓冲区，每次将一小批数据读入缓冲区以供 CPU 处理。

**二进制文件**
Python 语言支持对二进制文件的处理，处理过程仍然是“打开－读写－关闭”三部曲。 **打开二进制文件时必须指明“以二进制方式打开”**，具体就是用"rb"、"wb"和"ab"

**文件的随机读取**

Python 文件对象提供的** seek()**方法可用于文件的随机存取

## 高级数据结构

### 链表(Linked list)

**链表的基本结构**
链表是通过一个个节点（Node）组成的，每个节点都包含了称为数据域(value)和指针域(next)的基本单元，它也是一种递归的数据结构。它能保持数据之间的逻辑顺序，但存储空间不必按照顺序存储。 
链表的基本元素有：
节点(Node)：每个节点有两个部分，左边部分称为值域，用来存放用户数据；右边部分称为指针域，用来存放指向下一个元素的指针。
head:head节点永远指向第一个节点
tail: tail永远指向最后一个节点
None:链表中最后一个节点的指针域为None值)

### 堆栈(Stack)

> 堆栈(stack) 是一种数据集合体, 其中的数据构成一种具有"后进先出(LIFO)"性质的数据结构,即最后加入堆栈的数据总是首先取出. 
> 现实中堆栈的例子俯拾皆是，例如碗橱里的一摞碗、纸箱里的一摞书、弹夹中的子弹等等，他们共同的特点是先放进 去的东西垫底，最后放进去的东西在顶上，而取东西的顺序正好相反。
> ![0f1dbb3921319c7cafe934d4f9e442b1.png](en-resource://database/6169:1)


* 一种后进先出(LIFO)的显性数据结构, 对堆栈的插入和删除操作都智能在栈顶(top)进行. 
* 堆栈可以通过数组和链表轻松实现

堆栈，是以如下两个操作进行处理的数据结构：
push(x)：在堆栈顶部推入一个新数据 x，x 即成为新的栈顶元素；
pop()：从堆栈中取出栈顶元素，显然被取出的元素只能是最后加入堆栈的元素。 
为了完善这两个操作，还需提供一些辅助操作，如：
isFull()：检查堆栈是否已满。如果堆栈具有固定大小，那么满了之后是无法执行 push()的；
isEmpty()：检查堆栈是否为空。如果堆栈是空的，那么 pop()操作将出错。

**堆栈**是一种 **抽象数据类型**，因为我们只规定了堆栈的操作方式，并没有规定操作的具体实现方式。

具体应用中，可以采用多种不同的方式来实现堆栈这个抽象数据类型

### 队列(queue)

队列（queue）也是数据集合体，其中的数据成员有序排列。
与堆栈的“后进先出”相 反，队列具有“先进先出（FIFO）”的性质，即最先加入队列的数据将最先移出队列。
现实 生活中，当很多人等待某项服务时，通常需要排队，这就是队列，排在最前面的人最先获得   服务。

**队列**是一种**抽象数据类型**，完全由操作定义其特性。

与堆栈的 push/pop 类似，队列的两个主要操作是：

enqueue：入队，即在队列尾部添加数据；
dequeue：出队，即将队列头部的数据移出队列作为返回值。

## 面向对象思想与编程


> 面向对象思想和方法具有强大的描述复杂数据和构建复杂系统的能力，因此面向对象编程已成为当今流行的编程范型，是大多数程序员在解决问题时的不二之选。


## 数据与操作

数据结构 + 算法(表示出来,并解决问题)
**任何计算机程序都是对特定数据进行特定处理的过程。**
当我们利用计算机解决问题时， 不外乎要做两件事情：

* 一是**将问题要处理的数据表示出来**，这可以借助编程语言提供的基本 数据类型、复杂类型构造手段以及更高级的逻辑数据结构等来实现；
* 二是**设计对这些数据进行处理的算法过程**，并利用编程语言提供的各种语句编制成一步一步执行的操作序列。

因 此， 用计算机解决问题的关键是确定问题所涉及的数据以及对数据的操作。

关于数据和操作这两部分的关系，在程序设计思想和方法的发展过程中存在两种不同的 观 点：

* 一种是传统的以操作为中心的面向过程观点，

* 一种是现代的以数据为中心的面向对象 观 点。

### 面向过程观点

面向过程:传统程序设计的思维方式。


到目前为止，我们在编程时基本上都是这样思考的：先用特定**数据类型**的常量或变量来 **表示** **数据**，然后再利用合适的**操作**按一定的步骤来**处理数据**。


在这种思考方式下，数据和对 数 据的操作被看作是分离的两件事情：数据只是信息的表示，不表达任何操作，在程序中处 于“被动”地位；
而对数据的操作在程序中则处于“主动”地位，是驱动程序实现特定功能 的力 量。

## 计算机科学

> 面对需求和问题, 使用抽象的数据类型和算法来使其可计算

定义1: **计算机科学是对问题，解决问题以及解决问题过程中产生的解决方案的研究。**给定一个问题，计算机科学家的目标是开发一个算法，一系列的指令列表，用于解决可能出现的问题的任何实例。算法遵循它有限的过程就可以解决问题。

### 为什么数据结构与抽象数据类型

### 为什么要学习算法

计算机科学家经常通过经验学习。我们通过看别人解决问题和自己解决问题来学习。接触不同的问题解决技术，看不同的算法设计有助于我们承担下一个具有挑战性的问题。通过思考许多不同的算法，我们可以开始开发模式识别，以便下一次出现类似的问题时，我们能够更好地解决它。

算法通常彼此完全不同。考虑前面看到的 `sqrt` 的例子。完全可能的是，存在许多不同的方式来实现细节以计算平方根函数。一种算法可以使用比另一种更少的资源。一个算法可能需要 10 倍的时间来返回结果。我们想要一些方法来比较这两个解决方案。即使他们都工作，一个可能比另一个“更好”。我们建议使用一个更高效，或者一个只是工作更快或使用更少的内存的算法。当我们研究算法时，我们可以学习分析技术，允许我们仅仅根据自己的特征而不是用于实现它们的程序或计算机的特征来比较和对比解决方案。

在最坏的情况下，我们可能有一个难以处理的问题，这意味着没有算法可以在实际的时间量内解决问题。重要的是能够区分具有解决方案的那些问题，不具有解决方案的那些问题，以及存在解决方案但需要太多时间或其他资源来合理工作的那些问题。

经常需要权衡，我们需要做决定。作为计算机科学家，除了我们解决问题的能力，我们还需要了解解决方案评估技术。最后，通常有很多方法来解决问题。找到一个解决方案，我们将一遍又一遍比较，然后决定它是否是一个好的方案。

## 基础语义

> 专业术语

### 调度 - dispatch/schedule

> 把指令加入行程

**调度**在计算机中是分配工作所需资源的方法。资源可以指虚拟的计算资源，如[线程](https://zh.wikipedia.org/wiki/线程)、[进程](https://zh.wikipedia.org/wiki/进程)或[数据流](https://zh.wikipedia.org/w/index.php?title=数据流&action=edit&redlink=1)；也可以指硬件资源，如[处理器](https://zh.wikipedia.org/wiki/处理器)、网络连接或[扩展卡](https://zh.wikipedia.org/wiki/扩展卡)。

进行调度工作的程序叫做调度器。调度器通常的实现使得所有计算资源都处于忙碌状态（在负载均衡中），允许多位用户有效地同时共享系统资源，或达到指定的[服务质量](https://zh.wikipedia.org/wiki/服务质量)。调度是计算自身的基础，同时也是[编程语言](https://zh.wikipedia.org/wiki/编程语言)计算模型固有的部分。调度器使得在单处理器上通过[多任务处理](https://zh.wikipedia.org/wiki/多任务处理)，从而让执行多个进程成为可能。

调度器可能会针对不同的目标设计，例如：[吞吐率](https://zh.wikipedia.org/w/index.php?title=吞吐率&action=edit&redlink=1)最大化、响应时间最小化、最低延迟[[1\]](https://zh.wikipedia.org/wiki/调度_(计算机)#cite_note-1)、或最大化公平。在实践中，这些目标通常是互相冲突的，因此，调度器会实现一个权衡利弊的折中方案，而侧重点则可能是前文提到的任何一种，这取决于用户的需求和目的。



### 缺省 - default

 在[程序设计](https://zh.wikipedia.org/wiki/程序设计)中，一个函数的**缺省参数**是指不必须指定值的参数。在大多数程序设计语言中，函数可以接受一个或多个参数。通常对于每个参数都需要指定它们的值（例如C语言）。一些较新的程序设计语言（例如C++）允许程序员设定缺省参数并指定默认值，当调用该函数并未指定值时，该缺省参数将为缺省值。 

## Unix/Linux文件系统

### inode : index node

[参考文档](http://www.ruanyifeng.com/blog/2011/12/inode.html): 理解inode

[维基百科-inode](https://zh.wikipedia.org/wiki/Inode)



## 处理器CPU

计算机的“大脑”是CPU，它从内存中取出指令并执行之。在每个CPU基本周期中，首先从内存中取出指令，解码以确定其类型和操作数，接着执行之，然后取指、解码并执行下一条指令。按照这一方式，程序被执行完成。

#### 寄存器

维基定义: 寄存器是有限存贮容量的高速存贮部件，它们可用来暂存指令、数据和地址。

作为程序员我们必须理解CPU是如何运行的，特别是要弄清楚负责保存指令和数据的寄存器的机制。了解了寄存器，也就自然而然的理解了程序的运行机制

#### 字长

**字长**: 在同一时间中处理二进制数的位数叫字长.一个字长可以是32位,也可以是64位,有CPU决定

字长是CPU的主要技术指标之一，指的是CPU一次能并行处理的二进制位数，字长总是8的整数倍，通常PC机的字长为16位（早期），32位，64位。

诚然，现在CPU大多是64位的，但大多都以32位字长运行，都没能展示它的字长的优越性，因为它必须与64位软件（如64位的操作系统等）相辅才成，也就是说，字长受软件系统的制约，例如，在32位软件系统中64位字长的CPU只能当32位用。

#### CPU的构成 

在程序运行流程中，CPU所负责的就是解析和运算最终转换成机器语言的程序内容。

不同CPU使用了不同的指令集

CPU从功能上来看由**寄存器**、**控制器**、**运算器**、**时钟**构成。
CPU是寄存器的集合体

寄存器：用来暂存指令、数据等处理对象。 
控制器：负责把内存上的指令、数据等读入寄存器、并根据指令的执行结果来控制计算机。 
运算器：负责运算从内存读入寄存器的数据。 
时钟：负责发出CPU开始计时的时钟信号





## 内存 - RAM

> 别名: 随机存取存储器(Random Access Memory) 	内部存储器	主存	

随机存取存储器: 是与CPU直接交换数据的内部存储器. 



特性: 可以随时读写, 而且速度很快, 通常作为操作系统或其他正在运行中的程序的临时数据存储介质

#### DRAM的特点

> DRAM: 动态随机存取存储器, 相当于RAM

**随机存取**

所谓“随机存取”，指的是当存储器中的消息被读取或写入时，所需要的时间与这段信息所在的位置无关。相对地，有串行访问存储器包括顺序访问存储器（如：磁带）和直接访问存储器（如：磁盘）。

**易失性**

当电源关闭时RAM不能保留数据。如果需要保存数据，就必须把它们写入一个长期的存储设备中（例如硬盘）。RAM和[ROM](https://zh.wikipedia.org/wiki/唯讀記憶體)相比，两者的最大区别是RAM在断电以后保存在上面的数据会自动消失，而ROM则不会。

**较高的访问速度**

现代的随机存取存储器几乎是所有访问设备中写入和读取速度最快的，访问延迟也和其他涉及机械运作的存储设备（如硬盘、光盘驱动器）相比，也显得微不足道。但速度仍然不如作为CPU缓存用的静态随机存储器[SRAM](https://zh.wikipedia.org/wiki/静态随机存取存储器)。

**需要刷新**

现代的随机存取存储器依赖RAM存储数据。电容器充满电后代表1（二进制），未充电的代表0。由于电容器或多或少有漏电的情形，若不作特别处理，电荷会渐渐随时间流失而使数据发生错误。**刷新**是指重新为电容器充电，弥补流失了的电荷。DRAM的读取即有刷新的功效，但一般的定时刷新并不需要作完整的读取，只需作该芯片的一个列（Row）选择，整列的数据即可获得刷新，而同一时间内，所有相关记忆芯片均可同时作同一列选择，因此，在一段期间内逐一做完所有列的刷新，即可完成所有存储器的刷新。需要刷新正好解释了随机存取存储器的易失性。

**对静电敏感**

正如其他精细的集成电路，随机存取存储器对环境的静电荷非常敏感。静电会干扰存储器内电容器的电荷，引致数据流失，甚至烧坏电路。故此触碰随机存取存储器前，应先用手触摸金属接地。

**价格不断下降**



### 内存机制





## 缓存 - Cache

## 数制与编码



# 计算机专题笔记



云存储



## 自动化运维

思路: 调用系统API, 调用服务器API 

现在越来越多的服务器都转到了云上，而主流的公有云、私有云平台都拥有比较完备的资源管理的API，这些API也就是构建一个自动化CMDB的基础。
新一代的自动化运维平台应该是可以基于这些API来自动维护和管理相关的服务器、存储、网络、负载均衡的资源的。 

通过API对资源的操作都应该被作为操作日志记录下来，以备作为后续操作审计的基础数据。

CMDB这个东西听上去是老生常谈，但这个确实是所有运维工具的基础设施。



API

# 云平台开发

云服务

云计算的实现原理: 通过硬件资源进行共享

软件: 编译原理

硬件: 

文件系统: 

CPU 最基本的原理:计算 逻辑门 存储

CPU



云服务: 云存储 + 云计算 + 云控制(客户端 / 调度中心 / 终端)

云平台: PaaS 

## 云计算

cloud computing

网格计算,早期的分布式计算

特征: 超大规模	虚拟化	高可靠性	通用	按需服务	极其低廉

分布式

SDN NFV

云原生

## 云存储





# Python工匠




# Python 工匠：善用变量来改善代码质量

## 变量和代码质量

作为『Python 工匠』系列文章的第一篇，我想先谈谈 『变量（Variables）』。因为如何定义和使用变量，一直都是学习任何一门编程语言最先要掌握的技能之一。

变量用的好或不好，和代码质量有着非常重要的联系。在关于变量的诸多问题中，为变量起一个好名字尤其重要。

### 内容目录

* [如何为变量起名](#如何为变量起名)
    * [1. 变量名要有描述性，不能太宽泛](#1-变量名要有描述性不能太宽泛)
    * [2. 变量名最好让人能猜出类型](#2-变量名最好让人能猜出类型)
        * [『什么样的名字会被当成 bool 类型？』](#什么样的名字会被当成-bool-类型)
        * [『什么样的名字会被当成 int/float 类型？』](#什么样的名字会被当成-intfloat-类型)
        * [其他类型](#其他类型)
    * [3. 适当使用『匈牙利命名法』](#3-适当使用匈牙利命名法)
    * [4. 变量名尽量短，但是绝对不要太短](#4-变量名尽量短但是绝对不要太短)
        * [使用短名字的例外情况](#使用短名字的例外情况)
    * [5. 其他注意事项](#5-其他注意事项)
* [更好的使用变量](#更好的使用变量)
    * [1. 保持一致性](#1-保持一致性)
    * [2. 尽量不要用 globals()/locals()](#2-尽量不要用-globalslocals)
    * [3. 变量定义尽量靠近使用](#3-变量定义尽量靠近使用)
    * [4. 合理使用 namedtuple/dict 来让函数返回多个值](#4-合理使用-namedtupledict-来让函数返回多个值)
    * [5. 控制单个函数内的变量数量](#5-控制单个函数内的变量数量)
    * [6. 及时删掉那些没用的变量](#6-及时删掉那些没用的变量)
    * [7. 能不定义变量就不定义](#7-能不定义变量就不定义)
* [结语](#结语)

## 如何为变量起名

在计算机科学领域，有一句著名的格言（俏皮话）：

> There are only two hard things in Computer Science: cache invalidation and naming things.
> 在计算机科学领域只有两件难事：缓存过期 和 给东西起名字
> 
> -- Phil Karlton

第一个『缓存过期问题』的难度不用多说，任何用过缓存的人都会懂。至于第二个『给东西起名字』这事的难度，我也是深有体会。在我的职业生涯里，度过的最为黑暗的下午之一，就是坐在显示器前抓耳挠腮为一个新项目起一个合适的名字。

编程时起的最多的名字，还数各种变量。给变量起一个好名字很重要，**因为好的变量命名可以极大提高代码的整体可读性。**

下面几点，是我总结的为变量起名时，最好遵守的基本原则。

### 1. 变量名要有描述性，不能太宽泛

在**可接受的长度范围内**，变量名能把它所指向的内容描述的越精确越好。所以，尽量不要用那些过于宽泛的词来作为你的变量名：

- **BAD**: `day`, `host`, `cards`, `temp`
- **GOOD**:  `day_of_week`, `hosts_to_reboot`, `expired_cards`

### 2. 变量名最好让人能猜出类型

所有学习 Python 的人都知道，Python 是一门动态类型语言，它（至少在 [PEP 484](https://www.python.org/dev/peps/pep-0484/) 出现前）没有变量类型声明。所以当你看到一个变量时，除了通过上下文猜测，没法轻易知道它是什么类型。

不过，人们对于变量名和变量类型的关系，通常会有一些直觉上的约定，我把它们总结在了下面。

#### 『什么样的名字会被当成 bool 类型？』

布尔类型变量的最大特点是：它只存在两个可能的值**『是』** 或 **『不是』**。所以，用 `is`、`has` 等非黑即白的词修饰的变量名，会是个不错的选择。原则就是：**让读到变量名的人觉得这个变量只会有『是』或『不是』两种值**。

下面是几个不错的示例：

- `is_superuser`：『是否超级用户』，只会有两种值：是/不是
- `has_error`：『有没有错误』，只会有两种值：有/没有
- `allow_vip`：『是否允许 VIP』，只会有两种值：允许/不允许
- `use_msgpack`：『是否使用 msgpack』，只会有两种值：使用/不使用
- `debug`：『是否开启调试模式』，被当做 bool 主要是因为约定俗成

#### 『什么样的名字会被当成 int/float 类型？』

人们看到和数字相关的名字，都会默认他们是 int/float 类型，下面这些是比较常见的：

- 释义为数字的所有单词，比如：`port（端口号）`、`age（年龄）`、`radius（半径）` 等等
- 使用 _id 结尾的单词，比如：`user_id`、`host_id`
- 使用 length/count 开头或者结尾的单词，比如： `length_of_username`、`max_length`、`users_count`

**注意：**不要使用普通的复数来表示一个 int 类型变量，比如 `apples`、`trips`，最好用 `number_of_apples`、`trips_count` 来替代。

#### 其他类型

对于 str、list、tuple、dict 这些复杂类型，很难有一个统一的规则让我们可以通过名字去猜测变量类型。比如 `headers`，既可能是一个头信息列表，也可能是包含头信息的 dict。

对于这些类型的变量名，最推荐的方式，就是编写规范的文档，在函数和方法的 document string 中，使用 sphinx 格式（[Python 官方文档使用的文档工具](http://www.sphinx-doc.org/en/stable/)）来标注所有变量的类型。 

### 3. 适当使用『匈牙利命名法』

第一次知道『[匈牙利命名法](https://en.wikipedia.org/wiki/Hungarian_notation)』，是在 [Joel on Software 的一篇博文](http://www.joelonsoftware.com/articles/Wrong.html)中。简而言之，匈牙利命名法就是把变量的『类型』缩写，放到变量名的最前面。

关键在于，这里说的变量『类型』，并非指传统意义上的 int/str/list 这种类型，而是指那些和你的代码业务逻辑相关的类型。

比如，在你的代码中有两个变量：`students` 和 `teachers`，他们指向的内容都是一个包含 Person 对象的 list 。使用『匈牙利命名法』后，可以把这两个名字改写成这样：

students -> `pl_students`
teachers -> `pl_teachers`

其中 pl 是 **person list** 的首字母缩写。当变量名被加上前缀后，如果你看到以 `pl_` 打头的变量，就能知道它所指向的值类型了。

很多情况下，使用『匈牙利命名法』是个不错的主意，因为它可以改善你的代码可读性，尤其在那些变量众多、同一类型多次出现时。注意不要滥用就好。

### 4. 变量名尽量短，但是绝对不要太短

在前面，我们提到要让变量名有描述性。如果不给这条原则加上任何限制，那么你很有可能写出这种描述性极强的变量名：`how_much_points_need_for_level2`。如果代码中充斥着这种过长的变量名，对于代码可读性来说是个灾难。

一个好的变量名，长度应该控制在 **两到三个单词左右**。比如上面的名字，可以缩写为 `points_level2`。

**绝大多数情况下，都应该避免使用那些只有一两个字母的短名字**，比如数组索引三剑客 `i`、`j`、`k`，用有明确含义的名字，比如 person_index 来代替它们总是会更好一些。

#### 使用短名字的例外情况

有时，上面的原则也存在一些例外。当一些意义明确但是较长的变量名重复出现时，为了让代码更简洁，使用短名字缩写是完全可以的。但是为了降低理解成本，同一段代码内最好不要使用太多这种短名字。

比如在 Python 中导入模块时，就会经常用到短名字作为别名，像 Django i18n 翻译时常用的 `gettext` 方法通常会被缩写成 `_` 来使用*（from django.utils.translation import ugettext as _）*

### 5. 其他注意事项

其他一些给变量命名的注意事项：

- 同一段代码内不要使用过于相似的变量名，比如同时出现 `users`、`users1`、 `user3` 这种序列
- 不要使用带否定含义的变量名，用 `is_special` 代替 `is_not_normal`

## 更好的使用变量

前面讲了如何为变量取一个好名字，下面我们谈谈在日常使用变量时，应该注意的一些小细节。

### 1. 保持一致性

如果你在一个方法内里面把图片变量叫做 `photo`，在其他的地方就不要把它改成 `image`，这样只会让代码的阅读者困惑：『`image` 和 `photo` 到底是不是同一个东西？』

另外，虽然 Python 是动态类型语言，但那也不意味着你可以用同一个变量名一会表示 str 类型，过会又换成 list。**同一个变量名指代的变量类型，也需要保持一致性。**

### 2. 尽量不要用 globals()/locals()

也许你第一次发现 globals()/locals() 这对内建函数时很兴奋，迫不及待的写下下面这种极端『简洁』的代码：

```python
def render_trip_page(request, user_id, trip_id):
    user = User.objects.get(id=user_id)
    trip = get_object_or_404(Trip, pk=trip_id)
    is_suggested = is_suggested(user, trip)
    # 利用 locals() 节约了三行代码，我是个天才！
    return render(request, 'trip.html', locals())
​```

千万不要这么做，这样只会让读到这段代码的人（包括三个月后的你自己）痛恨你，因为他需要记住这个函数内定义的所有变量（想想这个函数增长到两百行会怎么样？），更别提 locals() 还会把一些不必要的变量传递出去。

更何况， [The Zen of Python（Python 之禅）](https://www.python.org/dev/peps/pep-0020/) 说的清清楚楚：**Explicit is better than implicit.（显式优于隐式）**。所以，还是老老实实把代码写成这样吧：

​```python
    return render(request, 'trip.html', {
        'user': user,
        'trip': trip,
        'is_suggested': is_suggested
    })
```

### 3. 变量定义尽量靠近使用

这个原则属于老生常谈了。很多人（包括我）在刚开始学习编程时，会有一个习惯。就是把所有的变量定义写在一起，放在函数或方法的最前面。

```python
def generate_trip_png(trip):
    path = []
    markers = []
    photo_markers = []
    text_markers = []
    marker_count = 0
    point_count = 0
    ... ...
​```

这样做只会让你的代码『看上去很整洁』，但是对提高代码可读性没有任何帮助。

更好的做法是，**让变量定义尽量靠近使用**。那样当你阅读代码时，可以更好的理解代码的逻辑，而不是费劲的去想这个变量到底是什么、哪里定义的？

### 4. 合理使用 namedtuple/dict 来让函数返回多个值

Python 的函数可以返回多个值：

​```python
def latlon_to_address(lat, lon):
    return country, province, city

# 利用多返回值一次解包定义多个变量
country, province, city = latlon_to_address(lat, lon)
```

但是，这样的用法会产生一个小问题：如果某一天， `latlon_to_address` 函数需要返回『城区（District）』时怎么办？

如果是上面这种写法，你需要找到所有调用 `latlon_to_address` 的地方，补上多出来的这个变量，否则 *ValueError: too many values to unpack* 就会找上你：

```python
country, province, city, district = latlon_to_address(lat, lon)
# 或者使用 _ 忽略多出来的返回值
country, province, city, _ = latlon_to_address(lat, lon)
```

对于这种可能变动的多返回值函数，使用 namedtuple/dict 会更方便一些。当你新增返回值时，不会对之前的函数调用产生任何破坏性的影响：

```python
# 1. 使用 dict
def latlon_to_address(lat, lon):
    return {
        'country': country,
        'province': province,
        'city': city
    }

addr_dict = latlon_to_address(lat, lon)

# 2. 使用 namedtuple
from collections import namedtuple

Address = namedtuple("Address", ['country', 'province', 'city'])

def latlon_to_address(lat, lon):
    return Address(
        country=country,
        province=province,
        city=city
    )

addr = latlon_to_address(lat, lon)
​```

不过这样做也有坏处，因为代码对变更的兼容性虽然变好了，但是你不能继续用之前 `x, y = f()` 的方式一次解包定义多个变量了。取舍在于你自己。

### 5. 控制单个函数内的变量数量

人脑的能力是有限的，研究表明，人类的短期记忆只能同时记住不超过十个名字。所以，当你的某个函数过长（一般来说，超过一屏的的函数就会被认为有点过长了），包含了太多变量时。请及时把它拆分为多个小函数吧。

### 6. 及时删掉那些没用的变量

这条原则非常简单，也很容易做到。但是如果没有遵守，那它对你的代码质量的打击是毁灭级的。会让阅读你代码的人有一种被愚弄的感觉。

​```python
def fancy_func():
    # 读者心理：嗯，这里定义了一个 fancy_vars
    fancy_vars = get_fancy()
    ... ...（一大堆代码过后）

    # 读者心理：这里就结束了？之前的 fancy_vars 去哪了？被猫吃了吗？
    return result
```

所以，请打开 IDE 的智能提示，及时清理掉那些定义了但是没有使用的变量吧。

### 7. 能不定义变量就不定义

有时候，我们定义变量时的心理活动是这样的：『嗯，这个值未来说不定会修改/二次使用』，让我们先把它定义成变量吧！

```python
def get_best_trip_by_user_id(user_id):
    user = get_user(user_id)
    trip = get_best_trip(user_id)
    result = {
        'user': user,
        'trip': trip
    }
    return result
```

其实，你所想的『未来』永远不会来，这段代码里的三个临时变量完全可以去掉，变成这样：

```python
def get_best_trip_by_user_id(user_id):
    return {
        'user': get_user(user_id),
        'trip': get_best_trip(user_id)
    }
```

没有必要为了那些可能出现的变动，牺牲代码当前的可读性。如果以后有定义变量的需求，那就以后再加吧。

## 结语

碎碎念了一大堆，不知道有多少人能够坚持到最后。变量作为程序语言的重要组成部分，值得我们在定义和使用它时，多花一丁点时间思考一下，那样会让你的代码变得更优秀。

这是『Python 工匠』系列文章的第一篇，不知道看完文章的你，有没有什么想吐槽的？请留言告诉我吧。

[>>>下一篇【2.编写条件分支代码的技巧】](2-if-else-block-secrets.md)

> 文章更新记录：
> 
> - 2018.04.09：根据 @onlyice 的建议，添加了 namedtuple 部分
