---
keywords: ["大模型", "机器学习", ]
---





# 人工智能

侯哥: 逻辑性  + 业务理解能力

侯哥-机器学习笔记

YOLO :图像识别

理解原理, 使用API

## 机器学习相关概念

### 人工智能

> AI - Artificial Intelligence 

定义1: 人工智能就是要让机器的行为看起来就像是人所表现出的智能行为一样(1956达特茅斯回忆)

定义2: 用机器来模仿人类学习以及其他方面的智能

定义3: 研究、开发用于模拟、延伸和扩展人的智能的理论、方法、技术及应用系统的一门新的技术科学

AI的核心问题包括建构能够跟人类似甚至超卓的推理、知识、规划、学习、交流、感知、移物、使用工具和操控机械的能力等

**主要分支**

- 计算机视觉(CV: computer vision)
- 自然语言处理(NLP):文本挖掘和分类(标签)
- 语音识别
- 机器翻译
- 机器人



**人工智能发展必备三要素**：数据、算法、计算力



**GPU与 CPU**：

GPU 加速计算可以将应用程序**计算密集部分**的工作负载转移到 GPU，同时仍由 CPU 运行其余程序代码。**从用户的角度来看，应用程序的运行速度明显加快.**

CPU：由专为顺序串行处理而优化的几个核心组成，而 GPU 则拥有一个由**数以千计的更小、更高效的核心**（专为同时处理多重任务而设计）组成的大规模并行计算架构.

**CPU**需要很强的通用性来处理各种不同的数据类型，同时又要逻辑判断又会引入大量的分支跳转和中断的处理。**这些都使得CPU的内部结构异常复杂。而**GPU**面对的则是类型高度统一的、相互无依赖的大规模数据和不需要被打断的纯净的计算环境**。GPU采用了数量众多的计算单元和超长的流水线，但只有非常简单的控制逻辑并省去了Cache。而CPU不仅被Cache占据了大量空间，而且还有复杂的控制逻辑和诸多优化电路，相比之下计算能力只是CPU很小的一部分.

CPU适用于IO密集型，GPU适用于计算密集型

**提问：什么类型的程序适合在GPU上运行？**

（1）**计算密集型的程序。**所谓计算密集型(Compute-intensive)的程序，就是其大部分运行时间花在了寄存器运算上，寄存器的速度和处理器的速度相当，从寄存器读写数据几乎没有延时。可以做一下对比，读内存的延迟大概是几百个时钟周期；读硬盘的速度就不说了，即便是SSD, 也实在是太慢了。　　

（2）**易于并行的程序。**GPU其实是一种SIMD(Single Instruction Multiple Data)架构， 他有成百上千个核，每一个核在同一时间最好能做同样的事情。

### 机器学习

> Machine Learning	

定义1:机器学习是从**数据**中**自动分析获得模型**，并利用**模型**对未知数据进行预测。

**人工智能和机器学习，深度学习的关系**

​	机器学习是人工智能的一个实现途径

​	深度学习是机器学习的一个方法发展而来

### 特征工程

特征工程是使用**专业背景知识和技巧处理数据**，**使得特征能在机器学习算法上发挥更好的作用的过程**。

意义：会直接影响机器学习的效果

吴恩达: 数据和特征决定了机器学习的上限，而模型和算法只是逼近这个上限而已。

Andrew Ng: Coming up with features is difficult, time-consuming, requires expert knowledge. “Applied machine learning” is basically feature engineering.

### 提示工程Prompt Engineering

### 逻辑

> 推理 logic

逻辑通常可分为三个部分：[归纳推理](https://zh.wikipedia.org/wiki/归纳推理)、[溯因推理](https://zh.wikipedia.org/wiki/溯因推理)和[演绎推理](https://zh.wikipedia.org/wiki/演绎推理)。

**归纳推理**: 是由个别到一般的推理方法。是论证的前提支持结论但不确保结论的推理过程。它基于对特殊的代表（token）的有限观察，把性质或关系归结到类型；或基于对反复再现的现象的模式（pattern）的有限观察，公式表达规律。

**溯因推理**: 是推理（结果）到最佳解释（原因）的过程。**把事实当做结果**，换句话说，它是开始于事实的集合，并推导出其最佳解释的推理过程。有时使用术语 **溯因**(abduction)意味生成假设来解释观察或结论.

**演绎推理**: 是原因到结果的推导。**把事实当做原因**，从一般性的前提出发，通过推导即“演绎”，得出具体陈述或个别结论的过程。演绎推理要求大前提，小前提必须为真

​	定义1：由一般到特殊的推理方法。推论前提与结论之间的联系是必然的，是一种确实性推理。

​	定义2：前提和结论之间具有必然联系的推理

​	定义3：前提蕴涵结论的推理

​	定义4：演绎推理就是前提与结论之间具有充分条件或充分必要条件联系的必然性推理

#### 溯因与演绎的区别

溯因推理: 允许推导 **原因** 作为 **结果** 的结论, 溯因是**解释**已知事物的过程，目标是解释原因(现象)

演绎推理: 允许推导 **结果** 作为 **原因** 的结论, 演绎是**推导**已知事物的推论，目标是得出结论(原理)

在数学里，逻辑是指形式逻辑和数理逻辑，形式逻辑是研究某个形式语言的有效推论。主要是演绎推理。数理逻辑是研究抽象逻辑关系和数	学基本的问题。

#### 归纳与演绎的区别

> 两种的目标都是为了得出某种结论,是两种不同的方法论. 多数人学习的[形式逻辑](https://zh.wikipedia.org/wiki/形式逻辑)是演绎的而不是归纳的。相对于演绎推理，归纳推理达成的结论并非必然与最初的假定有相同的确定程度。
>
> **演绎推理** 区别于 **溯因推理** 和 **归纳推理** ：它们的前提可以预测出高概率的结论，但是不确保结论为真。

**归纳**: 由个别到一般的推理. 用于解决和预测不确定性问题.从特殊归纳出普遍。结论明显不是确定的,前提原因到结果具有普遍性. 

**演绎**: 由一般到特殊的推理. 用于确定性推理.由一般推导出特殊. 结论是一般是确定的, 前提是原因到结果有确定联系.原因和结果都具有确定性



其他区别:

- **思维进程不同**。归纳推理的思维进程是从个别到一般，而演绎推理的思维进程不是从个别到一般，是一个必然地得出的思维进程。
- **对前提真实性的要求不同。**演绎推理要求大前提，小前提必须为真。归纳推理则没有这个要求。
- **结论所断定的知识范围不同。**演绎推理的结论没有超出前提所断定的知识范围。归纳推理除了完全归纳推理，结论都超出了前提所断定的知识范围。
- **前提与结论间的联系程度不同。**演绎推理的前提与结论间的联系是必然的，也就是说，前提真实，推理形式正确，结论就必然是真的。归纳推理除了完全归纳推理前提与结论间的联系是必然的外，前提和结论间的联系都是或然的，也就是说，前提真实，推理形式也正确，但不能必然推出真实的结论。

联系

1，演绎推理如果要以一般性知识为前提，（演绎推理未必都要以一般性知识为前提）则通常要依赖归纳推理来提供一般性知识。

2，归纳推理离不开演绎推理。

#### 逻辑学基本原理

[同一律](https://zh.wikipedia.org/wiki/同一律)（the law of identity）

事物跟其自身相等同，“自己”不能“不是自己”。

[无矛盾律](https://zh.wikipedia.org/wiki/无矛盾律)（the law of non-contradiction）

事物不能同时“是”跟“不是”。是就是，不是就不是。

[排中律](https://zh.wikipedia.org/wiki/排中律)（the law of excluded middle）

事物只能有“是”或“不是”两种状态，不存在其他中间状态。

[充足理由律](https://zh.wikipedia.org/wiki/充足理由律)（the law of sufficient reason）

任何事物都有其存在的充足理由。

## 机器学习工作流程

### 学习目标

[了解机器学习定义](#机器学习)

了解机器学习的工作流程

行 -  样本 列 -- 特征 

数据处理 和特征工程  非常重要

### 工作流程总结

1. 获取数据
2. 数据基本处理
3. 特征工程
4. 机器学习(模型训练)
5. 模型评估

#### 1. 获取到的数据集 

##### 在数据集中一般:

- 一行数据我们称为一个 **样本**
- 一列数据我们称为一个 **特征**
- 有些数据有 **目标值(标签值)** , 有些数据没有目标值

##### 数据类型构成

- 数据类型一: 特征值 + 目标值(连续和离散)

- 数据类型二: 只有特征值, 没有目标值

##### 数据分割

- 机器学习一般的数据集会划分为两个部分: 
  - 训练数据(70-80%): 用于训练, **构建模型**
  - 测试数据(20-30%): 在模型检验时使用, 用于 **评估模型是否有效**

#### 2. 数据基本处理

即对数据进行缺失值, 去除异常值等处理. 数据清洗

#### 3. 特征工程

[特征工程简介](#特征工程)

特征工程包含的内容: 特征提取, 特征预处理, 特征降维

##### 特征提取

特征提取: 将任意数据(如文本或图像)转换为可用于机器学习的数字特征

![特征提取](https://wwfyde.oss-cn-hangzhou.aliyuncs.com/images/20210427103827.png)

##### 特征预处理

特征与处理: 通过**一些转换函数**将特征数据**转换成更加适合算法模型**的特征数据过程

![特征预处理](https://wwfyde.oss-cn-hangzhou.aliyuncs.com/images/20210427103832.png)

##### 特征降维

特征降维: 指在某些限定条件下，**降低随机变量(特征)个数**，得到**一组“不相关”主变量**的过程

![特征降维](https://wwfyde.oss-cn-hangzhou.aliyuncs.com/images/20210427103836.png)

#### 4. **机器学习**

机器学习: 选择合适的算法对模型进行训练

#### 5. **模型评估**

模型评估: 对训练好的模型进行评估

### 完整机器学习项目流程

**1** **抽象成数学问题**

明确问题是进行机器学习的第一步。机器学习的训练过程通常都是一件非常耗时的事情，胡乱尝试时间成本是非常高的。

这里的抽象成数学问题，指的明确我们可以获得什么样的数据，抽象出的问题，是一个分类还是回归或者是聚类的问题。

**2** **获取数据**

数据决定了机器学习结果的上限，而算法只是尽可能逼近这个上限。

数据要有代表性，否则必然会过拟合。

而且对于分类问题，数据偏斜不能过于严重，不同类别的数据数量不要有数量级的差距。

而且还要对数据的量级有一个评估，多少个样本，多少个特征，可以估算出其对内存的消耗程度，判断训练过程中内存是否能够放得下。如果放不下就得考虑改进算法或者使用一些降维的技巧了。如果数据量实在太大，那就要考虑分布式了。

**3** **特征预处理与特征选择**

良好的数据要能够提取出良好的特征才能真正发挥作用。

特征预处理、数据清洗是很关键的步骤，往往能够使得算法的效果和性能得到显著提高。归一化、离散化、因子化、缺失值处理、去除共线性等，数据挖掘过程中很多时间就花在它们上面。这些工作简单可复制，收益稳定可预期，是机器学习的基础必备步骤。

筛选出显著特征、摒弃非显著特征，需要机器学习工程师反复理解业务。这对很多结果有决定性的影响。特征选择好了，非常简单的算法也能得出良好、稳定的结果。这需要运用特征有效性分析的相关技术，如相关系数、卡方检验、平均互信息、条件熵、后验概率、逻辑回归权重等方法。

**4** **训练模型与调优**

直到这一步才用到我们上面说的算法进行训练。现在很多算法都能够封装成黑盒供人使用。但是真正考验水平的是调整这些算法的（超）参数，使得结果变得更加优良。这需要我们对算法的原理有深入的理解。理解越深入，就越能发现问题的症结，提出良好的调优方案。

**5** **模型诊断**

如何确定模型调优的方向与思路呢？这就需要对模型进行诊断的技术。

过拟合、欠拟合 判断是模型诊断中至关重要的一步。常见的方法如交叉验证，绘制学习曲线等。过拟合的基本调优思路是增加数据量，降低模型复杂度。欠拟合的基本调优思路是提高特征数量和质量，增加模型复杂度。

误差分析 也是机器学习至关重要的步骤。通过观察误差样本全面分析产生误差的原因:是参数的问题还是算法选择的问题，是特征的问题还是数据本身的问题……

诊断后的模型需要进行调优，调优后的新模型需要重新进行诊断，这是一个反复迭代不断逼近的过程，需要不断地尝试， 进而达到最优状态。

**6** **模型融合**

一般来说，模型融合后都能使得效果有一定提升。而且效果很好。

工程上，主要提升算法准确度的方法是分别在模型的前端（特征清洗和预处理，不同的采样模式）与后端（模型融合）上下功夫。因为他们比较标准可复制，效果比较稳定。而直接调参的工作不会很多，毕竟大量数据训练起来太慢了，而且效果难以保证。

**7** **上线运行**

这一部分内容主要跟工程实现的相关性比较大。工程上是结果导向，模型在线上运行的效果直接决定模型的成败。 不单纯包括其准确程度、误差等情况，还包括其运行的速度(时间复杂度)、资源消耗程度（空间复杂度）、稳定性是否可接受。

这些工作流程主要是工程实践上总结出的一些经验。并不是每个项目都包含完整的一个流程。这里的部分只是一个指导性的说明，只有大家自己多实践，多积累项目经验，才会有自己更深刻的认识。

## 机器学习算法分类

> 了解机器学习常用算法的分类

#### 概括

根据数据集组成不同, 可以把机器学习算法分类:

- 监督学习:输入数据有特征有标签, 即有标准答案
  - 回归问题
  - 分类问题
- 无监督学习: 只有特征值, 没有目标值,输入数据有特征无标签, 即无标准答案
- 半监督学习
- 强化学习

#### 监督学习

 -- 有特征值, 有目标值:  基于特征来判断目标的某一特征

**目标值**(标签值):要预测的目标结果

监督学习算法常用来做预测

定义:输入数据时有输入特征值和目标值所组成. 函数的的输出可以是一个连续的值(称为**回归** ), 或是输出是有限个离散值(称为 **分类** )

**得分函数**

##### 回归问题

应用场景: 预测房价, 用户点击, 购买预测, ,根据样本集拟合出一条连续曲线

![回归问题](https://wwfyde.oss-cn-hangzhou.aliyuncs.com/images/20210427103842.png)

##### 分类问题

应用场景: 根据肿瘤特征判断良性还是恶性，得到的是结果是“良性”或者“恶性”，是离散的。

![分类问题](https://wwfyde.oss-cn-hangzhou.aliyuncs.com/images/20210427103847.png)

#### 无监督学习

无监督学习: 输入数据是由输入特征值组成

输入数据没有被标记, 也没有确定的结果. 样本数据类别未知，需要根据样本间的相似性对样本集进行分类（聚类，clustering）试图使类内差距最小化，类间差距最大化。

用来训练和学习, 有时候联目标是什么都不知道, 智能通过特征来预测是哪一类的

应用场景: 邮件 / 新闻聚类 

![无监督学习](https://wwfyde.oss-cn-hangzhou.aliyuncs.com/images/20210427103853.png)

**有监督无监督算法对比**

监督学习: 研究分类和回归问题, 输入数据有特征有标签, 即有标准答案

无监督学习: 研究聚类	`	问题, 输入数据有特征无标签, 即无标准答案

![](https://wwfyde.oss-cn-hangzhou.aliyuncs.com/images/20210427103858.png)

#### 半监督学习

 -- 有特征值, 一部分有目标值

半监督学习：即训练集同时包含有标记样本数据和未标记样本数据。

#### 强化学习

> 动态过程, 上一步数据的输出, 是下一步数据的输入

强化学习：实质是，make decisions 问题，即自动进行决策，并且可以做连续决策。

应用场景: 动态系统, 机器人控制

举例：

小孩想要走路，但在这之前，他需要先站起来，站起来之后还要保持平衡，接下来还要先迈出一条腿，是左腿还是右腿，迈出一步后还要迈出下一步。

小孩就是 **agent**，他试图通过采取**行动**（即行走）来操纵**环境**（行走的表面），并且从**一个状态转变到另一个状态**（即他走的每一步），当他完成任务的子任务（即走了几步）时，孩子得到**奖励**（给巧克力吃），并且当他不能走路时，就不会给巧克力。

四要素: agent, action, environment, reward

![强化学习抽象](https://wwfyde.oss-cn-hangzhou.aliyuncs.com/images/20210427103904.png)

强化学习的目标就是**获得最多的累计奖励**。

监督学习和强化学习的对比

|          | **监督学习**                                                 | **强化学习**                                                 |
| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 反馈映射 | 输入到输出的一个映射，监督式学习输出的是之间的关系，可以告诉算法什么样的输入对应着什么样的输出。 | 输入到输出的一个映射，强化学习输出的是给机器的反馈 reward function，即用来判断这个行为是好是坏。 |
| 反馈时间 | 做了比较坏的选择会立刻反馈给算法。                           | 结果反馈有延时，有时候可能需要走了很多步以后才知道以前的某一步的选择是好还是坏。 |
| 输入特征 | 输入是独立同分布的。                                         | 面对的输入总是在变化，每当算法做出一个行为，它影响下一次决策的输入。 |
| 行为模式 | 不考虑行为间的平衡，只是开发（exploitation）。               | 一个 agent 可以在探索和开发（exploration and exploitation）之间做权衡，并且选择一个最大的回报。 |

![alpha zero](https://wwfyde.oss-cn-hangzhou.aliyuncs.com/images/20210427103911.png)

拓展阅读：Alphago进化史 漫画告诉你Zero为什么这么牛http://sports.sina.com.cn/chess/weiqi/2017-10-21/doc-ifymyyxw4023875.shtml

### 机器学习算法分类

- **监督学习(supervised learning)（预测）**

  - 定义：输入数据是由输入特征值和目标值所组成。函数的输出可以是一个连续的值(称为回归），或是输出是有限个离散值（称作分类）。

  - In：有标签，Out：有反馈

    目的：预测结果

    案例：猫狗分类，房价预测

  - **分类 k-近邻算法、贝叶斯分类、决策树与随机森林、逻辑回归、神经网络**

  - **回归 线性回归、岭回归**

- **无监督学习(unsupervised learning)**

  - 定义：输入数据是由输入特征值所组成。

  - In：无标签，Out：无反馈

    目的：发现潜在结构

    案例：“物以类聚，人以群分”

  - **聚类 k-means**，**降维**

- **半监督学习**

  - 已知：训练样本Data和待分类的类别

    未知：训练样本有无标签均可

    应用（案例）：训练数据量过多时，

    监督学习效果不能满足需求，因此用来增强效果。

- **强化学习**

  - In：决策流程及激励系统，Out：一系列行动

    目的：长期利益最大化，回报函数（只会提示你是否在朝着目标方向前进的延迟反映）

    案例：学下棋

    **算法：马尔科夫决策，动态规划**

## 模型评估

> 了解机器学习中模型评估的方法
>
> 知道过拟合, 欠拟合发生情况

模型评估是模型开发过程不可或缺的一部分。它有助于发现表达数据的最佳模型和所选模型将来工作的性能如何。**按照数据集的目标值不同，可以把模型评估分为分类模型评估和回归模型评估。**

### 分类模型评估

- 准确率
  - 预测正确的数占样本总数的比例。
- 精确率
  - 正确预测为正占**全部预测为正**的比例
- 召回率
  - 正确预测为正占**全部正样本**的比例
- F1-score
  - 主要用于评估模型的稳健性
- AUC指标
  - 主要用于评估样本不均衡的情况

### 回归模型评估

![image-20190218152834380](https://wwfyde.oss-cn-hangzhou.aliyuncs.com/images/20210427103918.png)

- ##### 均方根误差（Root Mean Squared Error，RMSE）

  - RMSE是一个衡量回归模型误差率的常用公式。 然而，它仅能比较误差是相同单位的模型。

    ![image-20190312193846308](https://wwfyde.oss-cn-hangzhou.aliyuncs.com/images/20210427103922.png)

- ##### 相对平方误差（Relative Squared Error，RSE）

  - 与RMSE不同，RSE可以比较误差是不同单位的模型。

    ![image-20190312194839069](https://wwfyde.oss-cn-hangzhou.aliyuncs.com/images/20210427103928.png)

- ##### 平均绝对误差（Mean Absolute Error，MAE)

  - MAE与原始数据单位相同， 它仅能比较误差是相同单位的模型。量级近似与RMSE，但是误差值相对小一些。

    ![image-20190312194923850](https://wwfyde.oss-cn-hangzhou.aliyuncs.com/images/20210427103933.png)

- ##### 相对绝对误差（Relative Absolute Error，RAE)

  - 与RSE不同，RAE可以比较误差是不同单位的模型。

    ![image-20190312195006252](https://wwfyde.oss-cn-hangzhou.aliyuncs.com/images/20210427103938.png)

- ##### 决定系数 (Coefficient of Determination)

  - 决定系数 (**R2**)回归模型汇总了回归模型的解释度，由平方和术语计算而得。

    ![image-20190312202620606](https://wwfyde.oss-cn-hangzhou.aliyuncs.com/images/20210427103942.jpeg)

  - R2描述了回归模型所解释的因变量方差在总方差中的比例。R2很大，即自变量和因变量之间存在线性关系，如果回归模型是“完美的”，SSE为零，则R2为1。R2小，则自变量和因变量之间存在线性关系的证据不令人信服。如果回归模型完全失败，SSE等于SST，没有方差可被回归解释，则R2为零。

### 拟合

模型评估用于评价训练好的的模型的表现效果，其表现效果大致可以分为两类：过拟合、欠拟合。

在训练过程中，你可能会遇到如下问题：

##### 训练数据训练的很好啊，误差也不大，为什么在测试集上面有问题呢？

当算法在某个数据集当中出现这种情况，可能就出现了拟合问题。

### 欠拟合

![image-20190312213119759](https://wwfyde.oss-cn-hangzhou.aliyuncs.com/images/20210427103949.jpeg)

因为机器学习到的天鹅特征太少了，导致区分标准太粗糙，不能准确识别出天鹅。

### 过拟合

![è¿‡æ‹Ÿåˆ](https://wwfyde.oss-cn-hangzhou.aliyuncs.com/images/20210427103954.png)

机器已经基本能区别天鹅和其他动物了。然后，很不巧已有的天鹅图片全是白天鹅的，于是机器经过学习后，会认为天鹅的羽毛都是白的，以后看到羽毛是黑的天鹅就会认为那不是天鹅。

**过拟合**（over-fitting）：所建的机器学习模型或者是深度学习模型在训练样本中表现得过于优越，导致在验证数据集以及测试数据集中表现不佳。

### 小结

- 分类模型评估【知道】
  - 精确率 -- 查的准
  - 召回率 -- 查的全
  - F1-score -- 评判模型的稳健性
- 回归模型评估【知道】
  - MSE -- 均方误差
  - RMSE -- 均方根误差
  - MAE -- 平方绝对误差
- 拟合【掌握】
  - 举例 -- 判断是否是人
  - 欠拟合
    - 学习到的东西太少
    - 学习到的特征少
  - 过拟合
    - 学习到的东西太多
    - 学习到的特征多，不好泛化



## 深度学习

 --由神经网络发展而来



## 机器学习基础环境安装与使用

```
jupyter notebook

matplotlib

numpy

pandas

tables

bokeh -散景

Seaborn 
```



## Matplotlib

#### 学习目标

- Matplotlib的架构
- 应用Matplotlib的基本功能实现图形显示
- 应用Matplotlib实现多图显示
- 应用Matplotlib实现不同画图种类

#### 参考文档

中文文档

官方文档

[解决中文乱码问题](https://blog.csdn.net/GreenHandCGL/article/details/79814572)

```
解决中文乱码问题
venv\Lib\site-packages\matplotlib\mpl-data\matplotlibrc
修改文件, 取消注释font.family和font.sans-serif
并且在font.sans-serif中添加上自己想要的字体
```



#### 说明简介

专门用于开发2D图表(包括3D图表), 使用起来极其简单, 以渐进交互式方式实现数据可视化

**作用**: 可视化是在整个数据挖掘的关键辅助工具, 可以清晰的理解数据, 从而调整我们的分析方法. 能将数据进行可视化, 更直观的呈现, 使数据更加客观, 更具说服力

#### 用法示例

实现一个最简单的画图功能: 基本思路是

```python
# 导入画图模块
import matplotlib.pyplot as plt

# 创建画布
plt.figure(figsize=(20,9), dpi=125)

# 绘制图像
x = [1, 2, 3]
y = [4, 5, 6]
plt.plot(x, y)

# 显示图像
plt.show()
```

![简单绘图](https://wwfyde.oss-cn-hangzhou.aliyuncs.com/images/20210427104015.png)

### matplotlib结构

![图像结构](https://wwfyde.oss-cn-hangzhou.aliyuncs.com/images/20210427104020.png)

#### 容器层

容器层主要由Canvas、Figure、Axes组成。

一个figure(图像)可以包含多个axes(坐标系/绘图区)，但是一个axes只能属于一个figure。

一个axes(坐标系/绘图区)可以包含多个axis(坐标轴)，包含两个即为2d坐标系，3个即为3d坐标系 

![](https://wwfyde.oss-cn-hangzhou.aliyuncs.com/images/20210427104026.png)

##### Canvas - 画板

Canvas是位于最底层的系统层，在绘图的过程中充当画板的角色，即放置画布(Figure)的工具。

##### Figure - 画布

Figure是Canvas上方的第一层，也是需要**用户来操作**的应用层的第一层，在绘图的过程中充当画布的角色。

Figure:指整个图形(可以通过plt.figure()设置画布的大小和分辨率等)

##### Axes - 坐标系

Axes是应用层的第二层，在绘图的过程中相当于画布上的绘图区的角色。

Axes(**坐标系**):数据的绘图区域

Axis(**坐标轴**)：坐标系中的一条轴，包含大小限制、刻度和刻度标签

#### 辅助显示层

辅助显示层为Axes(绘图区)内的除了根据数据绘制出的图像以外的内容，主要包括Axes外观(facecolor)、边框线(spines)、坐标轴(axis)、坐标轴名称(axis label)、坐标轴刻度(tick)、坐标轴刻度标签(tick label)、网格线(grid)、图例(legend)、标题(title)等内容。

该层的设置可使图像显示更加直观更加容易被用户理解，但又不会对图像产生实质的影响。

![辅助显示层](https://wwfyde.oss-cn-hangzhou.aliyuncs.com/images/20210427104031.png)

#### 图像层

图像层指Axes内通过plot、scatter、bar、histogram、pie等函数根据数据绘制出的图像

#### 总结

- Canvas（画板）位于最底层，用户一般接触不到
- Figure（画布）建立在Canvas之上
- Axes（绘图区）建立在Figure之上
- 坐标轴（axis）、图例（legend）等辅助显示层以及图像层都是建立在Axes之上

### 折线图(plot)与基础绘图功能

#### 学习目标

- 学习折线图的绘制和图形保存
- 给图形添加辅助功能(如：标注、x,y轴名称、标题等)
- 多次plot绘制图形
- 多个坐标系显示图形
- 知道折线图的应用场景



#### 绘图顺序

导入需要的包 >> 创建画布 >> 绘制图像 >>辅助显示 >> 显示图像

#### 折线图绘制与显示

matplotlib.pytplot包含了一系列类似于matlab的画图函数。 它的函数**作用于当前图形(figure)的当前坐标系(axes)**。

```python
# 导入画图模块
import matplotlib.pyplot as plt

# 1.创建画布(容器层)
plt.figure(figsize=(10, 10))

# 2.绘制折线图(图像层)
plt.plot([1, 2, 3, 4, 5, 6 ,7], [17,17,18,15,11,11,13])

# 3.显示图像
plt.show()

```

#### 设置画布属性与图片保存

```
plt.figure(figsize=(), dpi=)
    figsize:指定图的长宽
    dpi:图像的清晰度
    返回fig对象
plt.savefig(path)

```

```python
# 1.创建画布，并设置画布属性
plt.figure(figsize=(20, 8), dpi=80)
# 2.保存图片到指定路径
plt.savefig("test.png")
```

注意：plt.show()会释放figure资源，如果在显示图像之后保存图片将只能保存空图片。

#### 完善原始折线图

**案例：显示温度变化状况**

需求：画出某城市11点到12点1小时内每分钟的温度变化折线图，温度范围在15度~18度

效果：

![上海1](https://wwfyde.oss-cn-hangzhou.aliyuncs.com/images/20210427104036.png)

#### 准备数据并画出初始折线图 

```python
# 画出温度变化图
import matplotlib.pyplot as plt
import random

# 0.准备x, y坐标的数据
x = range(60)
y_shanghai = [random.uniform(15, 18) for i in x]

# 1.创建画布
plt.figure(figsize=(20, 8), dpi=80)

# 2.绘制折线图
plt.plot(x, y_shanghai)

# 3.显示图像
plt.show()
```

![上海2](https://wwfyde.oss-cn-hangzhou.aliyuncs.com/images/20210427104042.png)

#### 添加自定义x,y刻度

```python
# 使用方法
plt.xticks(ticks=None, labels=None, **kwargs)
plt.yticks(ticks=None, labels=None, **kwargs)
# ticks:要显示的刻度值
# labels:显示的标签
```

```python
# 增加以下两行代码
# 构造x轴刻度标签
x_ticks_label = ["11点{}分".format(i) for i in x]
# 构造y轴刻度
y_ticks = range(40)

# 修改x,y轴坐标的刻度显示
plt.xticks(x[::5], x_ticks_label[::5])
plt.yticks(y_ticks[::5])
```

```python
# 绘制温度图
import matplotlib.pyplot as plt
import random


plt.figure(figsize=(16,9), dpi=150)

x = range(60)

y = [random.uniform(15, 18) for i in x]

y_beijing = [random.uniform(9,12) for i in x] 

# 修改x, y轴坐标的刻度显示
x_ticks_label = [f"11: {i:02d}" for i in x]

y_ticks = range(40)

plt.xticks(x[::5], x_ticks_label[::5])
# plt.yticks(y_ticks[::5])

# 添加网格显示
plt.grid(True, linestyle='--', alpha=0.5)

# 添加描述信息
plt.xlabel("时间")
plt.ylabel("温度")
plt.title("温度变化显示图")

plt.plot(x, y, label="上海")

# 使用多次plot可以画多个折线
plt.plot(x, y_beijing, color='r', linestyle='--', label="北京")

# 显示图例
plt.legend(loc="best")


plt.savefig("../../wwfyde/Markdown/images/Python机器学习/温度折线图.png")
plt.show()
```

![温度折线图](https://wwfyde.oss-cn-hangzhou.aliyuncs.com/images/20210427104052.png)

#### 添加网格显示

为了更加清楚地观察图形对应的值

```python
plt.grid(True, linestyle='--', alpha=0.5)
```

#### 添加描述信息

添加x轴、y轴描述信息及标题

```python
plt.xlabel("时间")
plt.ylabel("温度")
plt.title("中午11点0分到12点之间的温度变化图示")
```

#### 多次plot

需求：再添加一个城市的温度变化

收集到北京当天温度变化情况，温度在1度到3度。怎么去添加另一个在同一坐标系当中的不同图形，**其实很简单只需要再次plot即可**，但是需要区分线条，如下显示

#### 设置图形风格

| color  |   linestyle    |
| :----: | :------------: |
| r 红色 |     - 实线     |
| g 绿色 |    - - 虚线    |
| b 蓝色 |   -. 点划线    |
| w 白色 |    : 点虚线    |
| c 青色 | ' ' 留空、空格 |
| m 洋红 |                |
| y 黄色 |                |
| k 黑色 |                |

**显示图例**

注意：如果只在plt.plot()中设置label还不能最终显示出图例，还需要通过plt.legend()将图例显示出来

```
plt.legend(loc="best")
```

![图例显示](https://wwfyde.oss-cn-hangzhou.aliyuncs.com/images/20210427104100.gif)

#### 小结

- 图像保存【知道】
  - plt.savefig("路径")
- 添加x,y轴刻度【知道】
  - plt.xticks()
  - plt.yticks()
  - **注意:在传递进去的第一个参数必须是数字,不能是字符串,如果是字符串吗,需要进行替换操作**
- 添加网格显示【知道】
  - plt.grid(linestyle="--", alpha=0.5)
- 添加描述信息【知道】
  - plt.xlabel()
  - plt.ylabel()
  - plt.title()
- 多次plot【了解】
  - 直接进行添加就OK
- 显示图例【知道】
  - plt.legend(loc="best")
  - **注意:一定要在plt.plot()里面设置一个label,如果不设置,没法显示**
- 多个坐标系显示【了解】
  - plt.subplots(nrows=, ncols=)
- 折线图的应用【知道】
  - 1.应用于观察数据的变化
  - 2.可是画出一些数学函数图像

### 常见图形绘制

#### 学习目标

- 掌握常见统计图及其意义
- 绘制散点图和柱状图
- 探究不同变量之间的关系

Matplotlib能够绘制**折线图、散点图、柱状图、直方图、饼图。**

我们需要知道不同的统计图的意义，以此来决定选择哪种统计图来呈现我们的数据。

#### 常见图形种类及意义

- **折线图**：以折线的上升或下降来表示统计数量的增减变化的统计图

  **特点：能够显示数据的变化趋势，反映事物的变化情况。(变化)**

  api：plt.plot(x, y)

  ![img](https://wwfyde.oss-cn-hangzhou.aliyuncs.com/images/20210427104107.png)

- **散点图：**用两组数据构成多个坐标点，考察坐标点的分布,判断两变量之间是否存在某种关联或总结坐标点的分布模式。

  **特点：判断变量之间是否存在数量关联趋势,展示离群点(分布规律)**

  api：plt.scatter(x, y)

  ![img](https://wwfyde.oss-cn-hangzhou.aliyuncs.com/images/20210427104112.png)

- **柱状图：**排列在工作表的列或行中的数据可以绘制到柱状图中。

  **特点：绘制连离散的数据,能够一眼看出各个数据的大小,比较数据之间的差别。(统计/对比)**

  api：plt.bar(x, width, align='center', **kwargs)

  ```
  Parameters:    
  x : sequence of scalars.
  
  width : scalar or array-like, optional
  柱状图的宽度
  
  align : {‘center’, ‘edge’}, optional, default: ‘center’
  Alignment of the bars to the x coordinates:
  ‘center’: Center the base on the x positions.
  ‘edge’: Align the left edges of the bars with the x positions.
  每个柱状图的位置对齐方式
  
  **kwargs :
  color:选择柱状图的颜色
  ```

  ![img](https://wwfyde.oss-cn-hangzhou.aliyuncs.com/images/20210427104115.png)

- **直方图：**由一系列高度不等的纵向条纹或线段表示数据分布的情况。 一般用横轴表示数据范围，纵轴表示分布情况。

  **特点：绘制连续性的数据展示一组或者多组数据的分布状况(统计)**

  api：matplotlib.pyplot.hist(x, bins=None)

  ```
  Parameters:    
  x : (n,) array or sequence of (n,) arrays
  
  bins : integer or sequence or ‘auto’, optional
  组距
  ```

  ![img](https://wwfyde.oss-cn-hangzhou.aliyuncs.com/images/20210427104119.png)

- **饼图：**用于表示不同分类的占比情况，通过弧度大小来对比各种分类。

  **特点：分类数据的占比情况(占比)**

  api：plt.pie(x, labels=,autopct=,colors)

  ```
  x:数量，自动算百分比
  labels:每部分名称
  autopct:占比显示指定%1.2f%%
  colors:每部分颜色
  ```

  ![](https://wwfyde.oss-cn-hangzhou.aliyuncs.com/images/20210427104125.png)

#### 散点图绘制

需求：探究房屋面积和房屋价格的关系

房屋面积数据：

```python
x = [225.98, 247.07, 253.14, 457.85, 241.58, 301.01,  20.67, 288.64,
       163.56, 120.06, 207.83, 342.75, 147.9 ,  53.06, 224.72,  29.51,
        21.61, 483.21, 245.25, 399.25, 343.35]
```

房屋价格数据：

```python
y = [196.63, 203.88, 210.75, 372.74, 202.41, 247.61,  24.9 , 239.34,
       140.32, 104.15, 176.84, 288.23, 128.79,  49.64, 191.74,  33.1 ,
        30.74, 400.02, 205.35, 330.64, 283.45]
```

![img](https://wwfyde.oss-cn-hangzhou.aliyuncs.com/images/20210427104130.png)

代码：

```python
# 0.准备数据
x = [225.98, 247.07, 253.14, 457.85, 241.58, 301.01,  20.67, 288.64,
       163.56, 120.06, 207.83, 342.75, 147.9 ,  53.06, 224.72,  29.51,
        21.61, 483.21, 245.25, 399.25, 343.35]
y = [196.63, 203.88, 210.75, 372.74, 202.41, 247.61,  24.9 , 239.34,
       140.32, 104.15, 176.84, 288.23, 128.79,  49.64, 191.74,  33.1 ,
        30.74, 400.02, 205.35, 330.64, 283.45]

# 1.创建画布
plt.figure(figsize=(20, 8), dpi=100)

# 2.绘制散点图
plt.scatter(x, y)

# 3.显示图像
plt.show()
```

#### 柱状图绘制

**需求-对比每部电影的票房收入**

电影数据如下图所示：

![电影票房数据](https://wwfyde.oss-cn-hangzhou.aliyuncs.com/images/20210427104134.png)

**1 准备数据**

```
['雷神3：诸神黄昏','正义联盟','东方快车谋杀案','寻梦环游记','全球风暴', '降魔传','追捕','七十七天','密战','狂兽','其它']
[73853,57767,22354,15969,14839,8725,8716,8318,7916,6764,52222]
```

**2 绘制**

- matplotlib.pyplot.bar(x, width, align='center', **kwargs)

绘制柱状图

代码：

```python
# 0.准备数据
# 电影名字
movie_name = ['雷神3：诸神黄昏','正义联盟','东方快车谋杀案','寻梦环游记','全球风暴','降魔传','追捕','七十七天','密战','狂兽','其它']
# 横坐标
x = range(len(movie_name))
# 票房数据
y = [73853,57767,22354,15969,14839,8725,8716,8318,7916,6764,52222]

# 1.创建画布
plt.figure(figsize=(20, 8), dpi=100)

# 2.绘制柱状图
plt.bar(x, y, width=0.5, color=['b','r','g','y','c','m','y','k','c','g','b'])

# 2.1b修改x轴的刻度显示
plt.xticks(x, movie_name)

# 2.2 添加网格显示
plt.grid(linestyle="--", alpha=0.5)

# 2.3 添加标题
plt.title("电影票房收入对比")

# 3.显示图像
plt.show()
```

**参考链接：**

 https://matplotlib.org/index.html

#### 小结

- 折线图【知道】
  - 能够显示数据的变化趋势，反映事物的变化情况。(变化)
  - plt.plot()
- 散点图【知道】
  - 判断变量之间是否存在数量关联趋势,展示离群点(分布规律)
  - plt.scatter()
- 柱状图【知道】
  - 绘制连离散的数据,能够一眼看出各个数据的大小,比较数据之间的差别。(统计/对比)
  - plt.bar(x, width, align="center")
- 直方图【知道】
  - 绘制连续性的数据展示一组或者多组数据的分布状况(统计)
  - plt.hist(x, bins)
- 饼图【知道】
  - 用于表示不同分类的占比情况，通过弧度大小来对比各种分类
  - plt.pie(x, labels, autopct, colors)

## Numpy



## Pandas



DataFrame 类似于Numpy中的二维数组

# Glossary

> 相关文档
>
> 

## List

- 神经网络(neural network):
- 机器学习(Machine Learning): 
- 模型(model)
    - [[Microsoft](https://learn.microsoft.com/zh-cn/windows/ai/windows-ml/what-is-a-machine-learning-model)]机器学习模型是一个文件，在经过训练后可以识别特定类型的模式。 你可以用一组数据训练模型，为它提供一种算法，模型利用该算法学习这些数据并进行推理。
    - 表示一个知识, 数据的结构
- 参数
- 算法
- 训练(Train)
- 推理(infer)
- 评估(Evaluate)
- 预测(Predict)
- 分类(classification)

# 机器学习必修数学

主要内容

**机器学习基础**: 机器学习的分类与一般思想

**微积分基础**: 泰勒公式, 导数与梯度

**概率与统计基础**: 概率公式, 常见分布, 常见统计量

**线性代数基础**: 矩阵乘法的集合意义

# 迈向机器学习

机器学习主要解决问题

以大量数据为基础, 预测结果; 对大量数据进行识别和分类.

比较关键的一点是, 预测或分类的具体方法并不是由程序员事先设定的, 而是由计算机从大量数据中自动提取特征, 从而解决问题.

预测问题

分类问题

感知器

加权求和

梯度下降法

神经网络