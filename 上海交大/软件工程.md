# 软件工程

> 编写原则:
>
> 一: 内容有助于提高读者开发软甲你的能力, 特别是提高读者直接参与软件开发实践的能力.

软件 = 程序 + 数据 + 文档



软件开发的本质: 软件开发是一种映射——把实际问题域中的概念和处理逻辑映射到运行平台上的**概念**和**处理逻辑**。  *——数据结构+算法*

## 重要观点

正确定义问题，是解决问题的基础。

# 常见问题

软件开发的本质

问题域定义

软件生存周期过程——软件开发需要做什么

软件开发方法学, 结构化方法, 面向对象方法.

软件测试技术

软件生存周期模型——软件开发活动的组织框架

项目生存周期过程





# 基本概念

**问题域**: 问题域指提问的范围、问题之间的内在的关系和逻辑可能性空间。问题域（Problem domain）”指提问的范围、问题之间的内在的关系和逻辑可能性空间。软件工程：在软件工程中，问题域是指被开发系统的应用领域，即在客观世界中由该系统处理的业务范围。

**问题空间**: 问题空间是问题解决者对一个[问题](https://zh.wikipedia.org/wiki/问题)所达到的全部认识状态，它是由问题解决者利用问题所包含的**信息**和已贮存的信息主动地构成的。

一个问题一般有下面三个方面来定义：

1. [初始状态](https://zh.wikipedia.org/w/index.php?title=初始状态&action=edit&redlink=1)——一开始时的不完全的信息或令人不满意的状况；
2. [目标状态](https://zh.wikipedia.org/w/index.php?title=目标状态&action=edit&redlink=1)——你希望获得的[信息](https://zh.wikipedia.org/wiki/信息)或[状态](https://zh.wikipedia.org/wiki/状态)；
3. [操作](https://zh.wikipedia.org/w/index.php?title=操作&action=edit&redlink=1)——为了从[初始状态](https://zh.wikipedia.org/w/index.php?title=初始状态&action=edit&redlink=1)迈向[目标状态](https://zh.wikipedia.org/w/index.php?title=目标状态&action=edit&redlink=1)，你可能采取的步骤。

这三个部分加在一起定义了问题空间（problem space）。问题空间代表的就是需求，解空间代表的就是设计。从上面的论述可以看出，需求和设计是个相对的概念，存在于软件开发的各个阶段。处于不同位置的需求和设计本质上是相同的。因此，用于需求分析的手段和概念也是通用的。

心理学定义：[问题解决](https://baike.baidu.com/item/问题解决)者对问题客观陈述的理解，通常由问题的给定条件、目标和允许的认知操作三种成分构成。

定义：关于问题理解与表述的基本成分。 *描述问题的成分构成, 包含问题所处的情景*





# 软件需求与软件需求规约

> 不论是自顶向下的软件开发，还是自底向上的软件开发，正确定义问题，是解决问题的基础。
> 软件需求以一种技术形式，描述了一个产品/系统应该具有的功能、性能和其他性质。可见，软件需求是产品/系统设计、实现以及验证的基本信息源之一，是任何软件工程项目的基础。
>
> 
>
> 需求的作用, 定义, 分类, 需求发现
>
> 
>
> 需求规约的概念和格式, 作用

## 学习目标

### 常见问题

需求的5个基本性质

需求规约的4个基本性质

## 需求-Requirements

### 需求定义

一个需求是对目标系统的功能和特征的描述，描述了待开发产品/系统功能上的能力、性能参数或其他性质。

用户解决问题或达成目的所需要的条件和能力;系统或组件必须满足条件和功能; 相关的文档说明

<q>The software requirements are description of features and functionalities of the target system. Requirements convey the expectations of users from the software product. The requirements can be obvious or hidden, known or unknown, expected or unexpected from client’s point of view.</q>

<q>A condition or capability needed by a user to solve a problem or achieve an objective.
A condition or capability that must be met or possessed by a system or system component to satisfy a contract, standard, specification, or other formally imposed document.
A documented representation of a condition or capability as in 1 or 2.</q>

对于单一一个需求，必须具有如下5个基本性质:

- 必要的（ Necessary），该需求是用户所要求的。

- 无歧义的（ Unambiguous），该需求只能用一种方式解释。
- 可测试的（Testable），该需求是可进行测试的。
- 可跟踪的（Traceable），该需求可从一个开发阶段跟踪到另一个阶段。
- 可测量的（ Measurable），该需求是可测量的。



对于需求的以上5个性质的验证，可采用不同的活动和技术。例如，验证需求是不是歧义的，一般可采用需求复审。验证需求是不是可测的，可在标识任何所需要的数据和设施的基础上，开发一个测试概念。验证需求是不是可测量的，可通过检验一个特征是否存在，但需要考虑设计、实现和测试阶段所发生的各种情况。可见，可测性通常从属于可测量性，是可测量性的一个方面。
要确定陈述的一个单一需求是否满足以上5个性质，是非常复杂、耗时的，但可以产生良好的、清晰的需求陈述。

### 需求分类

为了理解、认识软件需求，可以把需求分为两大类:一类是功能需求，一类是非功能需求，而非功能需求又可分为性能需求、外部接口需求、设计约束和质量属性需求，如表2-1所示。功能需求,是整个需求的主体。

- 功能需求(functionality): 规约了系统或者系统构建必须执行的功能;
- 性能需求(performance): 规约了一个系统或者系统构件在性能方面必须具有的一些特性;
- 外部接口需求: 用户接口 硬件接口 软件接口 通信接口 内存约束，运行 和 地点需求
- 设计约束: 限制了软件系统或者软件系统构件的设计方案范围;
    - 法规政策(regulatory policies):
    - 硬件限制
    - 与其他应用的接口
    - 并发操作
    - 审计功能
    - 控制功能
- 质量属性:规约了软件产品所具有的一个性质（包括功能和其他需求）必须达到其质量方面的一个所期望的水平。

>  功能 功能规约
>
> 时序, 优先级, 互斥, 状态, 顺序

### 需求发现技术

自悟:

交谈

观察

小组会

提炼

## 需求规约-Requirement Specification

> 规格说明书, 需求规约基本格式

### 需求规约定义

需求规约是一个软件项目/产品/系统所有需求陈述的正式文档，它表达了一个软件产品系统的概念模型。
需求规约一般需要满足以下4个基本性质。

- 重要性和稳定性程度（Ranked for Importance and Stability）:按需求的重要性和稳定
    性，对需求进行分级，例如:基本需求、可选需求和期望需求。
- 可修改的（Modifiable）:在不过多地影响其他需求的前提下，可以容易地修改一个
    单一需求。
- 完整的（Complete）:没有被遗漏的需求。
- 一致的（ Consistent）:不存在互斥的需求。

### 作用

需求规约的作用可概括为以下4点。

- 需求规约是软件开发组织和用户之间一份事实上的**技术合同书**，是产品功能及其环境的体现。
- 对于项目的其余大多数工作，需求规约是一个管理控制点。
- 对于产品/系统的设计，需求规约是一个正式的、受控的起始点。
- 需求规约是创建产品验收测试计划和用户指南的基础，即基于需求规约一般还会产生另外两个文档—初始测试计划和用户系统操作描述。
    - 初始测试计划:初始测试计划应包括对未来系统中的哪些功能和性能指标进行测试，以及达到何种要求。在以后阶段的软件开发中，对这个测试计划要不断地修正和完善，并成为相应阶段文档的一部分。
    - 用户系统操作描述:从用户使用系统的角度来描述系统，相当于一份初步的用户手
        册。其主要内容包括对系统功能和性能的简要描述，使用系统的主要步骤和方法，以
        及系统用户的责任等。



在即将结束软件需求的讲解之前，特别需要提醒的是，**需求规约**和**项目需求**是两个不同的概念。如上所述，需求规约是软件开发组织和用户之间一份事实上的技术合同书，即关注产品需求; 而项目需求是客户和开发者之间的有关技术合同-产品/系统需求的理解, 一份项目文档, 关注项目工作与项目管理. 

因此需求规约不是一份设计文档, 不是进度或规划文档. 



## 软件需求分析方法

> 结构化方法
>
> 软件需求分析方法大体分为如下四类：**结构化方法**、**面向对象方法**、**面向控制方法**和**面向数据方法**。
>
> 自顶向下, 自底向上, 渐进式增量开发

# 结构化方法

> 结构化方法作为一种思想工具, 可用于**定义需求**, 建立待建系统的**功能模型**, 可用于定义满足需求的结构, 给出一种特定的软件解决方案。

## 学习目标

1.总的要求
要求考生掌握结构化分析方法，并能运用该方法给出小型简单系统的功能模型；掌握结构化设计方法，能基于给定的小型简单系统功能模型，给出系统的总体设计，并能运用详细设计工具给出若干模块的详细设计。
2.知识点和考核要求
（1）识记
1）表达问题域信息的基本术语及其表示。
2）表达功能模型的工具DFD图。
3）数据结构符和判定表、判定树。
4）变换型数据流图和事务型数据流图。
5）模块以及模块内聚和耦合。
6）详细设计工具:框图、PAD图、NS图和伪码
（2）领会
1）结构化方法源于的基本思想。
2）结构化分析方法中每一术语所基于的原理以及它们在建模中的作用。
3）构建系统功能模型的步骤。
4）变换设计和事务设计。
5）“高内聚低耦合”原则以及经验性准则。
6）详细设计工具的优缺点以及相互转换。
7）结构化方法存在的问题。
（3）应用
1）针对不复杂的系统需求（问题）陈述，创建该系统的功能模型，包括系统的DFD图、数据字典和加工小说明。
2）在创建系统功能模型的基础上，给出该系统的总体设计，并针对有关模块运用PAD图或N-S图或伪码，给出这些模块的详细设计。

## 结构化需求分析

### 软件系统/产品的需求分析过程中面临的三大问题:

1. 问题空间理解
2. 人与人之间的通信;
3. 需求的变化性;

### 需求分析技术应有的基本特征



### 基本术语

**结构化方法**: 结构化分析方法, 结构化设计方法以及结构化程序设计方法

**结构化分析方法**: 一般意义上说, 分析是针对一个问题, 系统化地使用信息对该问题的一个估算, 目标是对"系统应该做什么"进行一个估算, 即**需求规格说明**

**数据流**(data flow): 数据流程, 流程的输入数据/输出数据, 强调的是数据

**加工**(process):对输入数据进行处理并输出数据  *一般都会有输入流和输出流*

**数据存储**(data store, file): 结构化的客体

**数据源**/**数据潭**(data source/sink, external entity, input/output): 输入的起点, 输出数据, 数据终点, 服务者/消费者

[数据流程图](https://www.lucidchart.com/blog/data-flow-diagram-tutorial)

![data flow diagram symbols and notations](https://wwfyde.oss-cn-hangzhou.aliyuncs.com/images/20210426193342.png)

![1 Symbols used in the DEMARCO Notation of Data Flow Diagrams](https://wwfyde.oss-cn-hangzhou.aliyuncs.com/images/20210426193453.png)

<img src="https://wwfyde.oss-cn-hangzhou.aliyuncs.com/images/20210426193348.png" alt="Data flow diagram - Yourdon/DeMarco notation" style="zoom: 25%;" />

## 建模过程

> 目的: 系统地使用信息来创建系统功能模型
>
> 形式: 自顶向下, 逐步求精, 功能分解

### 建立系统环境图, 确定系统语境

最顶层的大加工

### 自顶向下, 逐步求精, 建立系统地层次数据流图

在顶层数据流图的基础上, 按功能分解的设计思想, 进行"自顶向下, 逐步求精", 对加工进行分解, 功能细分,  *树形结构*

1).  通过系统语境, 由父图生成子图,

2). 将父图的输入流和输出流分派到相关的子加工

3). 在各加工之间建立合理的关联, 必要时引入数据存储, 使之形成一个有机的整体.

经过上述三个步骤, 就可以创建一个数据流程图(Data Flow Diagram)

### 定义数据字典

> 根据数据流图, 定义其中包含的所有数据流和数据存储的数据结构, 直到给出构成以上数据项的基本数据类型。

数据是对客体的一种表示, 而且已经证明, 所有可以均可用3种基本结构表示, 顺序结构, 选择结构和重复结构

*区别, 基本结构, 程序流程图, 数据流程图的区别*

定义数据结构的符号

| 符号 | 描述   |
| ---- | ------ |
| =    | 定义为 |
| +    | 顺序   |
| \|   | 选择   |
| {}   | 重复   |
| m..n | 子界   |

数据字典 一般按照: **数据流条目**, **数据存储条目**, **数据项条目**三种条目进行组织

### 描述加工

> 目的: 依据系统地数据流程图, 给出每一个加工的小说明, 需求分析的目的是定义问题
>
> 对加工的可能情形进行说明, 当结构复杂时

表达工具: 

结构化自然语言: 说明是什么结构, 比如 顺序结构, 选择结构, 循环结构

判定表: 条件类别, 条件组合, 操作, 操作执行

判定树: 大括号分类概括



### 应用中注意的问题

一个加工必须既有输入又有输出;

必须准确地定义数据流和数据存储;

必须准确地描述每一个叶加工, 说明输入数据流与输出数据流之间的逻辑关系

**模型平衡问题**: 数据名一致, 父图中加工的输入/输出流必须与分解这个加工子图的输入/输出一致. *开始和结尾一样, 而不必关心内部进行了哪些子加工*, 所有的数据流必须是在数据字典中定义

**信息复杂性控制**: 上层数据流可以打包

### 重要观点

结构化需求分析方法看待客观世界的基本观点是: 信息系统是由一些信息流构成的, 其功能表现为信息在不断地流动(演化, 派生, 变化), 并经过一系列的变换, 最终产生人们所需要的结果。

结构化方法基于"**抽象**"这一软件设计基本原理, 即通过给出数据流概念, 支持进行**数据**抽象, 通过数据存储概念支持对系统中的**数据结构**的抽象; 通过给出加工概念, 支持系统**功能**的抽象。这是三个噶年就描述系统地功能而言是完备的, 即客观世界的任何事物均可规约为其中之一.

为了使系统分析能够清晰地定义系统边界, 同样基于抽象这一原理, 给出了**数据源**和**数据潭**这两个概念, 支持系统语境的定义

自顶向下, 逐层分解。**抽象**和**分解**是结构化方法采用的两个基本手段. 

### 需求验证

需求阶段的主要任务是完整地定义问题, 确定系统地功能和能力。该阶段的主要任务一般包括需求发现, 需求分析和需求验证。最终形成系统地软就需求规格说明书。

*大量统计数字表面, 软件系统中15%的错误起源于错误的需求*

## 结构化设计

> 解决怎么做的问题
>
> 目的: 在需求分析的基础上, 定义满足需求所需要的结构; 针对给定的问题, 给出该问题的软件解决方案
>
> **总体设计**: 建立系统地模块结构, 系统实现所需要的软件模块——系统中可标识的软件成分, 以及这些模块之间的调用关系。 **确定软件的模块结构和接口描述**
>
> 详细设计

### 参考资料

- [1974-structured-design](https://ieeexplore.ieee.org/document/5388187/citations#citations)

### 总体设计

**模块**: 软件中具有特定标识的独立成分.

**模块调用**: 模块之间的使用关系.

任务目标: 把系统地功能需求分配到一个特定的软件体系结构中.

**模块结构图(module structure chart, MSD图)**: 描述软件宏观结构的图形化工具, 用来表示模块的主要功能(*此功能应该是软件体系层面的功能*), 图形的主要元素是模块(描述)和模块调用(调用关系)

将模块排列(arrange)成一个树

![img](https://wwfyde.oss-cn-hangzhou.aliyuncs.com/images/20210426193415.png)

**层次结构图(hierarchical structure chart)**: 描绘软件的层次结构

HIPO图: "层次+输入/过程/输出"的英文缩写, 为每一个模块编写一个IPO图用以描述该模块

IPO模型(input process output) 输入-过程-输出

**当一个系统地模块结构图过于复杂时, 可以采用层次结构图对其进行进一步的抽象**

### 总体设计步骤

结构化设计方法的基本原则: 自顶向下, 功能分解, 这两个原则定义了 变换设计和事务设计

变换型数据流程图

事务型数据流图: 某个逻辑单元的输入到输出可能有多个选项的处理序列

### 模块化及启发式规则

模块化主要有两个任务: 设计接口和接口实现

**模块化方法**: 把待开发的软件分解成若干简单的, 具有**高内聚低耦合**的模块, 这一过程称为模块化。

**耦合**: 不同模块之间的依赖程度. 产生耦合的原因, 模块引用, 传递数据, 一个模块对另一个模块施加控制

常见的耦合类型(高到低):

1). 内容耦合: 一个模块直接修改或操作另一个模块的数据, 或不通过正常入口就会影响另一个模块的数据, 这样被称为内容耦合. 应该极力避免这样的高程度耦合。

2). 公共耦合, 两个或以上的模块共同引用一个全局数据项.

3). 控制耦合: 传入控制信号, 接受模块根据信号做相应的动作

4). 标记耦合: 一个模块向另外两个模块传递一个公共参数;

5). **数据耦合**: 模块之间通过参数来传递数据. 系统中一般都存在这种耦合, 另一个模块为了完成有意义的功能往往需要将某些模块的输出数据作为另一些模块的输入数据

**内聚**: 模块内部各部分之间的相互关联程度。

偶然内聚, 逻辑内聚, 时间内聚, 过程内聚, 通信内聚, 顺序内聚, **功能内聚**.

功能内聚是最理想的内聚, 模块的所有成分对于完成单一的功能都是基本的

软件设计时, 应力争做到高内聚低耦合, 更加抽象接口尽可能简单

**启发式规则**: 

改进软件结构, 提高模块独立性; 

力求模块规模适中;

力求深度(层数), 宽度(同一层次的模块数量), 扇出(下级模块数量)和扇入(多少个上级调用该模块)适中; 

尽力降低模块的接口复杂度; 

尽可能使模块的作用域(被动影响)在其控制域(主动影响)之内;

力求模块功能可以预测(预知输出结果)。

### **详细设计**

> 确定了软件的模块结构和接口描述后, 可以作为详细设计的一个重要输入

#### **结构化程序设计**

 程序设计方法学的第一种含义是, 以程序设计方法和技术为研究对象的学科. 它主要涉及用于指导程序设计工作的原理和原则; 第二种含义是, 针对某一领域或某一领域的一类特定问题, 所用的一整套特定程序设计方法所构成的体系。

结构化程序设计方法是一种基于结构的编程方法，即采用顺序结构、选择结构以及重复结构进行编程，其中每一结构只允许一个入口和一个出口。可见，结构化程序设计的本质是使程序的控制流程线性化，实现程序的动态执行顺序符合静态书写的结构，从而增强程序的可读性，不仅容易理解、调试、测试和排错，而且还可为程序的形式化证明带来方便。

编程工作是个演化过程，可按抽象级别依次降低、逐步精化，最终得出所需的程序。采用自顶向下、逐步求精，使所编写的程序只含顺序、判定、重复3种结构，这样可使程序结构良好、易读、易理解、易维护，并易于保障及验证程序的正确性。因此可以说，采用结构化程序设计方法进行编程，旨在提高编程（过程）质量和程序质量。
结构化程序设计的概念最早由E.W. Dijkstra在20世纪60年代中期提出，并在1968年著名的NATO软件工程会议上首次引起人们的广泛关注。1966年，C.Bohm和G. Jacopini在数学上证明了只用3种基本控制结构就能实现任何单入口单出口的程序，这3种基本控制结构是“顺序”、“选择”和“循环”。Bohm和 Jacopini的证明给结构化程序设计技术奠定了理论基础。

“顺序”、“选择”和“循环”3种结构可用流程图表示。实际上，用顺序结构和循环结构（又称DO— WHILE结构）完全可以实现选择结构（又称if-thenELSE结构），因此，理论上最基本的控制结构只有两种。

![三种基本控制结构](https://wwfyde.oss-cn-hangzhou.aliyuncs.com/images/20210426193421.png)

![其他常用控制结构](https://wwfyde.oss-cn-hangzhou.aliyuncs.com/images/20210426193429.png)

#### **详细设计工具**

> 设计工具通常就是 图形, 表格和语言三种

1)程序流程图

程序流程图中的箭头代表控制流而不是数据流, 这一点同数据流程图中的箭头是不同的



2)盒图(N-S图)

3)PAD图

4)类程序设计语言, 伪代码

**设计规约**: 概要设计规约, 详细设计规约



**概要设计规约**旨明高层软件体系结, 其主要内容如下:
1）系统环境，包括硬件、软件接口、人机界面、外部定义的数据库及其与设计有关的限定条件等。

2）软件模块的结构，包括模块之间的接口及设计的数据流和主要数据结构等

3）模块描述，包括模块接口定义、模块处理逻辑及必要的注释等。

4）文件结构和全局数据文件的逻辑结构，包括记录描述、访问方式以及交叉引用信息等。

5）测试需求等。

<u>概要设计规约是面向软件开发者的文档，主要作为项目管理人员、系统分析人员与设计人员之间交流的媒体。</u>

**详细设计规约**是对软件各成分内部属性的描述。它是概要设计的细化，即在概要设计规约的基础上，增加以下内容:

①各处理过程的算法。

②算法所涉及的全部数据结构的描述，特别是，对主要数据结构往往包括与算法实现有关的描述。

详细设计规约主要作为软件设计人员与程序员之间交流的媒体。



## 习题

1, 解释以下术语:







# 面向对象方法-UML

> 统一建模语言(Unified Modeling Language, UML)作为一种图形化建模语言, 紧紧围绕"系统都是由客体组成的, 他们之间相互作用构成了大千世界各式各样的系统"这一观点, 给出表达客体关系的术语以及表达模型的工具. 

软件系统中, 构造模块的4中基本观点: 

通过"过程"或"函数"来构造模块, 每个模块实现一项功能——结构化方法; 

围绕一个**数据结构**构造模块, 每个模块实现该数据结构上的操作——面向数据结构开发方法;

围绕一类事件来构造一个模块, 使每个模块能够识别该类事件并对该类事件作出响应——事件驱动开发方法;

围绕问题域中的一个客体来构造一个模块, 使每个模块实现该客体对系统对系统承担的责任——面向对象方法.



面向对象方法认为, "世界是由客体组成的, 客体有自己的属性和活动规律; 客体之间的相互依赖和相互作用构成了大千世界的各式各样的系统". 

构造软件系统时, 运用人类认识客观世界、解决实际问题的思维方式和方法. 

<u>简而言之, 面向对象方法是一种根据客体之间的关系来构造系统模型的系统化方法.</u> 



方法(method)驱动的基本思想: 给出模型化概念的基础上, 明确规定进行的步骤, 并在每一步中给出实现策略.

模型(model)驱动的基本思想: 以给定的一组模型化概念为基础, 以模型构造为驱动, 捕获系统知识, 建立一组规范的系统目标模型, 其中不明确规定实现这些目标的步骤, 但给出一些必要的指导.

UML方法学建立了不同的抽象层次. 

按面向对象的观点， “事物之间的相互依赖和相互作用，构成了现存的各式各样的系统＂， UML把客观世界的一切事物（包括客体和可标识的行为单元），分为8大范畴。
从语言学的角度，为了规约这八大范畴的事物，UML引入了8个术语，即**类与对象**、**接口**、**协作**、**用况**、**主动类**、**构件**、**制品**和**节点**，并给出了它们的含义和表示。UMI把它们统称为类目（Classifer），作为元信息，以便对客观世界的一切事物进行模型化。

为了表达各类事物之间的关系, UML给出了4个术语, 即以**关联**、**泛化**、**实现**、**依赖**作为元信息, 对一切事物之间的关系进行模型化.

## UML术语表

### 类与对象(Class and Object)

**类**是一组具有相同属性、操作、关系和语义的对象的描述。

对象是类的一个实例。通常把类表示为具有3个栏目的矩形，每个栏目分别代表**类名**、**属性**和**操作**。
<u>类可以是抽象类，即没有实例的类。</u>
由于类主要用于抽象客观世界中的事物，因此一般要有一组属性和操作。

#### 类的属性（Attribute）

类的属性是类的一个命名特性，该特性是由该类的所有对象所共享、用于表达对象状态的数据。
一个类可以有多个属性，也可以没有属性。
类的一个对象对其所属类的每一个属性应有特定的值。
在一个类中，表达属性的默认语法为: `[可见性]属性名[:类型] [=初始值]`

```text
可见性: 指明该属性是否可以被其他类所使用

+公有的: 可供其他类使用;
#受保护的: 只有其子类可使用;
-私有的: 只有本类的操作可使用;
~包内的: 只有同一包中声明的类可使用,
```

属性分为类属性和实例属性. *原文为类范围属性和对象范围属性.*

引入可见性的目的是为了支持信息隐蔽这一软件设计原则. 

#### 类的操作(Operation)

操作是对一个类中所有对象要做的事情的抽象

操作可以被其他对象所调用, 操作是对外提供的一种服务

类也分为类范围操作和实例范围操作



#### 类在建模中的主要用途

模型化问题域中的概念(词汇); *概念化, 问题域中的基础材料, 专业术语, 描述方法*

建立系统地职责分布模型; *对问题域中的问题进行进一步抽象, 使其能实现特定功能*

模型化建模中使用的基本类型. *对基本类型赋予进一步的意义, 比如枚举类型的成员, 整型的范围等等*

```
结构良好的类的特点:

明确抽象了问题域或解域中某个实体或概念.
包含了一个小的、明确定义的职责集, 并能很好的实现;
清晰地分离了抽象(abstraction)和实现(implement).
```



### 接口(Interface)

接口是操作的一个集合, 其中每个操作描述类、构件或子系统地一个服务。

在系统/产品建模中, 接口的主要作用: 对系统/产品中的"接缝"予以模型化. 

```
使用接口时应注意的问题:

接口只可以被其他类目使用, 而其本身不能访问其他类目;
接口描述类的外部可见操作, 通常是该类的一个特定有限行为;
接口不描述其中操作的实现, 也没有属性和状态; 类似于抽象类
接口之间没有关联挂、泛化、实现和依赖, 但可以参与泛化、实现和依赖
```



### 协作(Collaboration)

### 用例(Use Case)

### 主动类(Active Class)

### 构件(Component)

构件是系统设计中的一种模块化部件, 通过外部接口隐藏了它的内部实现.

构件是可以嵌套的, 即一个构件可以包好一些更小的构件.

### 制品(Artifact)

### 节点(Node)

节点是在运行时存在的物理元素, 通常表示一种具有记忆能力和处理能力的计算机资源. 一个构件可以驻留在一个人节点中, 也可以从一个节点转移到另一个节点.

### **表达关系术语**

表达各类事物之间的相互依赖和作用, 即表达各类事物之间的关系

### 关联(Association)

类目之间的一种结构关系, 是对一组具有相同结构、相同链(links)的描述.

链是对象之间具有特定语义关系的抽象, 实现智慧的链通常称为对象之间的连接(connection). *如人和公司是一组关联, 关联的语义是工作(动词)*

关联用一条连接两个累不的线段表示, 并可对其命名, 如果其结构具有方向性, 可用实心三角形来指示关联的方向.

从数学的角度来说, 关联是具有特定语义的对偶集合, 其中每一个对偶是一个链.

 与类相比, 类是对一组具有相同属性、操作、关系和语义的对象的描述; 而关联则是对一组具有相同结构和语义的链的描述

关联的基本元素: 角色, 导航和关联名. 

一个类目可以在不同的关联中扮演不同的角色

### 泛化(Generalization)

一般性类目(超类或父类)和它的较为特殊性类目(称为子类)之间的一种关系.

```
泛化的特点:
子类可继承父类的属性和操作, 并可具有更多的属性和操作;
子类可以替换父类的声明;
若子类一个操作的实现覆盖了父类同一个操作的实现, 这种情况称之为多态性, 但两个操作必须具有相同的名字和参数;
可以在其他类目之间创造泛化, 例如在节点之间、类和接口之间等. 
```

一个类可以有任意个父类. 没有父类且最少有一个子类的类被称为根类或基类; 没有子类的类称为叶子类. 

如果一个类有多个父类, 则说明该类使用了多继承. 多个父类时操作可能存在重叠, 一般应避免使用多继承.

### 细化(Realization)

### 依赖

依赖是一种使用关系, 用于描述一个类目使用另一类目的信息和服务. 当被依赖的类发生变化时这种关系下会影响当前类的使用. 

### 包

> 表达组合信息的术语

包可以作为"模块化"和"构件化"的一种机制. 

包时模型元素的一个分组. 

## UML的模型表达格式

UML的图形化工具分为两类:

一类是结构图, 用于表达系统或系统成分的静态结构模型, 给出系统或系统成分的一些说明性信息, 描述系统地功能和服务;

一类是行为图, 用于表达系统或系统成分的动态结构模型, 给出系统或系统成分的一些行为信息. 

行为图从多个视角中的一种(抽象层)进行抽象. 一类是(行为)功能的视角, 一类是(行为)交互的视角, 一类是(行为)生命周期的视角. 

### 类图(Class Diagram)

一般需要先确定的结构抽象层, 该抽象层决定了系统模型的形态.

### 用例图(Use Case Diagram)——系统功能

模型元素: 主题(subject), 用例(use case), 参与者(Actor), 关联, 泛化, 依赖.

### 状态迁移图(State Diagram)——功能生命周期

> 相关术语: 状态、事件和状态转移

图表功能: 强调从一个状态到零一个状态的控制流. 转移: 一般对应的是功能/函数/动作/活动; 状态: 参数的值

```
状态:

```



```
事件: 引发状态转移的激励(触发条件)

信号事件: 对象受到消息, 一般为异步事件, 信号通常由状态机处理.
调用事件: 对象接受到操作请求
时间事件: 
变化事件: 状态的一个变化或某一调节得到满足
```

```
状态转移: 对状态间关系的描述

```



### 时序图(Timing Diagram)——时间生命周期

### 序列图(Sequence Diagram)——逻辑生命周期

### 交互图——行为交互

### 活动图(Activity)



## 习题



### 

### 

# 面向对象方法-RUP

# 软件测试

> 错误是不可避免的

## 软件测试目标

软件测试第一目标是预防错误, 第二目标是发此案错误

软件测试定义: 按照特定规程发现软件错误的过程. 

错误(Error): 与所期望的设计之间的偏差, 该偏差可能产生不期望的系统行为或失效(Failure).

失效(Failure): 与规约的系统执行之间的偏差. 失效是系统故障或错误的后果.

故障(Fault):  导致错误或失效的不正常条件. 故障可以是偶然性的或是系统性的. 

```
软件测试与软件调试的区别:

1.测试从一个侧面证明程序员的"失败". 调试是为了证明程序员的正确.
2.测试从已知条件开始, 使用预先定义的程序且有预知的结果, 不可预见的仅是程序是否通过测试. 调试一般是不可知的内部条件开始, 除统计性调试外, 结果是不可预见的.
3.测试时有计划的, 并要进行测试设计. 调试是不受时间约束的.
4.测试时一个发现错误、改正错误、重新测试的过程. 调试是一个推理过程.
5.测试时有规程的. 调试的执行往往需要程序员进行必要的推理.
6.测试经常是由独立的测试组在不了解软件设计的条件下完成的. 调试必须由了解详细设计的程序员完成.
7.大多数测试的执行和设计可由工具支持. 调试时, 程序员能利用的工具主要是调试器.
```

## 软件测试技术

软件测试技术大体可分为两大类: 一类是**白盒**测试技术，又称为结构测试技术，典型的是路径测试技术；另一类是**黑盒**测试技术，又称为功能测试技术，包括事务处理流程技术、状态测试技术、定义域测试技术等。白盒测试技术依据的是程序的逻辑结构，而黑盒测试技术依据的是软件行为的描述。

### 路径测试技术

由于路径测试技术依据的是程序的逻辑结构，因此该技术的基本要点是:采用控制流程图来表达被测程序模型，揭示程序中的控制结构。通过合理地选择一组穿过程序的路径，以达到某种测试度量。
1.控制流程图
控制流程图是一种表示程序控制结构的图形化工具，其基本元素是过程块（简称过程）、节点、判定，如图6-2所示。



# 软件生存周期过程与管理

# 集成化能力成熟度模型(CMMI)