# 数据结构

[参见上海交大《数据结构》](上海交大/数据结构.md)

> 书籍提示: 《数据结构:上海交大》一书中是以C语言为基础来描述算法的. 
>
> 页面作者提示:
>
> 加粗内容为重点概念和术语, 高亮部分(`<mark>/<mark>` `====`包围的内容)是重点内容, <u>下划线内或引用内容是作者自己的提示</u>或从网页摘录的补充说明



> 数据结构: 数据的逻辑结构和存储结构
>
> 算法: 对数据运算的描述(运算的过程, 阶梯的方法)
>
> 使用计算机解决一个具体问题时, 一般需要经过下列几个步骤: 首先要从具体问题中抽象出一个适当的数学模型, 然后设计或选择一个求解此数学模型的算法, 最后编出程序进行调试、测试, 直至得到最终的解答。
>
> 程序设计的实质是针对实际问题选择一种好的数据结构和设计一个好的算法, 而好的算法在很大程度上取决于描述实际问题的数据结构



>个人总结wwfyde, 20230628:
>
>数据结构的本质目标是结构化存储数据, 根据不同的需求, 选择高效的数据结构, 数据的操作一般有查找(search), 排序(sort), 插入(insert), 删除(delete)等需求, 查找是最常见的需求

# 快速上手

## 常见数据结构

>  [youtube 10 Key Data Structures We Use Every Day](https://www.youtube.com/watch?v=ouipSd_5ivQ)
>
>  [10 Key Data Structures We Use Every Day](https://blog.bytebytego.com/p/ep58-10-key-data-structures-we-use?utm_source=%2Fsearch%2Flinux%2520file%2520systems&utm_medium=reader2)
>
>  [lark archived](https://wwfydeio.sg.larksuite.com/wiki/DKtgwejWki9dN8kKCNulT3D8gBc)



| type        | use case                                          |      |
| ----------- | ------------------------------------------------- | ---- |
| list        | twitter feeds                                     |      |
| array       | Math operations large data set                    |      |
| stack       | undo/redo for word editer<br />function execution |      |
| queue       | tasks queue, message queue                        |      |
| heap        | task scheduling                                   |      |
| tree        | HTML document<br />AI decision                    |      |
| suffix tree | search string in Document                         |      |
| graph       | path finding                                      |      |
| R-tree      | nearest neighbor                                  |      |
| Hash Table  | Caching systems                                   |      |

> 

### 列表-List

### 数组-Array

### 栈-Stack

### 队列-Queue

### 堆-Heap

一种优先级队列

### 树-Tree

### 后缀树-(Suffix Tree)

### 图-Graph

### R树-(R-tree)

### 哈希表-(Hash Table)





# 基本概念

> 专业术语, 材料

## Cheatsheet

|    中文    |      英文      |      |      |
| :--------: | :------------: | ---- | ---- |
|   线性表   |  linear list   |      |      |
|            |                |      |      |
| 优先级队列 | priority queue |      |      |



## Lists

- 队列
- 栈
- 堆
    - 二叉堆
    - 堆栈

## 数据结构

**数据**(Data): 描述客观事物的数, 字符以及能输入计算机中并被计算机处理的符号的集合. 

**数据元素**(Data Element): 数据的基本单位. 

**数据对象**(Data Object): 具有相同性质的数据元素的集合. 

**数据结构**(Data Structure): 带有结构的数据元素的集合. <u>数据元素之间的相互关系, 数据的组织形式</u>

[wiki:数据结构](https://zh.wikipedia.org/wiki/数据结构): 计算机中存储、组织数据的方式

## 时间复杂度

> [参见](算法.md/#时间复杂度)

wiki:在计算机科学中，算法的**时间复杂度**（Time complexity）是一个函数，它定性描述该算法的运行时间。这是一个代表算法输入值的[字符串](https://zh.m.wikipedia.org/wiki/字符串)的长度的函数。时间复杂度常用 **大O符号** 表述，不包括这个函数的低阶项和首项系数。使用这种方式时，时间复杂度可被称为是渐近的，亦即考察输入量大小趋近无穷时的情况。

n表示规模

渐进时间复杂度

例如，如果一个算法对于任何大小为 n（必须比 n^0^ 大）的输入，它至多需要$ 5*n^3 + 3*n $的时间运行完毕，那么它的渐近时间复杂度是 O(*n*3)。

常见函数的时间复杂度

为了计算时间复杂度，我们通常会估计算法的操作单元数量，每个单元执行的时间都是相同的。因此，总运行时间和算法的操作单元数量最多相差一个常量系数。

相同大小的不同输入值仍可能造成算法的执行时间不同，因此我们通常使用算法的[最坏情况复杂度](https://zh.m.wikipedia.org/w/index.php?title=最壞情況複雜度&action=edit&redlink=1)（英语：[Worst-case complexity](https://en.wikipedia.org/wiki/Worst-case_complexity)），记为$T(n)$  ，定义为任何大小的输入$n$所需的最大执行时间。另一种较少使用的方法是[平均情况复杂度](https://zh.m.wikipedia.org/w/index.php?title=平均情況複雜度&action=edit&redlink=1)（英语：[average-case complexity](https://en.wikipedia.org/wiki/average-case_complexity)），通常有特别指定才会使用。时间复杂度可以用函数$T(n)$的自然特性加以分类，举例来说，有著 $T(n)=O(n)$ 的算法被称作“线性时间算法”；而 $T(n)=O(m^n)$和$M^n=O(T(n))$，其中 $M≥n>1$ 的算法被称作“指数时间算法”。

$T(n) = O(f(n))$

# 学习目标

## 概论

-   了解数据结构在计算机软件和计算机应用中的作用
    -   非数值计算
-   熟悉各名词和术语的含义; 掌握各种基本概念, 特别是数据结构的三个方面内容机器之间的相互关系; 数据结构的两大类型和四种基本的存储方法
-   了解算法的五个要素(准则)以及算法与程序的区别
-   熟悉使用类C语言函数对算法的描述; 掌握对算法的分析和时间复杂度的估算

# 概论

> 关键词:  基本数据类型, 结构类型
>
> 学习目标: 
>
> 了解数据结构在计算机软件和计算机应用中的作用; 
>
> 熟悉各名词和术语的含义: 掌握各种基本概念, 特别是数据结构的三方面内容及其之间的相互关系; 熟悉数据结构的两大类型和四种基本的存储方法. 
>
> 了解算法的五个要素(准则)以及算法与程序的区别. 
>
> 熟悉使用类C语言函数对算法的描述;掌握对算法的分析和时间复杂度的估算. 



## 引言

数据结构作为一门独立课程的发展背景: 分析待处理对象的特性以及待处理对象之间存在的关系.



在计算机发展的初期, 人们使用计算机的主要目的是处理数值计算问题.使用计算机解决一个具体问题时, 一般需要经过下列几个步骤: <mark>首先要从具体问题中抽象出一个适当的数学模型, 然后设计或选择一个求解此数学模型的算法, 最后编出程序进行调试, 测试, 直到得到最终的解答.</mark> 由于当时所涉及的运算对象是简单的整型, 实型或布尔等类型的数据, 所以程序设计者的主要精力集中于程序设计的技巧上, 而无需重视数据结构.随着计算机应用领域的扩大和软件硬件的发展, 非数值计算问题显得越来越重要. 据统计, 处理非数值计算性问题占用了90%以上的计算机运行时间, 这类问题涉及的数据结构更为复杂, 数据元素之间的相互关系一般无法用数学方程式加以描述. 显然, 解决这类问题的关键不再是数学分析和计算方法, 而是要设计出合适的数据结构, 才能有效地解决问题.

著名的瑞士计算机科学家沃思(N.Wirth)教授曾提出: **算法+数据结构=程序**. <mark>这里的数据结构指的是数据的逻辑结构和存储结构, 算法则是指对数据运算的描述.</mark> 由此可见, 程序设计的市直 是针对实际问题选择一种好的数据结构和设计一个好的算法, 而好的算法在很大程度上取决于描述实际问题的数据结构.要设计出一个好的程序, 就必须有好的算法, 而好的算法必须建立在研究数据的特性及数据之间存在的关系的基础之上. 这正是数据结构这门课程所要研究的内容.

```Plain text
到底什么是数据结构?

数据结构是对实体对象的描述, 实体对象的特性决定了它可以具有哪些操作
图书馆图书目录(表)
地图着色问题
家族的血统关系问题, 博弈树问题(人机下棋), 计算机的文件系统等都是一种树形结构, 而城市之间的交通往来, 工程管理中的活动安排以及多叉路口交通灯管理等问题是图形结构的. 它们都是一种非线性的数据结构
```

由此可见, 描述这类非数值计算问题的数学模型不再是数学方程, 而是诸如表, 树和图之类的数据结构. 简单来说, 数据结构是研究非数值计算的程序设计问题中计算机的操作对象以及它们之间的关系和操作的一门课程. 

**数据结构(data structure)**: <u>具体的说,数据结构指的是数据元素之间的逻辑结构, 存储结构及其数据的抽象运算, 即按某种逻辑关系组织起来的一组数据, 再按一定的存储表示方式把他们存储在计算机的存储器中, 并在这些数据上定义一个运算的集合, 这就叫做一个数据结构.</u>

<mark>数据结构的定义</mark>

**数据结构**(wiki): 数据结构（英语：data structure）是计算机中存储、组织数据的方式。

## 基本概念和常用术语

本节将对一些与数据结构有关的基本概念和常用术语给予描述和定义, 以便于后续章节的学习. 

<mark>对象三要素: 类型, 值, 名称.</mark>

**数据(data)**是描述客观事物的数, 字符以及能输入计算机中并被计算机处理的符号的集合. 例如, 一个代数方程的求解程序中所使用的数据是整数和实数, 而一个文本编辑程序使用的数据是字符串. 随着计算机的发展一级计算机应用领域的扩大, 数据的含义也随之拓展了. 例如, 当今计算机可以处理的图形, 图像, 声音等也都属于数据的范畴

<mark>数据是对有意义信息(客观事物)的描述和表示</mark>

**数据元素(data element)** 是数据的基本单位. 如前例中目录卡面中的一张卡片(表格中的一行), 树种的一个节点, 图中的一个顶点等都是数据原书, 有时一个数据元素可由若干个**数据项**(也称为字段, 域, 属性)组成, 数据项是具有独立含义的最小标识单位, 如图书卡面信息中的登录号, 书名, 作者等. 

**数据对象(data object)**是具有相同性质的数据元素的集合, 是数据的一个子集. 例如, 大写字母数据对象就是集合{'A', 'B', ..., 'Z'}.

### 数据结构包含的内容

**数据结构是带有结构的数据元素的集合**. 结构指的是数据元素之间的相互关系, 即数据的组织形式, 结构中的数据元素称为节点. 虽然至今没有一个关于数据结构的标准定义, 但它一般包括以下三个方面的内容:

<mark>(1)数据元素之间的逻辑(或抽象)关系, 也称为数据的逻辑结构</mark>

数据的逻辑结构是从逻辑关系上描述数据的, 它与数据元素的存储结构无关, 是独立于计算机的. 因此, 数据的逻辑结构可以看作是从具体问题抽象出来的数学模型.

数据的逻辑结构又可分为线性结构和非线性结构两大类.

线性结构的特征是: 数据元素(节点)之间存在着一对一的关系, 且结构中仅有一个开始节点和一个终端节点, 其余节点都是仅有一个直接前趋和一个直接后继.

非线性结构的特征是: 数据元素之间存在着一对多或多对多的关系, 即一个节点可能有多个直接前趋和多个直接后继. 该结构包括树形结构, 图形结构和网状结构等.

<mark>(2)数据元素及其关系在计算机内的存储方式, 称为数据的存储结构(物理结构).</mark>

例如, 如果向量中各元素按其逻辑关系顺序存储, 就称为顺序存储结构. 如果向量中各元素是通过**指针连接**存储在内存中, 就称为链式存储结构.

数据的存储结构是数据在计算机中的存储表示(映像), 亦称为数据的物理结构.它包括数据元素和关系的表示, 是依赖于计算机语言的.

数据的存储结构可以用一下四种基本存储方法实现:

① **顺序存储方法**. 顺序存储方法是把逻辑上相邻的节点存储在物理位置上也相邻的连续存储单元里, 由此得到的存储结构称为顺序存储结构. 它通常是借助于程序设计语言的数组来描述的. 该方法主要应用于线性存储结构, 但非线性的数据结构也可通过某种线性化的方法来实现顺序存储.

② **链接存储方法**. 链接存储方法是用一组不一定连续的存储单元存储逻辑上相邻的元素.元素间的逻辑关系是由附加的指针域表示的, 由此得到的存储结构称为链式存储结构. 它通常是借助于程序设计语言中的指针来描述的.

③ **索引存储方法**. 索引存储方法通常是在存储元素信息的同时, 还建立附加的索引表.表中的索引项一般形式是: (关键字, 地址). 关键字是能唯一标识一个元素的一个数据项(字段)或多个数据项的组合.

④ **散列存储方法**. 散列存储方法的基本思想是根据元素的关键字直接计算出该元素的存储地址.

无论怎样定义数据结构, 都应该将数据的逻辑结构, 存储结构及运算这三方面看成一个整体. 因此, 存储结构是数据结构不可缺少的一个方面.

同一种逻辑结构, 采用不同的存户方法可以得到不同的存储结构. 选择何种存储结构来表示相应的逻辑结构, 要视具体应用系统要求而定, 而主要考虑还是运算方便及算法的时间和空间上的要求

<mark>(3)数据的运算, 即对数据元素施加的操作(行为).</mark>

数据的运算是定义在数据的逻辑结构上的, 每种逻辑结构都有一个运算的集合, 最常用的运算有: 检索-retrieve, 插入-insert, 删除-delete, 更新-update, 排序-sort等. 数据运算是数据结构不可分割的一个方面, 在给定了数据的逻辑结构和数据的存储结构之后, 按定义的运算集合及其运算性质的不同, 可能导致完全不同的数据结构

**数据类型(data type)**: 是和数据结构非常相关的一个概念. 所谓的数据类型, 是一个值的集合, 和定义在这个值集上的一组操作的总称.数据类型规定了在程序执行期间变量或表达式可能的取值范围以及在这些值上锁允许的操作运算. 通常, 数据类型可以看作是程序设计语言中已实现的数据结构

**抽象数据类型(Abstract Data Type, ADT)**: 抽象数据的组织和与之相关的操作. 一个ADT可以看作是定义了相关操作运算的一个数学模型.

抽象数据类型可以看作是描述问题的模型, 它独立于具体实现. 它的特点是将数据定义和数据操作封装在一起, 使得用户程序只能通过ADT中定义的某种操作类访问其中的数据, 从而实现信息的隐藏性.   <u>一个ADT相当于是Python/C++等程序设计语言中声明的一个类</u>

> ADT实际上等价于我们定义的数据的逻辑结构以及在逻辑结构上定义的操作,
>
> 抽象数据类型可以看作是描述问题的模型, 它独立于具体的实现.





## 算法的描述和分析

研究数据结构的目的在于更好地进行程序设计. 而程序设计离不开数据的运算, 这种运算的过程(或解题的方法)通常称为算法.

**算法**: 对问题求解的一种描述, 一种解题方法. 算法是由若干条指令组成的有穷序列, 其中每条指令表示一个或多个基本操作。

算法的五要素:

输入: 算法开始前必须给算法中用到的变量初始化, 一个算法的输入可以包含零个或多个数据. 

输出: 算法至少有一个或多个输出. 

有穷性:算法中每一条指令的执行次数都是有限的, 而且每一步都在有穷时间内完成, 即算法必须在执行有限步后结束. 

确定性: 算法中每一条指令的含义都必须明确, 无二义性. 

可行性: 算法是可行的,算法中描述的操作都可以通过有限次的基本运算来实现. 

>  <u>@wwfyde:问题求解:将实际问题描述为数学问题,然后对问题求解</u>



### 算法描述

算法是对问题求解步骤的一种描述. 通俗地说, 一个算法就是一种解题方法. 严格来讲, 算法是由若干条指令组成的有穷序列, 其中每条指令表示一个或多个基本操作.

此外, 算法还必须满足以下五个准则:

1. 输入. 算法开始前必须给算法中用到的变量初始化, 一个算法的输入可以包含零个或多个数据;
2. 输出. 算法至少有一个或多个输出;
3. 有穷性. 算法中每一条指令的执行次数都是有限的, 而且每一步都在有穷时间内完成, 即算法必须在执行有限步后结束.
4. 确定性. 算法中每一条指令的含义都必须明确, 无二义性.
5. 可行性. 算法是可行的, 即算法中描述的操作都可以通过有限次的基本运算来实现.

<mark>可行性通俗点讲就是(操作/问题)可以用计算机来求解,可以抽象为数学运行.</mark>

<mark>算法由一系列指令组成, 而指令由一些列操作组成, 操作则由基本的运算完成</mark>



显然, 一个程序如果对任何输入都不会陷入无限循环, 则它就是一个算法. 算法的含义与程序十分相似, 但二者是有区别的: 程序必须依赖于计算机程序语言, 而<u>一个算法可用自然语言, 计算机程序语言, 数学语言或约定的符号语言来描述</u>. 



### 算法分析

求解一个问题可能有多种不同算法, 而算法的好坏直接影响程序的执行效率, 且不同算法之间的运行效率相差巨大. 

选择最佳的算法, 首先应考虑算法是否正确, 算法的正确性: 对于一切合法的输入数据, 该算法经过有限时间的执行都能得到正确的结果. 评价一个算法的好坏主要由如下考虑:

1. 执行算法所耗费的时间, 即时间复杂性.
2. 执行算法所耗费的存储空间, 主要是辅助空间, 即空间复杂性.
3. 算法应易于理解, 易于编程, 易于调试等, 即可读性和可操作性. 

一个算法所耗费的时间应该是算法中每条语句的执行时间之和, 而每条语句的执行时间是该语句的执行次数(也称频度)与该语句执行一次所需要的时间的乘积. 但不同的计算机系统执行一次基本操作的时间是千差万别的, 不能用一个统一的量来衡量. 一般情况下, 算法中基本操作重复执行的次数是问题规模<var>n</var>的某个函数<var>f(n)</var>, 算法的时间量度记为: $T(n)=O(f(n))$ .



> 算法的时间复杂度一般不是考虑实际时间, 而是考虑基本操作的执行次数; 因为一般情况下一个基本操作的执行时间量与执行时间存在着常量对应关系
>
> 假设有函数f(n), 当n→∞时,如果函数f的增量f(n+Δn)-f(n)无限趋近于g(n), 则称f(n)~g(n), g(n)是f(n)的渐进函数
>
> 时间复杂度正是使用了渐进分析的思想, 但是又不完全等价于渐进函数, 而是考虑函数的数量级(也称数量阶), 不考虑渐进函数的低阶项和首相系数, 例如 $T(n)=2n^3+3n^2+2n+$ 与 $n^3$之比无限趋近不为零的常数, 则称二则是同阶, 或称二则的数量级相同. 可记为$T(n)=O(f(n))$ , 称之为渐进复杂度.

一般情况下, 将算法所要求解问题的输入量称为**问题规模**, 并用一个正整数n表示. 一个算法的时间复杂度(时间复杂性)<var>T(n)</var>就是就是该算法的时间耗费, 他说该算法所求问题规模n的函数. 当问题规模n趋向于无穷大时, 我们把时间复杂度<var>T(n)</var>的**数量级**(阶)称为算法的渐进时间复杂度.

> 对于问题规模n, 可能比较难以理解. 简单来讲, 就是数量大小表示(n个问题),而不单纯是数值,因为算法不仅仅针对于数学问题.

> 时间复杂度 $T(n)=O(n^3) $ : 这个公式的含义是, 描述求解问题规模n在算法f中的运行时间时, 我们更倾向于用**渐进分析**的方式来考虑算法的时间复杂度, 即算法f的变化率, 有点类似于数学中的求导.

假如讲算法中基本操作的重复执行次数看成是问题规模n的某个函数<var>f(n)</var>, 算法的渐进时间复杂度记作: $T(n)=O(f(n))$ . 它表示随着问题规模n的增大, 算法执行时间的增长率和f(n)的增长率相同, 其中<var>f(n)</var>一般为算法中频度最大的语句频度. 在分析算法时, 往往对算法的时间复杂度和渐进时间复杂度不予区分, 而经常是将渐进时间复杂度 $T(n)=O(f(n))$ 简称为时间复杂度. 

> 简单讲, 时间复杂度考虑的是算法渐进时间(执行时间增长率)与问题规模之间的关系
> 求下面程序段的算法时间复杂度:
> 
> ```
> x=0;
> for(i=2;i<=n;i++)
> 	for(j=2;j=i-1;j++)
> 		x=x+1; // 基本问题是求解x=x+1的累加数
> ```
>
> 分析:
> 上面的程序中语句频度最高的语句是 x=x+1; 其执行次数f(n)=e(n-c)*(n-d)次, 可知f(n)~ $n^2$ (渐近于$n^2$ ), 所以该算法的时间复杂度为 $O(n^2)$ .



如果一个算法的执行时间是一个与问题规模n无关的常数 即使是一个较大的常数, 该算法的时间复杂度都为常数阶, 记作T(n)=O(1)



算法的时间复杂度通常具有 $O(1)$, $O(n)$, $nO(log(_2)n)$ $nO(n)$, $O(n^2)$, $O(n^3)$, $O(2^n)$, $O(n!)$ 等形式, 按数量级递增递增排列, 依次为常数阶, 对数阶, 线性阶, 线性对数阶平方阶, 平方阶, 立方阶, k次方阶, 指数阶, 和阶乘阶. 

类似于实践复杂度, 一个算法的空间复杂度 $S(n)$ 定义为该算法所耗费的存储空间. 它是对一个算法在运行过程中临时占用存储空间大小的度量, 是问题规模n的函数. 一个算法在计算机存储器上锁占用的存储空间, 包括存储算法本身所占用的存储空间,算法的输入输出数据所占用的存储空间和算法在运行过程中临时占用的存储空间这三个方面. 

### 小结

著名的瑞士计算机科学家沃思教授曾提出: 算法+数据结构=程序. 他不仅指出了数据结构与算法在计算机科学中的地位, 同时也指出了算法与数据结构的密切关系. <mark>事实上, 在用计算机解决实际问题的过程中, 数据结构与算法是相辅相成, 缺一不可的两个方面: 数据结构是算法处理的对象, 也是设计算法的基础, 一个具体问题的数据在计算机中往往可以采用多种不同的数据结构来表示; 另一方面, 一个实际问题的计算过程常常有多种可用的算法. </mark> 因此, 选择什么样的数据结构和算法就成为实现应用程序过程中最重要的一个课题. 

算法分析是本章的一个重点, 也是一个难点. 算法的好坏直接影响程序的运行效率, 而程序的运行效率又直接影响实际应用系统的使用以及它的生存周期. 因此, 要深刻理解和掌握算法分析的思想, 方法以及时间复杂度的度量等概念. 

本章的主要概念包括: 数据, 数据元素, 数据结构, 逻辑结构, 存储结构; 算法, 算法设计, 算法分析, 时间复杂度等. 



# 线性表:Linear list

> 学习目标
>
> 了解线性表的逻辑结构特征, 即数据原书之间存在的线性关系;
>
> 熟练掌握顺序表和链表的存储表示方法, 特点及有关概念.
>
> 重点掌握顺序表上的插入和删除算法以及动态链表的建立, 查找, 插入和删除算法, 要特别主要链表的头指针, 头节点和开始节点的区别.
>
> 要求在熟悉上述内容的基础上, 能够针对具体应用问题的要求和性质, 选择合适的存储结构, 设计出相应的有效算法, 解决与线性表相关的实际问题.

## 线性表的定义和基本运算

### 定义

线性表(Linear List)是最简单和最常用的一种数据结构, , 它是由n个数据元素(节点)组成的有限序列. 其中, 数据元素的个数n为表的长度. 当n为零时称为空表, 非空的线性表通常记为
$$
(a_1, a_2, ..., a_{i-1}, a_i, a_{i+1}, ..., a_n)
$$
这里的元素 $a_i(1≤i≤n)$ 是一个抽象的符号, 它可以是一个数或者一个符号, 还可以是较复杂的记录. 



(非空)线性表的逻辑特征:

1. 有且仅有一个开始元素$a_1$, 没有前趋, 仅有一个直接后继$a_2$;
2. 有且仅有一个成为终端元素的$a_n$, 它没有后继, 仅有一个直接前趋;
3. 其余元素 $a_i(2≤i≤n-1)$称为内部元素, 他们都有且仅有一个直接前趋$a_{i=1}$和一个直接后继$a_{i+1}$

线性表之间的逻辑关系是相邻关系, 又称线性关系, 线性表是一种典型的线性结构

### 线性表的基本运算

数据的运算是定义在逻辑结构上的, 而运算的具体实现则是在存储结构上进行的. 因此在逻辑结构上定义的运算, 只要给出这些运算的功能是做什么, 至于怎么做灯实现细节, 只有待确定了存储结构之后才能考虑. 对于线性表, 常见的基本运算有以下几种:

1. 置空表 InitList(L), 构造一个空的线性表 L;
2. 求表长
3. 按索引查找
4. 按值查找
5. 插入
6. 删除

## 线性表的顺序存储和基本运算的实现

线性表的顺序存储指的是将线性表的数据元素按其逻辑次序依次存入一组地址连续的存储单元里, 用这种方法存储的线性表称为 **顺序表(sequence list)**

> 线性表是逻辑结构, 顺序表是指存储结构

通常用顺序表来描述数组

**基地址**: 线性表的第一个元素的存储位置

```c
#define ListSize 100
typedef int DataType;
typedef struct{
    DataType data[ListSize];
    int length;
}SeqList;
```

### 插入运算

插入运算会改变线性表的逻辑关系

```c
// 顺序表插入运算的算法描述
void InsertList(SeqList *L, int i, DataType x) {
    int j;
    if(i<1 || i>L->length+1){
        printf("position error");
        return;
    }
    if(L->length>=ListSize){
        printf("overflow");
        return;
    }
    for(j=L->length-1);j>=i-1;j--)
        L->data[j+1]=L->data[j];	// 从最坏一个元素开始逐一后移
    L->data[i-1]=x;					// 插入新元素 x
    L->length++;					//实际表长加 1
}
```

该算法的时间复杂度为 O(n)

### 删除运算

```c
// 顺序表删除运算的算法描述
// 基本思路时从删除位置起对后续元素依次迁移, 并将数组长度减一
DataType DeleteList(SeqList *L, int i) {
    // 在顺序表 L 中删除第 i 个元素, 并返回被删除元素
    int j;
    DataType x;  // DataType x 是一个通用类型表示符, 在使用时再定义实际类型
    if (i < 1 || i > L->length) {
        printf("position error");
        exit(0);
    }
    x = L->data[i];  // 保存被删除元素
    for(j=i;j<=L->length;j++){
        L->data[j-1]=L->data[j];
    }
    L->length--;
    return x;
}
```



## 线性表的链式存储结构

线性表顺序存储结构的特点是, 在逻辑关系上相邻的两个元素在屋里位置上也是相邻的, 因此可以随机存取表中任意元素. 但是, 经常需要做插入和删除操作运算时, 则需要移动大量的元素, 而采用链式存储结构时就可以避免这些移动. 然而由于链式存储结构存储线性表数据元素的存储空间可能是连续的, 也可能是不连续的, 因而链表的节点是不可随机存取的. 链式存储是最常用的存储方式之一, 不仅可以用来表示线性表, 而且还可以用来表示各种非线性的数据结构, 

### 单链表(线性链表)

在使用链式存储结构表示每个元素$a_i$时, 除了存储元素$a_i$本身之外, 还需要一个存储指示其后继元素$a_{i+1}$存储位置的指针, 由这两个部分组成元素$a_i$的存储映像通常称为**节点(node)**. 它包括两个域: 存储数据元素的域称为**数据域**, 存储直接后继存储地址的域称为**指针域**. 利用这种链式存储方式表示的线性表称为 **链表(linked list)** , 链表中的一个节点的存储结构为`{data:any, next: *p}`. n 个节点链接成一个链表, 即为线性表$(a_1, a_2, ..., a_{i-1}, a_i, a_{i+1}, ..., a_n)$ 的链式存储结构. 由于这种链表的每个节点中只包含一个指针域, 因此又称为 **单链表(singly linked list)**

![线性链表存储结构示意图]()

显然, 单链表中每个节点的存储地址是存放在其直接前趋节点的指针域(next)中, 而开始节点无直接前趋, 因此设立头指针head 指向开始节点. 又由于终端节点无后继节点, 所以终端节点的指针域为空, 即 NULL(本文用"∧"表示). 如果链表中一个节点也没有, 则为空链表, 这是 head=NULL.

由此可见, 一个单链表可由头指针唯一确定, 因此单链表可以用头指针的名字来命名. 用 C 语言中的结构类型描述线性表的链式存储结构如下:

```c
typedef struct node{		// 节点类型定义
    DataType data;			// 节点数据域
    struct node * next;		// 节点指针域
}ListNode;					
typedef ListNode * LinkList;// 定义指针变量 LinkList 为 *ListNode
ListNode * p;				// 定义一个指向节点的指针变量p 为*ListNode
LinkList head;				// 定义指向单链表的头指针
```

注意这里的 LinkList 和 ListNode * 是不同名字的同一指针类型, 取名的不同是为了在概念上更加明确. 特别值得注意的是指针变量和指针指向的变量(节点变量)这两个概念. 指针变量的值要么为空(NULL), 不指向任何节点; 要么为非空, 即他的值是一个节点的存储地址. 指针变量所指向的节点地址并没有具体索命, 而是在程序的执行过程中需要存放节点时才产生, 是通过 C 语言的标准函数 malloc() 实现的.  例如, 给指针变量 p 分配一个节点的地址: `p=(ListNode *)malloc(sizeof(ListNode))` ; 该语句的功能是申请分配一个类型为 ListNode 的节点的地址空间, 并将其首地址存入指针变量 p 中, 当节点不需要时, 可以用标准函数 free(p) 释放节点存储空间. 

链表中的节点变量是通过节点变量是通过指针变量来访问的. 因为在 C 语言中是用 p->来表示 p 所指向的变量的, 又由于节点类型是一个结构体类型(struct type), 因此可用 p->data 和 p->next 分别表示节点的数据域变量和指针域变量. 注意当 p 为空值是, 则不指向任何节点, 此时不能通过 p 来访问节点

### 单链表上的基本运算

#### 创建单链表

动态建立单链表的常用方法有两种: 一种是头插入法, 一种是尾插法. 

1 头插法建表

```c
LinkList CreateListF() {
    LinkList head;
    ListNode * p;
    char ch;
    head = NULL;
    ch=getchar();
    while (ch!='\n'){
        p=(ListNode *)malloc(sizeof(ListNode));	// 申请新节点
        p->data=ch;
        p->next=head;
        head=p;
        ch=getchar()	// 读入下一个字符
    }
    return head;  // 返回链表的头指针
}
```

2 尾插法

略

#### 查找运算

在单链表中, 任何两个节点的存储位置之间没有固定的联系, 每个节点的存储位置包含在其直接前趋的指针域中. 因此, 单链表中存取第 i 个节点时, 必须从表头节点开始查找, 所以链表结构是非随机存取的存储结构. 若链表带头节点时, 就应该特别注意头节点和表头节点(即开始节点)的区别. 

1 按节点序号查找

```c
ListNode* GetNodei(LinkList head, int i) {
    // head 为带头节点的单链表的头指针
    // 若查找成功, 则返回查找节点的存储地址(位置), 否则返回 NULL
    LisNode* p; int j;
    p=head->next; j=1;
    while(p!=NULL && j<i){
        p=p->next; ++j;
    }
    if (j==i)
        return p;
    else
        return NULL;
}
```

2 按节点值查找

略

#### 插入运算

#### 删除运算

### 循环链表

循环链表是链式存储结构的另一种形式. 其特点是单链表中最后一个节点(终端节点)的指针域不为空, 而是指向链表的头节点, 使整个链表构成一个环. 因此从表中任一节点开始都可以访问表中其他节点. 这种结构形式的链表称为单循环链表. 类似地, 还可以有多重链的循环链表. 

### 双向链表(doubly linked list)

单链表和单循环链表的节点中只设有一个指向其直接后继的指针域, 因此, 从某个节点出发只能顺指针向后访问其他节点. 若需要查找节点的直接浅语, 则需要从头指针开始查找某个节点的直接前趋节点.

若希望从表中快速确定一个节点的直接前趋, 只要在单链表的节点类型中增加一个指向其直接前趋的指针域prior即可. 这样形成的链表中又两条不同方向的链, 因此称之为 **双向链表** . 双向链表及其节点类型描述如下:

```c
typedef struct dlnode {
    Data Type;
    struct dlnode *prior, *next;
}DLNode;
typedef DLNode * DLinkList;
DlinkList head;

```



## 顺序表和链表的比较

线性表有两种存储结构: 顺序存储结构(顺序表)和链式存储结构(链表). 这两种存储表示各有其特点: 顺序表结构可以随机存取表中任一元素, 元素的存储位置可用一个简单的公式来表示, 然后在做插入和删除操作时, 需要移动大量元素. 而链式存储结构则克服在做插入和删除操作时移动大量元素的问题, 但却失去了随机访问的特点.

那么在实际应用中, 究竟选择哪种存储结构呢? 这就要根据具体问题的要求和性质来决定. 通常从两方面的性能来比较.

1.**时间性能**

顺序表的时间访问时间复杂度为O(1)

而链式存储结构必须从表头开始沿链逐一访问个节点, 其时间复杂度为O(n)

2.**空间性能**

## 小结



## ?散列表(自己加的位置, 这不是线性表)

> hash table

虽然数据是散列存储在散列表中, 但是hash值却是有大小和顺序的. 所以从散列表取出元素时是通过哈希来实现的. 

# 栈和队列

> stack and queue
>
> 学习目标
>
> 1. 掌握栈和队列这两种数据结构的特点, 懂得在什么问题中应该使用哪种结构.
> 2. 熟悉栈, 队列与线性表的关系, 顺序栈(顺序队列)与顺序表的关系, 以及链栈(链队列)与链表的关系
> 3. 重点掌握在顺序栈和链栈上实现的栈的五种基本运算, 特别是栈满和栈空的判断条件及它们的描述.
> 4. 重点掌握循环队列和链队列上实现队列的五种基本运算, 特别注意队满和队空的描述方法
> 5. 熟悉栈和队列的"下溢"和"上溢"的概念, 循环队列是如何消除"假上溢"的

## 栈

### 栈的定义及其运算

**栈(Stack)** 是现代在表的一端行插入和删除运算的线性表, 通常将插入, 删除的一端称为栈顶(top), 另一端陈伟栈底(bottom). 不含元素的空表称空栈. 栈又称为后进先出(Last In First Out)的线性表, 简称为LIFO表

## 栈的应用举例

栈的应用非常广泛, 只要满足LIFO原则, 都可以使用栈作为数据结构. 

## 队列

### 队列的定义及其运算

**队列(Queue)**也是一种操作受限的线性表, 他只允许在表的一端进行元素插入, 而在另一端进行元素删除. 允许插入的一端称为队尾(rear), 允许删除的一端称为队头(front). 队列又称先进先出(First In First Out)表. 

### 顺序循环队列

### 链队列

队列的链式存储结构称为链队列

## 栈和队列的应用实例

# 多维数组和广义表

> 熟悉数组在按行优先顺序的存储结构中
>
> 

## 多维数组和运算

数组(array)是我们比较熟悉的一种数据类型. 由于数组中各元素具有相同的数据类型, 并且数组元素的下标一般具有固定的上界和下界, 因此, 数组的处理比其他复杂的结构较为简单. 当数组维数为1时, 数组是一种元素个数固定的线性表, 而维数大于1时, 称为**多维数组**, 它可以看成是线性表的推广. 这里仅讨论多维数组

由于对数组一般不做插入和删除操作, 因此数组一旦建立, 结构中的元素个数和元素键的关系就不再发生变化. 所以一般是采用顺序存储的方法来表示数组. 

二维数组: A<sub>m×n</sub> <u>注意: 二维不是二列, 是二阶</u>

由于计算机的内存结构是一维的, 所以多维数组的数据存储结构就碧玺按某种次序将元素排成一个线性序列. 因此, 二维数组又可以以行向量的形式表示:
$$
A_{m×n}=[[a_{00},a_{01},...,a_{0 n-1}],[a_{10},a_{11},...,a_{1 n-1}],...,[a_{n-1 0},a_{n-1 2},a_{n-1 n-1}]]
$$
或者以列向量的形式表示(m与n位置互换)

## 矩阵的压缩存储

一般用二维数组存储矩阵

## 广义表基础

广义表是线性表的推广, 又称**列表**. 线性表的元素仅限于原子项, 即每个数据元素只能是一个数或一个记录, 如果放松对线性表元素的这种限制, 允许它们自身具有结构, 由此就产生了广义表的概念. 

### 广义表的定义

# 树-Trees

> 熟悉树的定义, 表示方法, 有关术语和基本概念
>
> 唱我二叉树的递归定义

## 树的基本概念和术语

树形结构是一类重要的非线性结构, 树中节点之间具有明确的层次关系, 节点之间有分支, 非常类似于真正的树.树形结构在客观世界大量存在, 如行政机构和家谱等都可以用树形结构形象地表示. 在计算机应用领域中, 树形结构也被广泛的应用.

树形结构是一个递归结构.

### 树的定义

树是n(n≥0)个节点的有限集T. 它或是空集或是非空集. 对任意一颗非空树: 

1.有且仅有一个特定的的称为根(root)的节点;

2.当n>1时, 其余的节点可分为m(m>0)个互不相交的有限集$T_1, T_2, ..., T_m$, 其中每个集合本身有只一颗树, 并称为根的**子树**. 

<mark>树的基本元素是节点, 节点意味着树是链式存储结构</mark>

### 树的表示法

略

### 基本术语

为了更好地理解和掌握数据结构的相关知识, 首先要书序树结构中的基本术语.

树的节点包含一个数据元素及若干个指向其子树的分支. 一个节点拥有的子树数称为该节点的 **度(degree)**. 一颗树种节点的最大度数称为该树的度. 度数为零的节点称为 **叶子节点(leaf node)** 或终端节点. 度数不为零的节点称为非终端节点或**分支节点**. 除根节点之外, 分支节点也称为**内部节点**, 而**根节点**又称为开始节点.

树种某个节点子树的根称为该节点的孩子(child), 相应地, 该节点称为孩子节点的双亲或父节点. 

若在一颗树中存在着一个节点序列$k_1, k_2, ..., kj$是的$k_i$是$k_{i+1}$的父节点(1≤j≤j), 则成该节点序列是从$k_1$到$k_j$的一条**路径**, 其**路径长度**为j-1. 显然, 从树根到树中其余节点均存在唯一的一条路径. <u>子节点永远只有一个父节点且确定</u>

若树种节点$k_i$到$k_j$存在一条路径, 责成$k_i$是$k_j$的祖先, 节点$k_j$是$k_i$的子孙.

树中节点的**层次(level)**是从根开始算起, 根为第一层, 其余节点的层次等于其双亲节点的层数加1. 树中节点的最大层次称为树的**深度(Depth)**或高度.

**森林(Forest)** 是m(m≥0)颗互不相交的树的集合. 若将一个树的根节点删除, 就得到该树的子树所构成的森林; 如果将森林中所以树作为子树, 用一个跟节点吧子树都连接起来, 森林就变成一颗树.



## 二叉树(Binary Trees)

### 二叉树的定义

二叉树(Binary Tree)是n(n≥0)个节点的有限集合, 它的每个节点至多只有两棵子树. 它或者是空集, 或者是由一个根节点及两棵互不相交的分别称作这个跟的左子树和右子树的二叉树组成.

### 二叉树的性质

#### 性质1

在二叉树的第i层上至多有 $2^{i-1}$ 个节点(i≥1).

#### 性质2

深度为k的二叉树至多有$2^k-1$个节点(k≥1)

#### 性质3

对任何一棵二叉树T, 若其叶子节点数为$n_0$, 度数为2的节点数为$n_2$, 则$n_0=n_2+1$

证明: 设$n_1$为二叉树T中度数为1的节点数. 因为二叉树中所有节点的度均不大于2,所以二叉树T上的节点总数为
$$
n=n_0+n_1+n_2
$$
另一方面, 度数为1的节点表示它有一个孩子节点, 度数为2的节点有两个孩子节点, 所以树中孩子节点总数应该是$n_1+2n_2$. 而树中只有跟节点不是任何节点的孩子节点, 因此二叉树中的节点总数又可表示为
$$
n=n_1+2n_2+1
$$
由上面两个式子解得: $n_0=n_2+1$ 

满二叉树和完全二叉树是两种特殊情形的二叉树

**满二叉树(full binary tree)**: 一颗深度为k且有$2^k-1$个节点的二叉树称为满二叉树

**完全二叉树**: 若一棵深度为k的二叉树,其前k-1层是一棵满二叉树, 而最下面一层(即第k层)上的节点都集中在盖层最左边的若干位置上, 则称此二叉树为完全二叉树. <u>完全二叉树,叶子节点总是从左往右依次插入的</u>

显然, 满二叉树一定是完全二叉树, 但完全二叉树则不一定是满二叉树.

#### 性质4

具有n个节点的完全二叉树的深度k为$⎣logn+1⎦$或$⎡log(n+1)⎤$

根据二叉树定义, 深度为k的的节点数n的可能取值有:
$$
2^{k-1}-1<n<2^k
$$
或
$$
2^{k-1}≤n≤2^k-1
$$
对上述等式取对数可以推导出k深度为

k-1 ≤logn, k≥log(n+1) 即k的值为$⎣logn+1⎦$或$⎡log(n+1)⎤$ 的整数

### 二叉树的顺序存储结构

### 二叉树的链式存储结构

一般情况多采用链式存储方式来存储二叉树. 设计不同的(节点)结构可以构成不同形式的链式存储结构. 在二叉树的链式存储表示中, 通常采用的方法是: 每个节点设置三个域, 即值域, 左指针域和右指针域, 用data表示值域, 用lchild和rchild分别表示指向左右子树的指针域.

相应地类型说明如下:

```c
typedef struct node{
    DataType data;
    struct node *lchild, *rchild;
}BinTNode;
typedef BinTNode * BinTree;
```

在一棵二叉树中, 舍友一个指向其跟节点(即开始节点)的BinTree型头指针bt及所有类型为BinTNode的节点, 就构成了二叉树的链式存储结构, 并称其为**二叉链表**

二叉链表是一种常用的二叉树存储结构, 在二叉树上的有关运算一般都采用这种链式存储结构, 但有时胡伟立便于查找节点的双亲, 还可以在节点结构中增加一个指向其双亲的指针parent.

### 二叉树的运算

#### 生成

#### 遍历

#### 应用举例

## 线索二叉树

从二叉树的运算可知, 遍历二叉树是以一定的规则将二叉树中的节点排列成一个线性序列, 得到二叉树中的前序序列或中序序列或后序序列. 这实质上是对一个非线性结构的线性化操作, 使每个节点(除第一个节点和最后一个节点外)在这个线性序列中有且仅有一个直接前趋和一个直接后继.

## 树和森林

## 哈夫曼树及其应用

### 最优二叉树



## B-Tree





## B+Tree

# 图-Graphs

## 图的定义和基本术语

## 图的存储结构

## 图的遍历

### 深度优先搜索遍历

### 广度优先搜索遍历

## 图的生成树和最小生成树

## 最短路径

## 拓扑排序

# 排序-Sort,dfs, bfs, dp

> 深刻理解各种内部排序方法的基本思想及其特点.
>
> 熟悉各种内部排序方法的排序过程.
>
> 掌握各种内部排序的算法的时间复杂度的分析方法, 并熟记其分析结论
>
> 能根据各种排序方法的优缺点及不同的应用场合, 选择合适的方法进行排序.

## 基本概念

排序(Sort)是数据处理中经常使用的一种重要的运算. 

所谓排序, 就是要整理问价哪种的记录, 使得它按给定的关键字递增(或递减)的次序排列. 如果带排序文件中存在多个关键字相同的记录, 经过排序后, 这些具有相同关键字的记录之间的相对次序保持不变, 责成这种排序方法是稳定的; 反之, 则是不稳定的. 

若整个待排序数据都在内存中处理, 不涉及数据的内外存交换, 则称这种排序为内部排序(简称内排序); 反之为外排血. 按所用排序策略的不同, 内部排序方法又可以分为五类: 插入, 选择, 交换, 归并和分配排序.

通常, 在排序的过程中需要进行两种基本操作:比较两个关键字的大小, 改变指向记录的指针或移动记录本身. 而待排序记录的存储方式一般有三种: 顺序结构, 链式结构和辅助表形式. 

评价排序算法的标注主要有两套: 执行算法需要时间, 以及算法所需要的附加空间. 另外, 算法本身的复杂度也是考虑的重要原因之一. 排序的时间开销, 一般情况下可以用算法执行中关键字的比较次数和记录的于东次数来衡量.

本章的讨论中, 若无特别声明, 都假定排序操作时按递增要求的, 排序文件以顺序表作为存储结构, 并假定关键字为证书. 为此, 定义待排序记录的数据类型如下:

```c
#define MAXSIZE 100
typedef int KeyType;
typedef struct {
    KeyType key;
    InfoType otherinfo;
}RecType;
typedef RecType SeqList[MAXSIZE+1];	// 表中0元素空座或用作哨兵单元
SeqList R;							// R为待排序的记录文件
```



## 插入排序(insertion sort)

### 直接插入排序

插入排序的基本思想是: 每次将一个待排序的记录按其关键字的大小插入到前面已排好序的文件中的适当位置, 直到全部记录插入完为止.

```c
// 插入排序
void InsertSort(SeqList R, int n){
    int, i, j;
    for (i=2; i<=n;i++)
        if (R[i].key<R[i-1].key) {
            R[0]=R[i];
            for (j=i-1;R[0].key<R[j].key; j--)
                R[j+1]= R[j];
            R[j+1]=R[0]
        }
}
```

```python
# python实现
def insert_sort(arr: List[int]) -> List[int]:
    """
    将列表分类两个部分已排序arr[:i]和未排序arr[i:]
    config未排序分组中取下首位并存储
    将arr[i]插入arr[:i], >=则不动, 小于则插入
    :param arr:
    :return:
    """
    for i in range(1, len(arr)):  # 移动i指针以排序
        print(type(repr(i)))
        r = arr[i]  # 记录操作的数
        j = i - 1  # 创建j指针
        while j >= 0 and r < arr[j]:  # 当r>=arr[j]或j<0时停止
            arr[j + 1] = arr[j]  # 将记录后裔
            j -= 1  # 移动指针
        arr[j + 1] = r  # 将操作对象插入正确位置

    return arr  # 可以不用返回, 因为,该算法是直接修改的传入的列表
```

插入排序的时间复杂度为$O(n^2)$

### 希尔排序(shell sort)

## 交换排序(Exchange Sort)

交换排序的基本思想是: 两轮比较待排序记录的关键字, 如果发现两个记录的次序相反时即进行交换, 直到所有记录都没有反序时位置

### 冒泡排序(bubble sort)

> 冒泡排序算法的时间复杂度$O(n^2)$

冒泡排序的基本思想是: 通过相邻元素之间的比较和交换, 使关键之较小的元素逐渐从底部移向顶部, 就像水底下的气泡一样逐渐向上冒泡

冒泡排序过程具体描述:首先将R[n].key和R[n-1].key进行比较, 若R[n].key<R[n-1].key则交换R[n]和R[n-1], 使轻者上浮, 重者下沉; 接着比较R[n-1].key和R[n-2].key,同样使轻者上浮, 重者下沉;依此类推;直到比较R[2].key和R[1].key,若反序则交换, 第一趟排序结束, 此时,记录R[1]的关键字最小, 然后在对R[n]~R[2]的记录进行第二趟排序, 使慈孝关键字的元素被上浮到R[2]中, 重复进行n-1趟后, 整个冒泡排序结束.

其算法描述如下: 

```c
// 类C算法描述
void BubbleSort(SeqList R, int n){
    int i, j, flag;				// 采用自底向上扫描数组R[1..n]做冒泡排序
    for(i=1;i<n;i++{			// 最多做n-1趟排序
        flag=0;					// 表示每一趟是否有交换, 先置0
        for(j=n;j>=i+1;j--){
            R[0]=R[j-1];		// R[0]作为交换时的暂存单元
            R[j-1]=R[j];
            R[j]=R[0];
            flag = 1;			// 有交换, flag置1
        }
        if (flag==0) return;
    }
}
```





```python
# Python实现
def bubble_sort(array: MutableSequence) -> MutableSequence:
    """
    从最后array[n-1]和array[n-2]开始,若array[n-1]<array[n-2]则相互交换值, 依次递减, 直到比较a[1]和a[0];
    array[0]排序完成, 依次排序array[1]...array[n-1] 最终完成排序

    :param array:
    :return:
    """
    n = len(array)
    for j in range(1, n):  # 第一轮找出最小的, 找出第二小的
        for i in range(n-1, j-1, -1):
            if array[i] < array[i-1]:
                array[i], array[i-1] = array[i-1], array[i]

    return array
```



### 快速排序(Quick Sort)

**快速排序**(Quick Sort)又称为划分交换排序. 快速排序是对冒泡排序的一种改进方法, 在冒泡排序中, 进行记录关键字的比较和交换式在相邻记录之间进行, 记录每次交换只能上移或下移一个相邻位置, 因而总得比较和移动次数较多. 

在快速排序排序中, 记录关键字的比较和记录的交换是从两端向中间进行的, 待排序关键字较大的记录记录一次就能够交换到后面单元中, 而关键字较小的记录一次就能够交换到前面单元中, 记录每次移动的距离较远, 因此总得比较和移动次数较少, 速度较快, 故称为快速排序.

快速排序的基本思想是: 首先在当前无序区R[low..high]中任取一个记录作为排序比较的基准(不妨设为x), 用词基准降当前无序区划分为两个较小的无序区R[low..i-1]和R[i+1..high], 并使左边的无序区中所有记录的关键字均小路等于基准的关键字, 右边的无序区中所有记录的关键字大于等于基准的关键字, 而基准记录x则唯一最终排序的位置i上, 即R[low..i-1]中的关键字≤x.key≤R[i+1..high]中的关键字. 这个过程称为一趟快速排序(或一次划分).当R[low..i-1]和R[i+2..high]均非空时, 分别对他们进行上述划分, 直到所有无序区中的记录均与排序好为止.



## 选择排序

### 直接选择排序

### 堆排序

堆(heap)定义:n个记录的关键字序列$k_1, k_2, ...,k_n$称为堆, 当且仅当满足一下关系:
$$
k_i≤k_{2i}且k_i≤k_{2i+1},或k_i≥k_{2i}且k_i≥k_{2i+1} (1≤i≤⎣n/2⎦)
$$
前者称为小跟堆, 后者称为大根堆.

## 归并排序(Merge Sort)

## 分配排序

## 内部排序方法的分析比较

# 查找-Search

> 熟练掌握顺序查找, 二分查找和分块查找的方法, 并能灵活应该.
>
> 熟练掌握二叉排序树的构造方法和查找过程
>
> 了解 B 树的特点及建树过程
>
> 熟练掌握散列表的构造方法及其查找过程;
>
> 熟练掌握各种查找方法在等概率情况下查找成功的平均查找长度的计算方法. 

## 基本概念

查找(Search)又称检索, 是数据处理中经常使用的一种重要运算

## 顺序表的查找

顺序表是指线性表的顺序存储结构. 假定顺序表采用一维数组表示, 其元素类型为 NodeType, 他含有关键字key域和其他数据域data, key域的类型假定用标识符KeyType(int)表示, 具体表的类型定义如下:

```c
typedef struct{
    KeyType key;
    InfoType data;
}NodeType;
typedef NodeType SeqList[n+1]
```



### 顺序查找

基本思路: 从表的一端开始, 顺序扫描线性表, 依次把扫描到的记录关键字语给定值k相比较, 若某个记录的关键之等于k, 则表明查找成功, 返回该记录所在的下标; 若直到所有记录记录都比较晚, 任务找到关键之语l相等的记录, 则表明查找失败, 返回0值. 

顺序查找的算法描述如下:

```c
int SeqSearch(SeqList R, keyType, int n)
{
    R[0].key = k;
    i=n;
    while (R[i].key !=k)
        i--;
    return i
    
}
```



### 二分查找

二分查找(Binary Search)又称折半查找, 是一种效率较高的查找方法. 二分查找要求查找对象的线性表必须是顺序存储结构的有序表.

二分查找的过程是: 首先将待查的k值和有续表R[1..2]的中间位置mid上的记录的关键字进行比较, 若相等

### 分块查找

也称索引顺序查找

分块查找的基本思想是: 首先查找索引表, 可用二分查找或顺序查找, 然后在确定的块中进行顺序查找. 由于分块查找实际上是两次查找过程, 因此整个查找过程的平均查找长度, 是两次查找的平均长度之和



## 树表的查找

树表查找是对树形存储结构所做的查找. 树形存储结构是一种多链表, 表中的每个节点包含一个数据域和多个指针域, 每个指针域指向一个后继节点. 

> wwfyde, 20230628: 为了提升查找效率, 必须将数据按照某种数据结构排序

### 二叉排序树(Binary Sort Tree)



```c
typedef struct node {
    KeyType key; 	// 关键字
    DataType other;		// 
    struct node*lchild, *rchild;
}BSTNode;
typedef BSTNode * BSTTree;
```

```go
struct Node struct{
    key int
    value Item
    left *Node
    right *Node
}
```



### B-Tree

#### 定义

> Wiki: In [computer science](https://en.wikipedia.org/wiki/Computer_science), a **B-tree** is a self-balancing [tree data structure](https://en.wikipedia.org/wiki/Tree_data_structure) that maintains sorted data and allows searches, sequential access, insertions, and deletions in [logarithmic time](https://en.wikipedia.org/wiki/Logarithmic_time). The B-tree generalizes the [binary search tree](https://en.wikipedia.org/wiki/Binary_search_tree), allowing for [nodes](https://en.wikipedia.org/wiki/Node_(computer_science)) with more than two children. Unlike other [self-balancing binary search trees](https://en.wikipedia.org/wiki/Self-balancing_binary_search_tree), the B-tree is well suited for storage systems that read and write relatively large blocks of data, such as [databases](https://en.wikipedia.org/wiki/Database) and [file systems](https://en.wikipedia.org/wiki/File_system).

在计算机科学领域, B-Tree 是一种自平衡树型数据结构, 可以保证数据数据排序和允许查找, 顺序访问, 插入, 和删除在对数时间内完成. B-Tree ? **二叉查找树(binary search tree)**, 允许超过两个子节点. 不同于其他 自平衡binary search tree, B-Tree 非常适合大型读写数据块存储系统, 比如数据库和文件系统. 



特点

节点分类: 根节点, 非叶子节点, 叶子节点

叶子节点之间双向链接

### B+Tree

### 红黑树(red-black tree)

1. 节点是红色或黑色
2. 根节点是黑色
3. 所有叶子都是黑色（叶子是NIL节点）
4. 每个红色节点的两个子节点都是黑色（从每个叶子到根的所有路径上不能有两个连续的红色节点）
5. 从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点

![image-20220503101640833.png](https://wwfyde.oss-cn-hangzhou.aliyuncs.com/images/202305310412396.png)

**红黑树的优点：** 限制了左右子树的树高，不会相差过大。

**缺点：** 规则复杂，一般人想要弄懂这玩意儿，就已经很费劲了，更别说使用了。

## 散列表查找





# 数据结构-Old



## 队列(queue)

> 先进先出

## 堆(heap)

> 树形数据结构, 只能从两端取 二叉堆 优先队列( queue)
>
> 也是一个数组

*堆*(Heap)是计算机科学中一类特殊的*数据结构*的统称。*堆*通常是一个可以被看做一棵完全二叉树的数组对象。

特性: 完全二叉树, 数组对象

## 栈(stack)

> 线性数据结构, 只能 从 两端取  取最新的

特点 : 后进先出

## 字符串(strings)

## 哈希(hashes)

## 列表(lists)

## 集合(sets)

## 有序集合(sorted stes)

