---
aliases: 
    - system-design
    - system-architecture
    - architecture-design
tags:
    - Python
    - Go
author: wwfyde
title: System Design
---

# 系统设计



> 系统科学, 系统分析 , 系统架构, 系统工程, 系统理论, 架构设计
>
> 设计=软件架构, 中文世界中通常将系统设计称为系统架构
>
> 控制论 信息论 系统论 	
>
> 控制: 根据 状态 响应 结构
>
> 耗散结构理论 | 平衡结构理论

需求 - 搜索 - 认知 - <u>分析</u> - 设计 - 实现

需求实现 = 问题解决 解决问题的策略

准确 描述问题和需求 建立合适的表征 选择正确的模型 

## 参考资料

- 数据密集型应用系统设计(书籍)
    Design Data-Intensive Applications
    - 电子书
    - 纸质书

- ByteByteGo
- [ByteByteGo-system-design](file:///Users/wwfyde/Desktop/Ebooks/System-design.pdf)
- 系统架构: 复杂系统产品的设计与开发
- 架构整洁之道
- 领域驱动设计(Domain-Driven Design, DDD)

## 博客文章

- [程序员架构修炼之道：软件架构基本概念和思维](https://cloud.tencent.com/developer/article/2111810)

![img](https://wwfyde.oss-cn-hangzhou.aliyuncs.com/images/202305311027658.png)

![img](https://wwfyde.oss-cn-hangzhou.aliyuncs.com/images/202306011328568.png)



Plan -> Code-> Build -> Test -> Release -> Deploy -> Operate -> Monitor -> Plan



![Image](https://wwfyde.oss-cn-hangzhou.aliyuncs.com/images/202306061432457.jpeg)

### 



## 常见架构模式(architecture patterns)

> - https://www.redhat.com/architect/14-software-architecture-patterns

```
"The architectural pattern captures the design structures of various systems and elements of software so that they can be reused. During the process of writing software code, developers encounter similar problems multiple times within a project, within the company, and within their careers. One way to address this is to create design patterns that give engineers a reusable way to solve these problems, allowing software engineers to achieve the same output structurally for a given project."
```



1. **Layered pattern**
2. **Client-server pattern**
3. **Master-slave pattern**
4. **Pipe-filter pattern**
5. **Broker pattern**
6. **Peer-to-peer pattern**
7. **Event-bus pattern**
8. **Model-view-controller pattern**
9. **Blackboard pattern**
10. **Interpreter pattern**



# 核心概念

> 技术指标, 专业术语, Glossary



## 参考资料

- https://glossary.cncf.io/

## Lists

- 设计与架构:

    - 设计(Design):
    - 架构(Architecture)
    - 二者关系: 
        - 软件设计与架构之间的关系，作者认为它们是无区别的。这段话后面会有详细描述，主要的意思是作者认为"架构"一词经常用于与低层次细节分离了的高层次上下文中，然而"设计"似乎经常表示在低层次上的结构和决定。
        - 也就是架构是跟更高层次的抽象相关，设计是跟组件实现的细节相关，普遍认为架构师就是跟更高层次的抽象相关，而不是在一线编写代码，作者认为是大错特错。
    - 参考资料:
        - https://mp.weixin.qq.com/s/t8IoxdeVzHEX2miCxE6iyA

    



### 技术指标

- 可靠性(reliable, reliability)
    - 可用性(available), 高可用
    - 当出现意外情况如硬件、软件故障、人为失误等, 系统应可以继续正常运转: 虽然性能可能有所降低, 但确保功能正确. 
    - 也包含了容错性
    - 支持数据备份和恢复
    - 可观测性, 支持服务健康度检查等等. 
    
- 健壮的(robust)
- 容错性(resilient/fault-tolerant)
- 可复原的(resilient)
- 可伸缩性(scalable)
    可扩展性
    - 随着规模的的增长, 例如数据量、流量或复杂性, 系统应以合理的方式来匹配这种增长
    
- 可维护性(maintainable)
    - 随着时间的推移, 许多新的人员参与到系统开发和运维, 以维护现有功能或适配新场景等, 系统都应高效运转. 

- 流式处理(stream processing): 持续发送消息至另一个进程, 处理采用异步方式
- 批处理(batch processing): 定期处理大量的累积数据
- 模块化(modular)
- 可测试的(testable)



## 架构模式-Architecture_Patterns

## 数据密集型应用系统设计
data Intensive
institute



# 核心理念

## 领域驱动设计

## 结构化设计

# **文章-Articles**

## **ByteByteGo**

## What does API gateway do? 

The diagram below shows the detail. 

Step 1 - The client sends an HTTP request to the API gateway. 

Step 2 - The API gateway parses and validates the attributes in the HTTP request. 

Step 3 - The API gateway performs allow-list/deny-list checks. 

Step 4 - The API gateway talks to an identity provider for authentication and authorization. 

Step 5 - The rate limiting rules are applied to the request. If it is over the limit, the request is rejected. 

Steps 6 and 7 - Now that the request has passed basic checks, the API gateway finds the relevant service to route to by path matching. 

Step 8 - The API gateway transforms the request into the appropriate protocol and sends it to backend microservices. 

Steps 9-12: The API gateway can handle errors properly, and deals with faults if the error takes a longer time to recover (circuit break). It can also leverage ELK (Elastic-Logstash-Kibana) stack for logging and monitoring. We sometimes cache data in the API gateway. 

Over to you: 

1) What’s the difference between a load balancer and an API gateway? 

2) Do we need to use different API gateways for PC, mobile and browser separately?  — Subscribe to our weekly newsletter to get a Free System Design PDF (158 pages): [https://bit.ly/42Ex9oZ](https://t.co/4QcX8btXGL)

![Image](https://wwfyde.oss-cn-hangzhou.aliyuncs.com/images/202307301125209.jpeg)

### system-design-blueprint

[system-design-blueprint-the-ultimate-guide](https://blog.bytebytego.com/p/ep56-system-design-blueprint-the#§system-design-blueprint-the-ultimate-guide)

- Load Balancing
    \- API Gateway
    \- Communication Protocols
    \- Content Delivery Network (CDN)
    \- Database
    \- Cache
    \- Message Queue
    \- Unique ID Generation
    \- Scalability
    \- Availability
    \- Performance
    \- Security
    \- Fault Tolerance and Resilience
    \- And more

![Image](https://wwfyde.oss-cn-hangzhou.aliyuncs.com/images/202309140125661.jpeg)



# 设计原则

## 设计原则1

> system design principles

System design principles are fundamental guidelines that help software engineers and designers create systems that are scalable, maintainable, and efficient. Some important system design principles include:

1. Modularization: Breaking up a system into smaller, independently functioning modules helps to improve its maintainability, scalability, and flexibility.
2. Separation of Concerns: Separating different concerns or responsibilities in a system (e.g., user interface, business logic, data storage) helps to improve its maintainability, as changes in one area can be made without affecting others.
3. Loose Coupling: Reducing the degree of interdependence between components or modules in a system helps to improve its flexibility and maintainability.
4. High Cohesion: Ensuring that each module or component in a system has a clear, well-defined purpose and performs a single, focused task helps to improve its maintainability and understandability.
5. Abstraction: Using abstraction to hide implementation details and present a simplified, high-level view of a system can help improve its maintainability, scalability, and flexibility.
6. Performance Optimization: Designing systems with performance in mind, and using techniques such as caching, load balancing, and database indexing to optimize performance, can help ensure that a system can scale to handle increasing levels of traffic or usage.
7. Resilience: Designing systems that can recover from failures or errors, using techniques such as redundancy, fault tolerance, and graceful degradation, can help ensure that a system remains available and usable in the face of unexpected events.

These principles can be applied to many different types of systems, from small, single-purpose applications to large-scale, distributed systems. By following these principles, designers and engineers can create systems that are easier to build, maintain, and scale, while also ensuring that they meet the needs of their users and stakeholders.

### 模块化-Modularization

Modularization: Breaking up a system into smaller, independently functioning modules helps to improve its maintainability, scalability, and flexibility.

### 关注点分离-Separation of Concerns

Separation of Concerns: Separating different concerns or responsibilities in a system (e.g., user interface, business logic, data storage) helps to improve its maintainability, as changes in one area can be made without affecting others.

### 低耦合-Loose Coupling

Loose Coupling: Reducing the degree of interdependence between components or modules in a system helps to improve its flexibility and maintainability.

### 高聚合

High Cohesion: Ensuring that each module or component in a system has a clear, well-defined purpose and performs a single, focused task helps to improve its maintainability and understandability.

### 抽象

Abstraction: Using abstraction to hide implementation details and present a simplified, high-level view of a system can help improve its maintainability, scalability, and flexibility.

### 性能优化

Performance Optimization: Designing systems with performance in mind, and using techniques such as caching, load balancing, and database indexing to optimize performance, can help ensure that a system can scale to handle increasing levels of traffic or usage.

### 高弹性

Resilience: Designing systems that can recover from failures or errors, using techniques such as redundancy, fault tolerance, and graceful degradation, can help ensure that a system remains available and usable in the face of unexpected events.

## 质量属性

系统架构, 软件设计, 系统设计

Sure, here are a few more system design principles:

### 扩展性/灵活性-Scalabe/Flexible

Scalability: A system that is scalable can handle increases in load or demand without becoming overloaded or crashing. Scalability can be achieved through techniques such as load balancing, horizontal or vertical scaling, and efficient use of resources.

Flexibility describes how easily a system can adapt to changing requirements or environments. It involves the ability to add new features, modify existing ones, and integrate with external systems.

### 易读性/可读性-legible/readable

命名与可读性

可读性, readable

### 可靠性-Reliability

功能与可靠性

### 性能-Performance

性能与速度

### 安全性-secure

安全性与隐私

Security: A system that is secure protects against unauthorized access, data breaches, and other security threats. Security can be achieved through techniques such as encryption, access controls, and authentication.

### 可维护性-maintainable

文档与可维护性

Maintainability: A system that is maintainable can be easily updated, modified, and extended over time. Maintainability can be achieved through techniques such as modularization, good documentation, and use of design patterns.

### 简洁性-simple

Simplicity: A system that is simple is easier to understand, use, and maintain. Simplicity can be achieved through techniques such as minimizing complexity, avoiding unnecessary features, and using familiar design patterns.



### 可用性-Usable

Usability: A system that is usable is designed with the user's needs and goals in mind, and is easy to learn, use, and navigate. Usability can be achieved through techniques such as user research, user-centered design, and usability testing.

### 可复用性-reusable

### 可移植性-Portability

便携的

### 互操作性-Interoperable

系统之间共享和通信和交互能力

Interoperability: A system that is interoperable can communicate and work with other systems and technologies, enabling integration and collaboration. Interoperability can be achieved through techniques such as use of open standards and APIs.

### 可测试性-testable

Testability: A system that is testable is designed with testing in mind, enabling efficient and effective testing of its functionality, performance, and security. Testability can be achieved through techniques such as design for testability, automated testing, and continuous integration.

These principles are not exhaustive, and different systems may require different combinations of principles depending on their specific needs and requirements. However, by following these and other system design principles, engineers and designers can create systems that are robust, efficient, maintainable, and user-friendly.

### 百度AI回答

软件设计质量属性评估指标可以根据不同的特性进行细分。以下是一些常见的评估指标：

1. 可维护性（Maintainability）：

* 代码规范符合度：代码风格、命名规范、注释等是否符合规定。
* 模块化程度：代码是否模块化，是否符合面向对象的设计原则，是否使用设计模式等。
* 可测试性：代码是否便于测试，测试用例的覆盖率等。
* 可扩展性：代码是否具备可扩展性，是否考虑到未来发展的需求等。

2. 可读性（Readability）：

* 代码注释率：代码注释是否充分，是否能够让其他开发者容易理解。
* 代码结构清晰度：代码结构是否清晰，逻辑是否简洁。
* 函数/方法的复杂度：函数/方法的实现是否过于复杂。

3. 可扩展性（Extensibility）：

* 模块耦合度：各个模块之间的耦合度是否较低，方便进行功能扩展或修改。
* 预留扩展接口：是否预留了扩展接口，方便进行后续开发。

4. 灵活性（Flexibility）：

* 参数化设计：软件是否支持参数化设计，能否通过配置参数来实现不同的功能。
* 可定制化程度：软件是否支持一定程度的定制化，能否满足不同用户的需求。

5. 简洁性（Simplicity）：

* 代码冗余度：代码是否存在冗余，是否有不必要的复杂度。
* 设计复杂度：软件设计是否过于复杂，是否存在简洁的解决方案。

6. 可复用性（Reusability）：

* 组件化程度：软件是否能够拆分为可重复使用的组件或模块。
* 组件复用率：组件在其他项目中的复用次数和使用范围。

7. 可测试性（Testability）：

* 单元测试覆盖率：单元测试覆盖了多少代码分支和功能。
* 集成测试覆盖率：集成测试覆盖了多少模块之间的交互和功能。
* 自动化测试程度：自动化测试的比例和执行效率。

这些评估指标可以帮助我们衡量软件设计的质量，但具体的评估标准可能需要根据实际情况进行调整和优化。

## 软件设计原则

Software design principles are guidelines that help software engineers create software that is easy to understand, maintain, and modify. Here are some key software design principles:

1. SOLID: SOLID is a set of principles that help to create software that is easy to maintain and extend. The principles are:

- Single Responsibility Principle: A class should have only one responsibility.
- Open/Closed Principle: Software entities should be open for extension but closed for modification.
- Liskov Substitution Principle: Objects of a superclass should be replaceable with objects of a subclass without affecting the correctness of the program.
- Interface Segregation Principle: A client should never be forced to implement an interface that it doesn't use or need.
- Dependency Inversion Principle: High-level modules should not depend on low-level modules. Both should depend on abstractions.

2. DRY (Don't Repeat Yourself): DRY is a principle that encourages software engineers to avoid duplicating code, data, and other elements in their software. This principle helps to reduce code complexity, improve maintainability, and minimize the risk of errors.

3. KISS (Keep It Simple, Stupid): KISS is a principle that encourages software engineers to keep their software simple and straightforward. This principle helps to minimize complexity, improve maintainability, and reduce the risk of errors.

4. YAGNI (You Ain't Gonna Need It): YAGNI is a principle that encourages software engineers to avoid adding unnecessary complexity or features to their software. This principle helps to minimize complexity, reduce development time, and ensure that the software meets its requirements.

5. Composition over Inheritance: This principle encourages software engineers to prefer composition (combining smaller objects) over inheritance (inheriting properties and methods from a parent object). This principle helps to improve flexibility and maintainability, and reduce the risk of errors.

6. Separation of Concerns: This principle encourages software engineers to separate different concerns or responsibilities in their software (e.g., user interface, business logic, data storage). This principle helps to improve maintainability, as changes in one area can be made without affecting others.

By following these and other software design principles, software engineers can create software that is easy to understand, maintain, and modify, and that meets the needs of its users and stakeholders

### SOLID

#### 单一职责原则

单一职责原则：一个接口应该只完成一个功能，这样可以提高代码的模块化。

#### 开放封闭原则

软件实体（类、模块、函数等等）应该可以通过扩展来实现新的功能，而不是修改已有的代码。

#### 里氏替换原则

子类继承父类时，应保持父类的原有功能，提高代码的可重用性和可维护性。

#### 接口隔离原则

接口隔离原则：客户端不应该依赖它不需要的接口，一个类对接口的依赖应该最小化。

#### 依赖倒置原则

核心代码与业务逻辑解耦, 使其不需要频繁变动

在程序代码中，应该依赖于抽象的接口，而不是具体的实现，这样可以降低类与类之间的耦合，提高系统的可扩展性

### 代码复用-DRY

### 简单直接-KISS

### 最小可用-YAGNI (You Ain't Gonna Need It)

### 组合胜过继承-Composition over Inheritance

避免将接口设计得太大, 接口越大越复杂, 应用场景就越小, 

### 关注点分离-Separation of Concerns



### 控制反转-依赖注入

Go语言中, 分为编译时依赖注入和运行时注入

分别参考`github.com/google/wire` 和 `github.com/uber-go/dig`



# 系统架构

## 基础概念

### 系统

实体与关系的集合. 表现与描述 : 功能, 结构 

<u>系统</u>(system)是由一组实体和这些实体之间的关系所构成的集合， 其功能要大于这些实体各自的功能之和。

<u>系统思维</u> (system thinking)， 简单地说， 就是把某个疑间、 某种状况或某个难题明确地视为一个系统， 也就是视为一组相互关联的实体。 系统思维不等于系统化地思考(thinking systematically)。 本章的目标是概括地介绍系统及系统思维。系统思维的运用方式有很多种， 它可以用来理解现有系统的行为及表现， 可以用来预想系统在经过修改之后的状况， 可以用来给具备系统性质的决策或判断提供指导， 也可以用来为系统的设计与拼接（我们称之为系统架构）提供支持。
系统思维与其他一些思维模式并立， 例如批判思维（衡最某个说法的有效性）、 分析思维（根据一套规律或原则进行分析）、 创新思维等。 一位准备工作做得比较充分的思考者， 能够使用各种思维模式来进行思考（这就是认知， cognition)，而且还能够意识到自己当前正在使用的是哪种<u>思维模式</u>（这就是元认知， meta-cognition)。

<u>系统科学</u>

　　系统科学知识体系的结构根据其理论概括程度的高低，可以划分为3个层次：

　　①系统的基础理论。奥地利生物学家贝塔朗菲创立的一般系统论，比利时物理学家和化学家I.普利戈金和布鲁塞尔学派提出的[耗散结构理论](http://wiki.mbalib.com/wiki/耗散结构理论)，德国物理学家H.哈肯倡导的[协同学](http://wiki.mbalib.com/wiki/协同学)，分别从生物学、物理学和化学等不同学科出发，探讨共同的系统理论正在形成系统的基础理论学科——系统学。

　　②系统的技术科学。指运筹学、[系统方法](http://wiki.mbalib.com/wiki/系统方法)和计算科学技术。运筹学包括[数学规划](http://wiki.mbalib.com/wiki/数学规划)、[博弈论](http://wiki.mbalib.com/wiki/博弈论)、[排队论](http://wiki.mbalib.com/wiki/排队论)、[库存论](http://wiki.mbalib.com/wiki/库存论)、[决策理论](http://wiki.mbalib.com/wiki/决策理论)、[搜索论](http://wiki.mbalib.com/wiki/搜索论)和[网络技术](http://wiki.mbalib.com/wiki/网络技术)等。[系统方法](http://wiki.mbalib.com/wiki/系统方法)是合理地研究和处理有关系统的整体联系的一般[科学方法论](http://wiki.mbalib.com/wiki/科学方法论)。系统方法在[唯物辩证法](http://wiki.mbalib.com/wiki/唯物辩证法)的指导下，运用系统理论，为研究和设计各种系统客体提出基本的原则，引导人们有效地解决各种现实课题。现代计算机科学技术主要是电子计算机的应用，这是系统[研究和开发](http://wiki.mbalib.com/wiki/研究和开发)的必要工具，它使复杂系统的大量数据的[定量分析](http://wiki.mbalib.com/wiki/定量分析)得以实现。系统的技术科学这一层次是一个中介环节，它为系统理论运用于系统工程提供了重要的方法和手段，具有应用理论学科的性质。

　　③系统工程技术。指系统工程或系统分析。在国外，广义的系统分析与系统工程并无区别，涵义几乎相同，两种专门名词交互使用。狭义的系统分析则是一种决策方法，用于决策阶段，而系统工程则用于管理活动全过程。在中国统称系统工程。系统工程是[组织管理](http://wiki.mbalib.com/wiki/组织管理)的技术和方法，具有应用学科的性质。

### <u>系统理论</u>（systems theory）

#### 系统理论概述

　　**系统理论**是研究系统的一般模式，结构和规律的学问，它研究各种系统的共同特征，用数学方法定量地描述其功能，寻求并确立适用于一切系统的原理、原则和[数学模型](http://wiki.mbalib.com/wiki/数学模型)，是具有逻辑和数学性质的一门新兴的科学。

#### 系统论的思想及方法

　　**系统论的核心思想**是系统的整体观念。贝塔朗菲强调，任何系统都是一个有机的整体，它不是各个部分的机械组合或简单相加，系统的整体工功能是各要素在孤立状态下所没有的新质。他用[亚里斯多德](http://wiki.mbalib.com/wiki/亚里斯多德)的“整体大于部分之和”的名言来说明系统的整体性，反对那种认为要素性能好，整体性能一定好，以局部说明整体的机械论的观点。同时认为，系统中各要素不是孤立地存在着，每个要素在系统中都处于一定的位置上，起着特定的作用。要素之间相互关联，构成了一个不可分割的整体。要素是整体中的要素，如果将要素从系统整体中割离出来，它将失去要素的作用。正象人手在人体中它是劳动的器官，一旦将手从人体中砍下来，那时它将不再是劳动的器官了一样。

　　**系统论的基本思想方法**，就是把所研究和处理的对象，当作一个系统，分析系统的结构和功能，研究系统、要素、环境三者的相互关系和变动的规律性，并优化系统观点看问题，世界上任何事物都可以看成是一个系统，系统是普遍存在的。大至渺茫的宇宙，小至微观的原子，一粒种子、一群蜜蜂、一台机器、一个工厂、一个学会团体、……都是系统，整个世界就是系统的集合。

#### 系统的分类

　　系统是多种多样的，可以根据不同的原则和情况来划分系统的类型。

- 按人类干预的情况可划分自然系统、人工系统；
- 按学科领域就可分成自然系统、社会系统和思维系统；
- 按范围划妥则有宏观系统、微观系统；
- 按与环境的关系划分就有开放系统、封闭系统、孤立系统；
- 按状态划分就有平衡系统、非平衡系统、近平衡系统、远平衡系统等等。

　　此个还有大系统、小系统的相对区别。

#### 系统论的任务

　　系统论的任务，不仅在于认识系统的特点和规律，更重要地还在于利用这些特点和规律去控制、管理、改造或创造一系统，使它的存在与发展合乎人的目的需要。也就是说，研究系统的目的在于调整系统结构，直辖市各要素关系，使系统达到优化目标。

## 系统架构

<u>向保松</u> 你对系统架构的描述对了一半！<u>架构</u>=实体+实体关系，架构会涌现出功能和性能，也就是架构产生了1+1大于2的效果，多出来的部分就是功能和性能！系统架构分析有逆向和顺序；顺序就是把概念变成架构，书中介绍了一整套可以按部就班，适用于任何场景的标准流程！ <u>功能</u>--->形式的映射是学习已经存在的系统，而设计是形式--->功能的映射;设计过程是先有问题和概念，然后设计实体架构，实体架构会自然涌现功能功能架构，功能架构实现目标；在设计过程中我们需要多次抽象，比如猫--->猫科动物-->动物--->行走的东西，这个过程刚好与编程中的抽象一一对应（系统建模语言借鉴了UML）；模型只是系统设计中的一种工具，辅助系统架构师分析，输出文档，让所有人都能理解系统架构；因为系统架构师把模型都做好了，大家理解起来非常快，就可以直接上手写程序(创建实体)。功能其实也是为 <u>目标</u> 服务的，实体架构又是为功能架构服务器的；只要能实现目标，你可以用不同的功能架构，为了实现功能也可以有多种实体架构。这本书有一个非常创新的概念：实体架构---涌现----功能和性能，系统架构中不仅有功能，还有性能（健壮性、可扩展性、可维护性等），所以把系统架构说成是研究功能比较片面。

### 形式

实体化,序列化(路径化)

*形式: 对实体和关系的描述*

元认知 : 对 一系列的信息 的评估

形式是描述系统的存在性, 具备状态, 对功能的描述, 对实体, 信息, 功能的表征和描述

元认知 : 表征 - 联系 - 描述 - 评估

表征过程 就是概念化的过程, 

形式是系统的物理体现或信息体现, 它存在或有可能于某段时间内稳定而无条件地存在, 且对功能的执行起到工具性(承载, 载体)的作用. 形式包括实体的形式及实体间的形式关系. 形式先于功能的执行而存在. 形式是系统/产品的一项属性(某一维度或层面上的表征). 

*功能依赖于形式, 功能是对逻辑的描述*

形式中含有所有实体的总和, 这些实体是形式的元素或块. 它们是整体中的元素, 它们与形式之间的关系, 是部分与整体的关系. 形式也包括这些形式实体之间的关系, 这些关系通常称为结构. 于是, <u>形式</u> 就等于 <u>形式实体</u> 加上 <u>结构</u>



*结构是对路径(关系)的集合的描述, 是对逻辑的关系的描述, 对实体间的关系的描述*

### 功能

*功能: 一系列的形式的集合*

形式 - 功能  = 实体 - 关系 

形实体 + 功能 = 产品

实现 + 关系 = 系统

### 需求

### 结构

### 状态

### 复杂度

### 决策

### 表征

### 算法

## 需求

> 问题

## 搜索

> 索引 现实层描述

## 认知

## 分析

分层思想 解耦 通过不同的维度 来描述同一个问题

A is B 

A mapping B 

元连接, 复合连接 一切的一切都是对现实的表征才会有意义

### 基本概念

系统需求分析方法由对软件的<u>数据域</u>和<u>功能域</u>的系统分析过程及其表示方法组成。它定义了表示系统<u>逻辑视图</u>和<u>物理视图</u>的方式。

系统分析是一种研究方略，它能在不确定的情况下，确定问题的本质和起因，明确咨询目标，找出各种可行方案，并通过一定标准对这些方案进行比较，帮助决策者在复杂的问题和环境中作出科学抉择。

系统分析方法来源于系统科学。系统科学是20世纪40年代以后迅速发展起来的一个横跨各个学科的新的科学部门，它从系统的着眼点或角度去考察和研究整个客观世界，为人类认识和改造世界提供了科学的理论和方法。它的产生和发展标志着人类的科学思维由主要以“实物为中心”逐渐过渡到以“系统为中心”，是科学思维的一个划时代突破。

系统分析是咨询研究的最基本的方法，我们可以把一个复杂的咨询项目看成为系统工程，通过系统[目标分析](https://baike.baidu.com/item/目标分析)、系统要素分析、系统环境分析、系统资源分析和系统管理分析，可以准确地诊断问题，深刻地揭示问题起因，有效地提出解决方案和满足客户的需求。

### 逻辑层面

逻辑, 数据, 虚拟

分析 数据层面

### 物理层面

功能, 物理, 业务, 现实

分析 功能层面 

### 模型层面

**表征 : 建立联系 逻辑到物理的映射**

模型, 模拟

模型层 是 虚拟到现实的 一一对应 虚拟到现实的准确连接, 映射

然后 确保 数据层面 和 功能层面 一对一 实现对现实的模拟 准确的表达

## 设计

> 模型 建立模型 但是一般都只能根据模型思维建立模型

## 实现



# 软件架构与设计模式

服务器

<极客时间>



# 云原生(Cloud Native)

> 参考链接
>
> - [](https://www.cncf.io/about/who-we-are/)

<!-- TODO -->

## Introduction

> Cloud native technologies empower organizations to build and run scalable applications in modern, dynamic environments such as public, private, and hybrid clouds. Containers, service meshes, microservices, immutable infrastructure, and declarative APIs exemplify this approach.
>
> These techniques enable loosely coupled systems that are resilient, manageable, and observable. Combined with robust automation, they allow engineers to make high-impact changes frequently and predictably with minimal toil.
>
> The Cloud Native Computing Foundation seeks to drive adoption of this paradigm by fostering and sustaining an ecosystem of open source, vendor-neutral projects. We democratize state-of-the-art patterns to make these innovations accessible for everyone.

云原生技术有利于各组织在公有云、私有云和混合云等新型动态环境中，构建和运行可弹性扩展的应用。云原生的代表技术包括容器、服务网格、微服务、不可变基础设施和声明式API。

这些技术能够构建容错性好、易于管理和便于观察的松耦合系统。结合可靠的自动化手段，云原生技术使工程师能够轻松地对系统作出频繁和可预测的重大变更。

云原生计算基金会（CNCF）致力于培育和维护一个厂商中立的开源生态系统，来推广云原生技术。我们通过将最前沿的模式民主化，让这些创新为大众所用。

>  declarative APIs即声明式API (与之相对的是命令式APIs(imperative APIs)), 声明是注重状态描述, 命令式注重过程描述. 
>
>  声明式就是属性化, 通过声明来蕴含执行某些操作或方法. 声明式是一种以数据为中心的思维方式, 强调行为结果, 而不是行为过程. 因为结果蕴含了行为过程. 
>
>  也就是说, 接口是一个名词或形容词, 而不是一个动词.
>
>  go help doc, git clone url 是一种命令式语句. 要将命令属性化, 只需要描述命令的结果即可, 即将命令蕴含在结果中. 声明式API更关注行为结果. 以数据为中心

# Microservice-微服务架构

<!--TODO-->

> 相关概念: 云原生(Cloud Native)
>
> 参考链接
>
> - https://microservices.io/patterns/cn/microservices.html
> - https://microservices.io/patterns/
> - 

## 零散记录

[服务治理策略](https://mp.weixin.qq.com/s?__biz=MzUzMTUxMzYyNQ==&mid=2247485561&idx=1&sn=e477f571b992a6787fc7ea1674aafcc2&chksm=fa40200fcd37a9197f595ff91e8ecb379eb2fa8861786d2aba02fc77c34ea68c183d1187b581&token=1417600517&lang=zh_CN&scene=21#wechat_redirect)

### 文章

微服务最佳实践

A picture is worth a thousand words: 9 best practices for developing microservices. When we develop microservices, we need to follow the following best practices: 

1. Use separate data storage for each microservice 
    分离每个微服务的数据存储

2. Keep code at a similar level of maturity 

    保持代码在相似的成熟度水平

3. Separate build for each microservice 
    分离构建每个微服务

4. Assign each microservice with a single responsibility
    为每个微服务指定单一响应

5. Deploy into containers
    部署到容器中

6. Design stateless services
    设计无状态服务

7. Adopt domain-driven design
    采取领域驱动设计 

8. Design micro frontend
    设计微前端 

9. Orchestrating microservices
    编排微服务





![img](https://wwfyde.oss-cn-hangzhou.aliyuncs.com/images/202307081544764.jpeg)



## 服务网格(Service Mesh)



# **数据密集型应用系统设计**

> Title: Designing Data-Intensive Applications
>
> Author: Martin kleppmann



## 1. 可靠、可扩展与可维护的应用系统

> reliable, scalable, maintainable applications

数据库: 用以存储数据, 这样之后应用可以再次访问. 

高速缓存: 缓存哪些复杂或操作昂贵的结果, 以加快下一次访问.

索引: 用户可以按关键字搜索数据并支持各种过滤

流式处理: 持续发送消息至另一个进程, 处理采用异步方式.

批处理: 定期处理大量的累积数据. 

![a-system-archtecture](https://wwfyde.oss-cn-hangzhou.aliyuncs.com/images/202308111112842.png)

### 认识数据系统

我们通常将数据库、队列、高速缓存等视为不同类型的系统. 虽然数据库和消息队列存在某些相似性, 例如二者都会保存数据(至少一段时间), 但他们却有着截然不同的访问模式, 这就意味着不同的性能特征和设计实现.

We Often treat database, Queue, cache as different system of types. while there are similar features between database and message queue, such as both of them will storing data, but they having different way to access, which means different performance features and implements.

We Typically think of database, queues, caches, etc. as being very different categories of tools.

那么为什么本书将它们归为一大类即"数据系统"(data system)呢?

越来越多的应用需求广泛, 单个组件往往无法满足所有数据处理与存储需求. 因而需要将任务分解, 每个组件负责高效完成其中一部分, 多个组件依靠应用程代码驱动有机衔接起来.



## 2. 数据模型与查询语言

> 语言的边界就是世界的边界





# 分布式系统



# **分布式**

### 总结

分布式场景的三大算法: 集中式算法(协调者broker), 分布式算法(同意), 循环令牌算法(回路循环)

## 基本定义



## 分布式平台

> 百度网盘, 大咖说技术公开课, 分布式平台内核揭秘.avi

分布式是一种应用框架,一种设计模式: 针对这种模式衍生出多种技术支撑, 路由, 负载均衡, 任务调度, 资源竞争, 平衡计算, 线程间,进程间网络通讯等等. 

RASP需求 

 



## 00开篇词 | 四纵四横，带你透彻理解分布式技术

在众多计算机技术当中，分布式技术无疑是最璀璨的明珠之一。毫不夸张地说，没有分布式技术就没有互联网，也就没有现在的阿里巴巴、腾讯、亚马逊、Facebook、谷歌等科技巨头，更不会有以信息技术为核心的、对人类历史产生巨大变革的第三次工业革命。万维网、Email、DNS 等，都是分布式系统的典型代表。

随着分布式技术的不断发展，它也早已不再局限于传统的互联网等应用场景。在今年的两会期间，全国政协委员、360 董事长周鸿祎更是大唱 I’M ABCDE 字母歌。**IMABCDE 这 7 个字母所代表的 IoT 物联网、Mobile 移动计算、AI 人工智能、Blockchain 区块链、Cloud 云计算、Data 大数据、Edge 边缘计算，也无不都是以分布式技术为基石。**

无疑，**谁更好地掌握了分布式技术，谁就更容易在新一轮技术浪潮中获得主动。**在全球经济增速趋缓的大背景下，与许多应用业务大量裁人形成鲜明对比的是，各大巨头的中间件团队、实验室等基础部门，依然在大规模地招兵买马。随着业务扩展，以及 IMABCDE 等新兴技术领域的布局，分布式技术人才已然成为巨头们争夺的焦点。

**一方面是各大厂商的求贤若渴，一方面是分布式专业技术人才的一将难求。**在多年的面试中，我经常能体会到，有些面试者确实非常积极主动，但他们表现出来的水平却无法通过面试。分布式技术人才市场的供应与需求，俨然一首冰与火之歌。

2007 年，我在西安电子科技大学攻读博士期间，就开始研究并行与分布式计算；毕业后，在 IBM 做过 HPC 大规模负载管理系统 LSF 相关的设计和研发工作，在华为负责过分布式 IoT 相关项目的架构设计，以及电信级业务微服务框架、函数服务框架的设计工作，也从事过区块链相关的研究工作。现在，我在智载云帆负责技术体系的构建，专注于无服务器 Serverless 的架构实践。

从我深入研究分布式技术这十多年的经验来看，分布式技术概念繁多、知识庞杂、新兴技术层出不穷，令许多新手望而却步，而许多有一定年限工作经验的老手，虽然也能对一些概念滔滔不绝，但追问到实质性问题就变得磕磕巴巴，顾左右而言它。比如：

- 各种分布式概念、名词学了一大堆，但经常张冠李戴，傻傻分不清楚；
- 做了多年技术，也参与了很多分布式技术实践，却无法回答工作中各种分布式技术、组件、框架选型背后的根源；
- 在一个分布式技术配套的典型场景往往能驾轻就熟，但一旦稍微变更考察业务场景、业务目标后，就变得毫无头绪。

究其原因，主要是**知识碎片化、不成体系、见树不见林。**如果再追究更深层次的原因，那无外乎就是两点：

- **在计算机学科课程设置中，分布式技术尴尬如同中小学中的性教育，重要但不受重视。**鲜有高校在计算机本科专业中设置分布式课程，即便是有些高校在研究生教育中设置了相关课程，也是如同高手过招点到为止。
- **信息碎片化与信息孤立。**在信息泛滥的信息时代，各种经典教材、最新文章自然是唾手可得。但，教材固然经典但严谨有余浅出不够，最重要的是没有与时下最新的场景相结合，一方面是因为教材“年久失修”，另一方面确实是因为分布式领域新技术推出的速度令人叹为观止；而网上的各种技术文章虽然多，却鲜有体系化的说明，一个个概念如同一座座信息孤岛。**如果不能体系化地理解这些概念，何谈掌握，更谈不上真正地去综合运用这些知识了。**

因为工作太忙，这些年我整体而系统的输出比较少。偶然一次听到任正非的讲话，他提到了基础教育、孩子是一个社会的未来，这让我感触良多。我想，如果说一个社会的未来，离不开朝气蓬勃的孩子们，那么**一个行业的兴盛，同样也离不开一个广泛的从业者基础。**而我如果能做好分布式通识课这样的一个专栏，既可以对自己这些年的经验做一次系统梳理，温故而知新，又能帮助更多的人系统理解并掌握分布式核心技术，为整个行业的兴盛略尽绵薄之力，何乐而不为呢？

其实，在工作、面试、演讲等多种场合，也经常会有人问我：“聂博士，分布式领域的新概念繁多、各种框架五花八门、各种组件层出不穷，应该如何应对啊？”我回答说：“其实你已经有答案了。”

看着他们满脸疑惑，我笑着问：“RISC 芯片，程序设计中的封装、继承，还有现在提倡的中台战略，它们都在做一件什么事情呢？”他们答道：“莫非是重用？”

我说：“是的，**既然指令可以重用，代码可以重用，技术、业务、数据等都可以重用，为什么知识体系不可以呢？学好分布式通识课，掌握了分布式的核心技术、体系，你就会发现很多新技术、新框架、新组件只不过是‘新瓶装旧酒’，将分布式核心技术进行了再包装、再组合，至多也就是做了一点延伸而已。”**

那么，分布式通识课究竟该如何学呢？在接下来的三个月时间里，我会遵循以下 4 个思路带着你一起学习。

第一，分布式技术错综复杂，各种技术相互耦合，确实无法简单地像网络等技术一样划分层次，所以我会结合自己多年的积累和思考，首先为你梳理出一个脉络清晰、**四纵四横**的分布式核心技术知识体系，然后从这个纵横的技术体系中抽取最核心、最普适的技术思想以及概念，结合各种适用场景一一解析。这样的设计，旨在帮助你找到核心知识点，并将这些知识点联系起来，快速形成分布式核心技术的知识网络，从而形成自己的技术判断力，进而规划出自己的技术路线。

第二，从一个熟知的事物出发，进行浅出的讲解，帮助你从已有知识体系扩展到新的知识体系，从而迅速、牢固地掌握分布式技术的核心知识点。

第三，透过表象深入讲解技术本质，而不是 case by case 地讲解，帮助你知其然并知其所以然，真正做到理解与运用时的举一反三。

第四，针对同一分布式问题的不同方法，从多维度、多角度进行对比、分析，方便你在工作中灵活选型，避免重复“造轮子”。你甚至可以综合权衡各种方法的优缺点，提炼发明出新的方法，最终做到活学活用。

讲到这里，你是不是也有点摩拳擦掌、跃跃欲试了呢？“分布式世界这么大，我要去看看！”别慌，请先看完这份技术地图。

![](https://wwfyde.oss-cn-hangzhou.aliyuncs.com/images/202305101710374.jpg)

首先，按照业务的架构层次栈，我自底向上按照资源、通信、数据与计算的维度，梳理出了 4 个技术层次：分布式资源池化、分布式通信、分布式数据存储与管理、分布式计算。这样的划分符合业务架构设计的一般规律，即**“在一定资源上，进行一定通信，通过一定计算，完成一定数据的加工和处理，从而对外提供特定的服务”。**另一方面，这样的划分也整合了零散的知识点，具有完备性。

既然横向的 4 个层次都已经完备了，那为什么又多出了 4 个纵向的技术呢？如果我们把横向的 4 个层次比作派生类的话，那么纵向的 4 条技术线应该是它们的基类。因为，在分布式环境下，无论是资源、通信、数据还是计算，都需要去解决协同、调度、追踪高可用，还有部署的问题。因此，我从横向的技术层次中，提炼出分布式协同、分布式调度、分布式追踪与高可用、分布式部署 4 个纵向技术线。由于分布式追踪、分布式部署虽属于支撑技术，但并不会影响业务的构成，因此我不会在本专栏中进行讲解。

最后，如果说现在分布式领域里各种包装出来的、五花八门的新技术，像是令人高不可攀的女神、男神的话，那么这个分布式通识课程中所提炼出来的体系和核心知识点无疑就是女神、男神素颜的样子。我想说，等你**看尽素颜，无论是女神、男神也好，还是各种高大上的技术也好，也就不会觉得那么高不可攀了。**

既然你已经看到了这里，相信你也看到了学习分布式技术知识的迫切需求，那么不妨请你在留言区做个自我介绍，给我说说你的困惑，也说说你想通过这个专栏收获些什么，这样我后续也可以根据你的情况进行有针对性的讲解。

我是聂鹏程，今天的内容就到这里了，我们下一讲再会。

## 01 | 分布式缘何而起：从单兵，到游击队，到集团军

你好，我是聂鹏程。这是专栏的第一篇文章，我们先来聊聊什么是分布式。

与其直接用些抽象、晦涩的技术名词去给分布式下一个定义，还不如从理解分布式的发展驱动因素开始，我们一起去探寻它的本质，自然而然地也就清楚它的定义了。

在今天这篇文章中，我将带你了解分布式的起源，是如何从单台计算机发展到分布式的，进而帮助你深入理解什么是分布式。为了方便你更好地理解这个演进过程，我将不考虑多核、多处理器的情况，假定每台计算机都是单核、单处理器的。

### 分布式起源

### 单兵模式：单机模式

1946 年情人节发布的 ENIAC 是世界上的第一台通用计算机，它占地 170 平米重达 30 吨，每秒可进行 5000 次加法或者 400 次乘法运算，标志着单机模式的开始。

所谓**单机模式**是指，所有应用程序和数据均部署在一台电脑或服务器上，由一台计算机完成所有的处理。

以铁路售票系统为例，铁路售票系统包括用户管理、火车票管理和订单管理等模块，数据包括用户数据、火车票数据和订单数据等，如果使用单机模式，那么所有的模块和数据均会部署在同一台计算机上，也就是说数据存储、请求处理均由该计算机完成。这种模式的好处是功能、代码和数据集中，便于维护、管理和执行。

单机模式的示意图，如下所示：

![](https://wwfyde.oss-cn-hangzhou.aliyuncs.com/images/202305101710342.jpg)

这里需要注意的是，**本文的所有示意图中，紫色虚线表示在一台计算机内。**

事物均有两面性，我们再来看看单机模式的缺点。单个计算机的处理能力取决于 CPU 和内存等，但硬件的发展速度和性能是有限的，而且升级硬件的性价比也是我们要考虑的，由此决定了 CPU 和内存等硬件的性能将成为单机模式的瓶颈。

你有没有发现，单机模式和单兵作战模式非常相似，单台计算机能力再强，就好比特种兵以一敌百，但终归能力有限。此外，将所有任务都交给一台计算机，也会存在将所有鸡蛋放到一个篮子里的风险，也就是单点失效问题。

归纳一下，单机模式的主要问题是：**性能受限、存在单点失效问题。**

### 游击队模式：数据并行或数据分布式

既然单机模式存在性能和可用性的问题。那么，有没有什么更好的计算模式呢？答案是肯定的。

为解决单机模式的问题，并行计算得到了发展，进而出现了数据并行（也叫作数据分布式）模式。**并行计算**采用消息共享模式使用多台计算机并行运行或执行多项任务，核心原理是每台计算机上执行相同的程序，将数据进行拆分放到不同的计算机上进行计算。

请注意，并行计算强调的是对数据进行拆分，任务程序在每台机器上运行。要达到这个目的，我们必须首先把单机模式中的应用和数据分离，才可能实现对数据的拆分。这里的应用就是执行任务的程序，任务就是提交的请求。以铁路售票系统为例，运行在服务器上的用户管理、火车票管理和订单管理等程序就是应用，用户提交的查询火车票、购买火车票的请求就是任务。

在单机模式中，应用和数据均在一台计算机或服务器上，要实现数据的并行，首先必须将应用和数据分离以便将应用部署到不同的计算机或服务器上；然后，对同类型的数据进行拆分，比方说，不同计算机或服务器上的应用可以到不同的数据库上获取数据执行任务。

以铁路售票系统的数据并行为例，主要包括两个步骤，如下所示：

**第一步**，将应用与数据分离，分别部署到不同的服务器上：

![](https://wwfyde.oss-cn-hangzhou.aliyuncs.com/images/202305101710431.jpg)

**第二步**，对数据进行拆分，比如把同一类型的数据拆分到两个甚至更多的数据库中，这样应用服务器上的任务就可以针对不同数据并行执行了。

对于铁路售票系统来说，根据线路将用户、火车票和订单数据拆分到不同的数据库中，部署到不同的服务器上，比如京藏线的数据放在数据库服务器 1 上的数据库中，沪深线的数据放在数据库服务器 2 上的数据库中。



![](https://wwfyde.oss-cn-hangzhou.aliyuncs.com/images/202305101710474.jpg)

需要注意的是，为了更好地帮助你理解这个数据拆分的过程，我在这里选择拆分数据库的方式进行讲解。由于数据库服务器本身的并发特性，因此你也可以根据你的业务情况进行选择，比方说所有业务服务器共用一个数据库服务器，而不一定真的需要去进行数据库拆分。

可以看出，在数据并行或数据分布式模式中，每台计算机都是全量地从头到尾一条龙地执行一个程序，就像一个全能的铁道游击队战士。所以，你也可以将这种模式形象地理解成游击队模式，就和铁道游击队插曲的歌词有点类似：“我们扒飞车那个搞机枪，撞火车那个炸桥梁……”

这种模式的好处是，可以利用多台计算机并行处理多个请求，使得我们可以在相同的时间内完成更多的请求处理，解决了单机模式的计算效率瓶颈问题。但这种模式仍然存在如下几个问题，在实际应用中，我们需要对其进行相应的优化：

- 相同的应用部署到不同的服务器上，当大量用户请求过来时，如何能比较均衡地转发到不同的应用服务器上呢？解决这个问题的方法是设计一个负载均衡器，我会在”分布式高可靠“模块与你讲述负载均衡的相关原理。
- 当请求量较大时，对数据库的频繁读写操作，使得数据库的 IO 访问成为瓶颈。解决这个问题的方式是读写分离，读数据库只接收读请求，写数据库只接收写请求，当然读写数据库之间要进行数据同步，以保证数据一致性。
- 当有些数据成为热点数据时，会导致数据库访问频繁，压力增大。解决这个问题的方法是引入缓存机制，将热点数据加载到缓存中，一方面可以减轻数据库的压力，另一方面也可以提升查询效率。

从上面介绍可以看出，数据并行模式实现了多请求并行处理，但如果单个请求特别复杂，比方说需要几天甚至一周时间的时候，数据并行模式的整体计算效率还是不够高。

由此可见，数据并行模式的主要问题是：**对提升单个任务的执行性能及降低时延无效。**

#### 集团军模式：任务并行或任务分布式

那么，有没有办法可以提高单个任务的执行性能，或者缩短单个任务的执行时间呢？答案是肯定的。任务并行（也叫作任务分布式）就是为解决这个问题而生的。那什么是任务并行呢？

任务并行指的是，将单个复杂的任务拆分为多个子任务，从而使得多个子任务可以在不同的计算机上并行执行。

我们仍以铁路售票系统为例，任务并行首先是对应用进行拆分，比如按照领域模型将用户管理、火车票管理、订单管理拆分成多个子系统分别运行在不同的计算机或服务器上。换句话说，原本包括用户管理、火车票管理和订单管理的一个复杂任务，被拆分成了多个子任务在不同计算机或服务器上执行，如下图所示：

![](https://wwfyde.oss-cn-hangzhou.aliyuncs.com/images/202305101710546.jpg)

可以看出，任务并行模式完成一项复杂任务主要有两个核心步骤：首先将单任务拆分成多个子任务，然后让多个子任务并行执行。这种模式和集团军模式很像，任务拆分者对应领导者，不同子系统对应不同兵种，不同子程序执行不同任务就像不同的兵种执行不同的命令一样，并且运行相同子系统或子任务的计算机又可以组成一个兵团。

在集团军模式中，由于多个子任务可以在多台计算机上运行，因此通过将同一任务待处理的数据分散到多个计算机上，在这些计算机上同时进行处理，就可以加快任务执行的速度。因为，只要一个复杂任务拆分出的任意子任务执行时间变短了，那么这个任务的整体执行时间就变短了。

当然，nothing is perfect。**集团军模式在提供了更好的性能、扩展性、可维护性的同时，也带来了设计上的复杂性问题**，毕竟对一个大型业务的拆分也是一个难题。不过，对于大型业务来讲，从长远收益来看，这个短期的设计阵痛是值得的。这也是许多大型互联网公司、高性能计算机构等竞相对业务进行拆分以及重构的一个重要原因。

### 分布式是什么？

讲了半天，那到底什么是分布式呢？

**总结一下，分布式其实就是将相同或相关的程序运行在多台计算机上，从而实现特定目标的一种计算方式。**

从这个定义来看，数据并行、任务并行其实都可以算作是分布式的一种形态。从这些计算方式的演变中不难看出，**产生分布式的最主要驱动力量，是我们对于性能、可用性及可扩展性的不懈追求。**

### 总结

在今天这篇文章中，我和你分享了分布式的起源，即从单机模式到数据并行（也叫作数据分布式）模式，再到任务并行（也叫作任务分布式）模式。

单机模式指的是，所有业务和数据均部署到同一台机器上。这种模式的好处是功能、代码和数据集中，便于维护、管理和执行，但计算效率是瓶颈。也就是说单机模式性能受限，也存在单点失效的问题。

数据并行（也叫作数据分布式）模式指的是，对数据进行拆分，利用多台计算机并行执行多个相同任务，通过在相同的时间内完成多个相同任务，从而缩短所有任务的总体执行时间，但对提升单个任务的执行性能及降低时延无效。

任务并行（也叫作任务分布式）模式指的是，单任务拆分成多个子任务，多个子任务并行执行，只要一个复杂任务中的任意子任务的执行时间变短了，那么这个业务的整体执行时间也就变短了。该模式在提高性能、扩展性、可维护性等的同时，也带来了设计上的复杂性问题，比如复杂任务的拆分。

在数据并行和任务并行这两个模式的使用上，用户通常会比较疑惑，到底是采用数据并行还是任务并行呢？一个简单的原则就是：任务执行时间短，数据规模大、类型相同且无依赖，则可采用数据并行；如果任务复杂、执行时间长，且任务可拆分为多个子任务，则考虑任务并行。在实际业务中，通常是这两种模式并用。赶紧行动起来，去分析一下你的业务到底应该采用哪种分布式模式吧，加油！

## 02 | 分布式系统的指标：啥是分布式的三围

你好，我是聂鹏程。

在上一篇文章中，通过对分布式发展历程的学习，我们对分布式技术有了一个整体印象。接下来，我们就再来看看可以用哪些指标去具体地衡量一个分布式系统。如果你已经对分布式系统的指标了解得很清楚了，可以直接跳过这篇文章，学习下一讲的内容。

### 分布式系统的指标

从分布式技术的起源可以看出，分布式系统的出现就是为了用廉价的、普通的机器解决单个计算机处理复杂、大规模数据和任务时存在的性能问题、资源瓶颈问题，以及可用性和可扩展性问题。换句话说，分布式的目的是**用更多的机器，处理更多的数据和更复杂的任务。**

由此可以看出，**性能、资源、可用性和可扩展性**是分布式系统的重要指标。没错，它们就是分布式系统的“三围”。接下来，我们一起来看看这几个指标吧。

### 性能（Performance）

性能指标，主要用于衡量一个系统处理各种任务的能力。无论是分布式系统还是单机系统，都会对性能有所要求。

不同的系统、服务要达成的目的不同，关注的性能自然也不尽相同，甚至是相互矛盾。常见的性能指标，包括吞吐量（Throughput）、响应时间（Response Time）和完成时间（Turnaround Time）。

**吞吐量**指的是，系统在一定时间内可以处理的任务数。这个指标可以非常直接地体现一个系统的性能，就好比在客户非常多的情况下，要评判一个银行柜台职员的办事效率，你可以统计一下他在 1 个小时内接待了多少客户。常见的吞吐量指标有 QPS（Queries Per Second）、TPS（Transactions Per Second）和 BPS（Bits Per Second）。

- QPS，即查询数每秒，用于衡量一个系统每秒处理的查询数。这个指标通常用于读操作，越高说明对读操作的支持越好。所以，我们在设计一个分布式系统的时候，如果应用主要是读操作，那么需要重点考虑如何提高 QPS，来支持高频的读操作。
- TPS，即事务数每秒，用于衡量一个系统每秒处理的事务数。这个指标通常对应于写操作，越高说明对写操作的支持越好。我们在设计一个分布式系统的时候，如果应用主要是写操作，那么需要重点考虑如何提高 TPS，来支持高频写操作。
- BPS，即比特数每秒，用于衡量一个系统每秒处理的数据量。对于一些网络系统、数据管理系统，我们不能简单地按照请求数或事务数来衡量其性能。因为请求与请求、事务与事务之间也存在着很大的差异，比方说，有的事务大需要写入更多的数据。那么在这种情况下，BPS 更能客观地反应系统的吞吐量。

**响应时间**指的是，系统响应一个请求或输入需要花费的时间。响应时间直接影响到用户体验，对于时延敏感的业务非常重要。比如用户搜索导航，特别是用户边开车边搜索的时候，如果响应时间很长，就会直接导致用户走错路。

**完成时间**指的是，系统真正完成一个请求或处理需要花费的时间。任务并行（也叫作任务分布式）模式出现的其中一个目的，就是缩短整个任务的完成时间。特别是需要计算海量数据或处理大规模任务时，用户对完成时间的感受非常明显。

### 资源占用（Resource Usage）

资源占用指的是，一个系统提供正常能力需要占用的硬件资源，比如 CPU、内存、硬盘等。

一个系统在没有任何负载时的资源占用，叫做**空载资源占用**，体现了这个系统自身的资源占用情况。比如，你在手机上安装一个 App，安装的时候通常会提示你有多少 KB，这就是该 App 的空载硬盘资源占用。对于同样的功能，空载资源占用越少，说明系统设计越优秀，越容易被用户接受。

一个系统满额负载时的资源占用，叫做**满载资源占用**，体现了这个系统全力运行时占用资源的情况，也体现了系统的处理能力。同样的硬件配置上，运行的业务越多，资源占用越少，说明这个系统设计得越好。

### 可用性（Availability）

可用性，通常指的是系统在面对各种异常时可以正确提供服务的能力。可用性是分布式系统的一项重要指标，衡量了系统的鲁棒性，是系统容错能力的体现。

系统的可用性可以用**系统停止服务的时间与总的时间之比衡量。**假设一个网站总的运行时间是 24 小时，在 24 小时内，如果网站故障导致不可用的时间是 4 个小时，那么系统的可用性就是 4/24=0.167，也就是 0.167 的比例不可用，或者说 0.833 的比例可用。

除此之外，系统的可用性还可以用**某功能的失败次数与总的请求次数之比来衡量**，比如对网站请求 1000 次，其中有 10 次请求失败，那么可用性就是 99%。

你可能经常在一个系统的宣传语中见到或听到 3 个 9（或 3N，3 Nines）、5 个 9（或 9N，9 Nines）。这些宣传语中所说的 3 个 9、5 个 9，实际上就是系统厂商对可用性的一种标榜，表明该系统可以在 99.9% 或 99.999% 的时间里能对外无故障地提供服务。

讲到了可用性，你可能还会想到一个非常近似的术语：可靠性（Reliability）。那**可靠性和可用性有什么区别呢？**

**可靠性**通常用来表示一个系统完全不出故障的概率，更多地用在硬件领域。而**可用性**则更多的是指在允许部分组件失效的情况下，一个系统对外仍能正常提供服务的概率。

杰夫 · 迪恩（Jeff Dean）曾在 Google I/O 大会上透露：谷歌一个基于 1000 台通用计算机的集群，一年之内就有 1000+ 硬盘会出现故障。由于现在比较常见的分布式系统基本上都是基于通用计算机的，这就意味着在这些系统中无法实现真正的可靠，所以我们也会在一些场合见到可靠性和可用性交换使用的情况。

### 可扩展性（Scalability）

可扩展性，指的是分布式系统通过扩展集群机器规模提高系统性能 (吞吐、响应时间、 完成时间)、存储容量、计算能力的特性，是分布式系统的特有性质。  



分布式系统的设计初衷，就是利用集群多机的能力处理单机无法解决的问题。然而，完成某一具体任务所需要的机器数目，即集群规模，取决于单个机器的性能和任务的要求。

**当任务的需求随着具体业务不断提高时，除了升级系统的性能做垂直 / 纵向扩展外，另一个做法就是通过增加机器的方式去水平 / 横向扩展系统规模。**

这里垂直 / 纵向扩展指的是，增加单机的硬件能力，比如 CPU 增强、内存增大等；水平 / 横向扩展指的就是，增加计算机数量。好的分布式系统总在追求“线性扩展性”，也就是说系统的某一指标可以随着集群中的机器数量呈线性增长。

衡量系统可扩展性的常见指标是加速比（Speedup），也就是一个系统进行扩展后相对扩展前的性能提升。

- 如果你的扩展目标是为了提高系统吞吐量，则可以用扩展后和扩展前的系统吞吐量之比进行衡量。
- 如果你的目标是为了缩短完成时间，则可以用扩展前和扩展后的完成时间之比进行衡量。

### 不同场景下分布式系统的指标

我们都希望自己的分布式系统是高性能、高可用、高扩展和低资源占用的。但出于硬件成本、开发效率等因素的约束，我们无法在性能、可用性、可靠性和资源占用做到面面俱到。因此，在不同的业务场景中，设计者们需要有所取舍。

接下来，我带你一起看一下典型的电商、IoT、电信、HPC（高性能计算）、大数据、云计算、区块链等业务或系统对不同指标的诉求。

- **电商系统。**对于一个电商系统而言，系统设计者最看重的是吞吐量，为了处理更多的用户访问或订单业务，甚至不惜牺牲一些硬件成本。
- **IoT。**对于一个 IoT 系统而言，设计者最看重的是资源占用指标，因为在一些功能极简的 IoT 设备上 RAM、ROM 的可用资源通常都是 KB 级的。
- **电信业务。**对于电信业务而言，最重要的无疑是响应时间、完成时间，以及可用性。因为，你在打电话时不希望你的声音半天才被对方听到，也不希望半天才听到对方的回应，更不希望你的电话无法拨出。
- **HPC。**HPC 系统最显著的特点是任务执行时间极长，一个天体物理任务的分析和计算通常耗时数周甚至数月。因此，通过水平扩展来提高系统的加速比，是 HPC 系统设计者需要关注的。
- **大数据。**大数据任务的处理时间可能相对 HPC 系统来讲比较短，但常见的完成时间也达到了小时级，所以扩展性也是大数据系统首先要考虑的。
- **云计算。**对于一个云计算系统而言，常见任务是虚拟主机或容器的创建、资源调整、销毁等操作，如何减少这些操作的完成时间，从而提升用户体验是设计者们要重点关注的。另外，云计算系统本质上卖的是资源，那么降低系统本身的资源开销，也是系统设计的重中之重。
- **区块链。**区块链的吞吐量比较低，比特币的 TPS 只有 7 次每秒，单平均一次交易的确认就需要 10 分钟左右，因此吞吐量和完成时间通常是区块链系统设计者的首要目标。

![](https://wwfyde.oss-cn-hangzhou.aliyuncs.com/images/202305101710628.jpg)

### 总结与思考

按照不同维度，分布式系统的指标可以分为性能、资源占用、可用性、可扩展性这四大类。我们自然希望自己的系统，是高性能、高可用、高扩展和低资源占用的，但考虑到硬件成本、开发效率等因素，必须要在设计不同的系统、业务时有所取舍。

所以，我又和你分析了典型的电商、IoT、电信、HPC（高性能计算）、大数据、云计算、区块链等业务或系统的不同诉求，进而得出了系统设计者需要关注哪些指标。你在设计其他类型的系统时，可以按照这个思路进行取舍。

我在文中提到了，分布式系统的指标之间会存在一些冲突或约束。那你不妨思考一下：我们今天讲解的指标中，哪些指标之间是相互制约、相互冲突的，它们又是如何制约的呢？

我是聂鹏程，感谢你的收听，欢迎你在评论区给我留言分享你的观点，也欢迎你把这篇文章分享给更多的朋友一起阅读。我们下期再会！

## 03 | 分布式互斥：有你没我，有我没你

通过前面的两篇文章，相信你已经对此次的分布式世界之行有了一个初步了解，想必对此次旅行也是充满期待。今天，我就带你正式踏上第一站：分布式协调与同步。在这一站，我将带你学习如何让分布在不同计算机上的程序具有“团队精神”，换句话说就是如何让程序通过协作共同去达成一个业务目标。

在本站，我将带你打卡的第一个景点是分布式互斥。那，什么是分布式互斥呢？

### 什么是分布式互斥？

想象一下，你正在一家餐厅使用自助咖啡机泡制咖啡，突然有个人过来挪走了你的杯子，开始泡制他自己的咖啡。你耐着性子等他操作完，继续泡制自己的咖啡。结果你开始没多久，他又回来中断了你泡制咖啡的过程。相信要不了几个回合，你和他就会上演一场“有你没我，有我没你”的格斗了。

这样现实的问题也同样存在于分布式世界。就像我们使用自助咖啡机时不希望被打扰一样，对于同一共享资源，一个程序正在使用的时候也不希望被其他程序打扰。这，就要求同一时刻只能有一个程序能够访问这种资源。

### 分布式锁

在分布式系统里，这种排他性的资源访问方式，叫作**分布式互斥**（Distributed Mutual Exclusion），而这种被互斥访问的共享资源就叫作**临界资源**（Critical Resource）。

接下来，我带你一起看看如何才能让分布式系统里的程序互斥地访问临界资源。

### 霸道总裁: 集中式算法

> 互斥算法，就是我们所说的**集中式算法**，也可以叫做中央服务器算法。
>
> 协调者

对于前面提到的咖啡机问题，我们首先想到的就是，增加一个“协调者”来约束大家使用自助咖啡机，解决强行插入打断别人的问题。

类似地，我们引入一个协调者程序，得到一个分布式互斥算法。每个程序在需要访问临界资源时，先给协调者发送一个请求。如果当前没有程序使用这个资源，协调者直接授权请求程序访问；否则，按照先来后到的顺序为请求程序“排一个号”。如果有程序使用完资源，则通知协调者，协调者从“排号”的队列里取出排在最前面的请求，并给它发送授权消息。拿到授权消息的程序，可以直接去访问临界资源。

这个互斥算法，就是我们所说的**集中式算法**，也可以叫做中央服务器算法。之所以这么称呼，是因为协调者代表着集中程序或中央服务器。

集中式算法的示意图如下所示:

![](https://wwfyde.oss-cn-hangzhou.aliyuncs.com/images/202305101710590.jpg)

如图所示，程序 1、2、3、4 为普通运行程序，另一个程序为协调者。当程序 2 和程序 4 需要使用临界资源时，它们会向协调者发起申请，请求协调者授权。

不巧的是，程序 3 正在使用临界资源。这时，协调者根据程序 2 和 4 的申请时间顺序，依次将它们放入等待队列。在这个案例里，程序 4 的申请时间早于程序 2，因此排在程序 2 的前面。

程序 3 使用完临界资源后，通知协调者释放授权。此时，协调者从等待队列中取出程序 4，并给它发放授权。这时，程序 4 就可以使用临界资源了。

从上述流程可以看出，**一个程序完成一次临界资源访问，需要如下几个流程和消息交互**：

1. 向协调者发送请求授权信息，1 次消息交互；
2. 协调者向程序发放授权信息，1 次消息交互；
3. 程序使用完临界资源后，向协调者发送释放授权，1 次消息交互。

因此，每个程序完成一次临界资源访问，需要进行 3 次消息交互。

不难看出，集中式算法的优点在于直观、简单、信息交互量少、易于实现，并且所有程序只需和协调者通信，程序之间无需通信。但是，这个算法的问题也出在了协调者身上。

- 一方面，协调者会成为系统的性能瓶颈。想象一下，如果有 100 个程序要访问临界资源，那么协调者要处理 100*3=300 条消息。也就是说，协调者处理的消息数量会随着需要访问临界资源的程序数量线性增加。
- 另一方面，容易引发单点故障问题。协调者故障，会导致所有的程序均无法访问临界资源，导致整个系统不可用。

因此，在使用集中式算法的时候，一定要选择性能好、可靠性高的服务器来运行协调者。

**小结一下：**集中式算法具有简单、易于实现的特点，但可用性、性能易受协调者影响。在可靠性和性能有一定保障的情况下，比如中央服务器计算能力强、性能高、故障率低，或者中央服务器进行了主备备份，主故障后备可以立马升为主，且数据可恢复的情况下，集中式算法可以适用于比较广泛的应用场景。

### 民主协商：分布式算法

既然引入协调者会带来一些问题，这时你可能就会想，不用协调者是否可以实现对临界资源的互斥访问呢？想象一下，当你需要使用自助咖啡机的时候，是不是可以先去征求其他人的意见，在确认其他人都没在使用也暂时不会使用咖啡机时，你就可以放心大胆地去泡制自己的咖啡了呢？

同理，我们可以把这套算法用于分布式系统。当一个程序要访问临界资源时，先向系统中的其他程序发送一条请求消息，在接收到所有程序返回的同意消息后，才可以访问临界资源。其中，请求消息需要包含所请求的资源、请求者的 ID，以及发起请求的时间。

这，就是民主协商法。**在分布式领域中，我们称之为分布式算法，或者使用组播和逻辑时钟的算法。**

如图所示，程序 1、2、3 需要访问共享资源 A。在时间戳为 8 的时刻，程序 1 想要使用资源 A，于是向程序 2 和 3 发起使用资源 A 的申请，希望得到它们的同意。在时间戳为 12 的时刻，程序 3 想要使用资源 A，于是向程序 1 和 2 发起访问资源 A 的请求。

### 轮值 CEO：令牌环算法 

那么除了集中式算法、分布式算法以外，还有什么方法可以实现分布式互斥吗？答案是肯定的。毕竟，方法总比问题多。华为独创的轮值 CEO 其实就给了我们一个很好的启示。在华为的轮值 CEO 体系里，CEO 就是临界资源，同时只能有一个人担任，由多名高管轮流出任 CEO。

类似地，程序访问临界资源问题也可按照轮值 CEO 的思路实现。 如下图所示，所有程序构成一个环结构，令牌按照顺时针（或逆时针）方向在程序之间传递，收到令牌的程序有权访问临界资源，访问完成后将令牌传送到下一个程序；若该程序不需要访问临界资源，则直接把令牌传送给下一个程序。

在分布式领域，这个算法叫作令牌环算法，也可以叫作基于环的算法。为了便于理解与记忆，你完全可以把这个方法形象地理解为轮值 CEO 法。

![令牌环算法](https://wwfyde.oss-cn-hangzhou.aliyuncs.com/images/202305101710612.jpg)

因为在使用临界资源前，不需要像分布式算法那样挨个征求其他程序的意见了，所以相对而言，在令牌环算法里单个程序具有更高的通信效率。同时，在一个周期内，每个程序都能访问到临界资源，因此令牌环算法的公平性很好。

但是，不管环中的程序是否想要访问资源，都需要接收并传递令牌，所以也会带来一些无效通信。假设系统中有 100 个程序，那么程序 1 访问完资源后，即使其它 99 个程序不需要访问，也必须要等令牌在其他 99 个程序传递完后，才能重新访问资源，这就降低了系统的实时性。

综上，**令牌环算法非常适合通信模式为令牌环方式的分布式系统**，例如移动自组织网络系统。一个典型的应用场景就是无人机通信。

无人机在通信时，工作原理类似于对讲机，同一时刻只能发送信息或接收信息。因此，通信中的上行链路（即向外发送信息的通信渠道）是临界资源。

如下图所示，所有的无人机组成一个环，按照顺时针方向通信。每个无人机只知道其前一个发送信息的无人机，和后一个将要接收信息的无人机。拥有令牌的无人机可以向外发送信息，其他无人机只能接收数据。拥有令牌的无人机通信完成后，会将令牌传送给后一个无人机。

所有的无人机轮流通信并传输数据，从而消除了多个无人机对通信资源的争夺，使得每个无人机都能接收到其他无人机的信息，降低了通信碰撞导致的丢包率，保证了网络通信的稳定性，提高了多个无人机之间的协作效率。



# **高并发**

## 基础概念

并发: 

常见的并发方式 : 多线程, 子进程, 协程, 生成器. 多进程

### 需要避免的问题

全局变量引发的竞争问题

# 线程通信

# 进程通信

# **云计算**

### 定义



云计算（cloud computing）是分布式计算的一种，指的是通过网络“云”将巨大的数据计算处理程序分解成无数个小程序，然后，通过多部服务器组成的系统进行处理和分析这些小程序得到结果并返回给用户。

> 数据分割 使用相同的程序代码, 来跑同一个任务

云计算早期，简单地说，就是简单的分布式计算，解决任务分发，并进行计算结果的合并。因而，云计算又称为网格计算。通过这项技术，可以在很短的时间内（几秒种）完成对数以万计的数据的处理，从而达到强大的网络服务。

现阶段所说的云服务已经不单单是一种分布式计算，而是**分布式计算**、**效用计算**、**负载均衡**、并行计算、网络存储、热备份冗杂和虚拟化等计算机技术混合演进并跃升的结果。



维基百科:

**云计算**（英语：**cloud computing**），是一种基于[互联网](https://zh.wikipedia.org/wiki/互联网)的计算方式，通过这种方式，共享的软硬件资源和信息可以按需求提供给计算机各种终端和其他设备，使用服务商提供的计算机基建作计算和资源。

# Web开发技术原理

本文档主要用于记录 **说明简介** , **技术参考** 和 **使用说明**, **工作原理** 以及 **运行机制**

更倾向于理论化和抽象化







# 网络基础

计算机网络

## 服务器开发



## 技术趋势

- 快速迭代
- **高并发**
    - 异步编程(上下文切换)
- 分布式
- 高可用
- 高性能
- **实时数据处理**
- 高扩展
- 快速响应
- 微服务系统
- 性能优化性能调优

## 核心必会技术

- Ajax
- mysql
- linux1
- 框架



## 案例: 文件下载器 没看 (补充看后面)







