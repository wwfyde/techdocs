# C程序设计语言

## 参考文档
[GNU C Manual](https://www.gnu.org/software/gnu-c-manual/gnu-c-manual.html)

## 学习目标

### C学习目标

### C++学习目标

基本语法, 设计风格 语言特性 

面向对象的基本概念和思想, 根据实际需求设计并实现自己的类

## 学习技巧

理解好C中的函数至关重要

理解基础的语言, 能读懂和翻译C代码, 语法, 语义, 运算符, 基本的结构, 关键词

多练习, 多阅读, 多写Demo, 多实践, 处理错误和异常

函数名: 就是函数目标, 一般为动词+ 名称, 囊括, 函数的目标

模块名: 一般为名词

[原文链接](https://mp.weixin.qq.com/s?__biz=MzIxNzMyNjc2NA==&mid=2247486402&idx=2&sn=b18559e259a7d9c52f9ca1a2693d826b&chksm=97fa3e01a08db717c85eb430ceeeb5b8ea650c68f9c3326864bc1392b4fc207496c1a265dc06&scene=0&xtrack=1&key=ce671f2c7e350727b26661dd85a5088b91df496c293029d069a2944f6ef84229619c83e2ce5de2a4e1deabba5b076b67b43203312a3da5cd963cafdf0b9e8cac784149dcef5933869f2b110426c777a5&ascene=1&uin=OTcxOTExNDI0&devicetype=Windows+10+x64&version=62090070&lang=zh_CN&exportkey=ATkCCgLL7SnFoaj8LbUL1rU%3D&pass_ticket=NsNl7M48ZYX%2Bo%2BTTlvA9w%2FnxTTCqNbuFCCKw9B25sf1OxjcYHXVo3%2BQ1CyGzG8mk)

**先看理论, 再去练习实践, 从而掌握**

**学习C语言的顺序**





1)选一本好的入门书，系统地学习。





2)动手去上机操作和练习，对答案，**任何理论知识都需要实操验证**。



3)正确认识和理解C语言，把握学习的重点，避免分散精力。



从最基础的语法（变量、字符串、条件、循环、数组、函数、结构体等），再到高阶的算法（指针、内存管理等C语言中至关重要的两大标准），循序渐进。



确实，大家在学习 C 语言的过程中，往往忽视了最重要的一点，看书很重要，但配套的训练同样不容忽视，两者结合起来同时进行的才能快速提升编程水平，最终达成学习的目标——在实际项目中运用。



而学习 C 语言恰恰就是一个坚持**看**、**敲**、**写**的过程，缺一不可：

1)**多看书学习**

不能仅仅记住那些名词，那些规则，程序设计语言的重点在于应用。在应用中去总结和体会，用自己的语言去定义那些名词术语，用自己的语言去概括那些语法的规则和意义。对，就是不要“你觉的”，而是要通过学习领会“你觉的”，最终到达“自己觉得”！



2)**操作和练习**

C语言是一门工具，我们要在不断的操作和练习中熟悉工具的性能、使用方法和使用技巧，仅仅停留在纸上谈兵的程度，是远远不够的。



3)**拓展知识面**

C语言虽然是一门高级程序设计语言，但是它还是涉及很多计算机系统底层方面的知识，最典型的例如指针，多了解一些计算机原理方面的知识，拓展自己的知识面。



4)**多做练习**

不能仅仅停留在编码上，程序设计的重点在于设计。做习题时拿起纸和笔，整理自己的思路，记录自己分析问题和解决问题的想法。过段时间再来看看自己曾经的想法，评价一下，也就是说，学习C语言，要反复多次地进入学习。



5)**反复学习**

学习C语言，要反复多次地进入学习。每过段时间再来整理自己的所学和曾经的想法，

第一次，重点在于了解基本语法和知识点

第二次，在练习中体会基本语法和知识点

第三次，系统观的练习和设计思想的锻炼



逐渐在学习中培养自己的逻辑思维能力。学习自顶而下的分析方法，学习严谨而全面的流程控制。学习其他优秀工程师的思维技巧，将会是我们受益终生。

# 核心思想

从语法上来说：引用、继承、多态、重载、容器；从设计来说：23种设计模式





## 快速入门

> 编写程序 >> 编译 >> 加载 >> 运行 >> 输出 

打印 "hello, world"

```c
#include<stdio>

int main(){
    printf("hello, world")
}
```

```shell

```



## 设计模式

设计模式 是一种 思维模型 评估模型 建立表征  框架 模型 是一种经验 + 框架 

协议 = 

创建型 (数据:材料) -- 语法

结构性 (逻辑:组合) -- 时序

功能型 (行为:方法) -- 语义

命令设计模式 

设计模式的语言基础就是, 多态特性

对现实的模拟 , 复杂的

非常重要 

直接决定的复杂度 

框架 对现实的模式 



## 标准库

## 设计特性

自顶向下

结构化编程 : 顺序, 循环, 选择, 子程序, 代码块

模块化设计

### 高效性

### 可移植性

### 强大而灵活

### 面向程序员

### 缺点

指针错误, 运算符多且复杂



# 语言特性



调接口应该就是c++动态库或者静态库的知识了，一般开放的都是函数；从这个角度讲就是函数、函数参数、函数返回值



编译型语言

- C语言中, 变量和数据是分开存储的

- *语言优势* : 强大的控制结构, 快速, 代码紧凑, 可移植性
- *语言标准* :
  - <u>ANSI标准</u> :C90 
  - <u>C99</u> : 1999  
  - <u>C11</u> : 2011
- 设计哲学(C90/ ANSI C):
  - 信任程序员
  - 不要妨碍程序员做需要做的事
  - 轻装上阵, 经济使用资源的原则
  - 保持语言<u>精炼简单</u>
  - 只提供一种方法执行一项操作
  - 让程序运行更快, 即使不能保证其可移植性
  - 作为实现, 应该针对目标计算机来定义最合适的某特定操作, 而不是强加一个抽象, 统一的定义
- 重大变更
  - *C99*: main函数必须要声明类型, 如果没有返回值, 需要 `void` 
  - `//` 单行注释从*C99*开始支持, 解决 `/* */`多行注释, 避免误删除,在符号配对时造成注释正常的代码的情况

## 使用C语言的7个步骤

![image-20200425005442174](https://wwfyde.oss-cn-hangzhou.aliyuncs.com/images/20210426192246.png)

### 1, 定义程序的目标

编写程序前,应该理清思路. *明确目标* , 需要哪些*输入信息*, 要进行哪些*计算*和*控制*, 信息加工, 逻辑处理, 状态迁移, 以及程序需要哪些*输出信息*.

这一步骤中, 不涉及具体的计算机语言, 应该用一般术语来描述问题

**web编程中则需要 多一个 额外的触发条件, 来实现手动信息输入.**

任务目标需求问题:概念化

### 2, 设计程序

*数据表示*

*数据处理*

### 3, 编写代码

把设计程序 翻译成C语言

```c
#include <stdio.h>
int main(void)
{
    //这是注释
    int dogs;
    printf("Hello, 世界!\n");
    scanf("%d", &dogs);
    printf("你输入了 %d 条狗\n", dogs);
    return 0;
}
```

### 4, 编译

说明: 编译的细节取决于编程的环境

### 5, 运行程序

通过IDE, 命令行, 双击可执行文件等方式运行程序

### 6, 测试和调试程序

解决bug

*调试*: 查找并修复程序错误的过程. 

### 7, 维护和修改代码

修复错误, 扩展程序, 修改代码, 

使用更好的解决方案, 添加新的特性, 移植代码到其他计算机系统中

### 说明

编程并非像描述那样是一个线性的过程。有时，要在不同的步骤之间往复。例如，在写代码时发现之前的设计不切实际，或者想到了一个更好的解决方案，或者等程序运行后，想改变原来的设计思路。对程序做文字注释为今后的修改提供了方便。
许多初学者经常忽略第1步和第2步(定义程序目标和设计程序)，直接跳到第3步(编写代码)。刚开始学习时，编写的程序非常简单，完全可以在脑中构思好整个过程。即使写错了，也很容易发现。但是，随着编写的程序越来越庞大、越来越复杂，动脑不动手可不行，而且程序中隐藏的错误也越来越难找。最终，那些跳过前两个步骤的人往往浪费了更多的时间，因为他们写出的程序难看、缺乏条理、让人难以理解。要编写的程序越大越复杂，事先定义和设计程序环节的工作量就越大。
磨刀不误砍柴工，应该养成先规划再动手编写代码的好习惯，用纸和笔记录下程序的目标和设计框架。这样在编写代码的过程中会更加得心应手、条理清晰。



## 用法思想 语法特性 语法结构 

三大特性 继承(重写 访问) 封装(访问权限  结构体 + 成员方法) 多态

C++ 结构类(存储) + 方法(功能) 对计算机的模拟

Python 属性(特性) + 方法(方法)  对现实的模拟





公有 , 保护权限 私有权限

多态 : 接口 , 关键字 virtual (虚拟) 声明一个接口  



一个类的的所有 函数 都加上了 virtual   就是一个接口 

Python : 基类 + 实现多态  默认所有 

C++ 来写一条 Python的框架 

java / 接口

**模板**:写了 一个框架  自己定义对象  容器 存取 访问 特定的类型 

链表 , 

基础数据类型 的封装 成为模板 list模板  静态的新的对象 

模板的 作用 对 数据结构 特定的方法来约束结构 

**容器** -- 数据结构 

容器 是用模板语法来实现 

模板:语法层 

int a = 10 

Template A  + B + 方法  造成一种

容器:是语义层

## 数据结构

内存管理  数据结构 其实  内存空间 反应 

**对象**:函数 内存区域 放在  所有的数据结构就是内存

**结构体** : 纯粹 独立的内存 

全是成员变量:结构体:模拟 现实 结构体 . 访问 内存里面可以访问具体



结构体 >> 对象 self **this指针**  >> 对象的方法 >> 指向 结构体 = 唯一ID

对象 = 结构体 + 成员函数  可读写的一块内存空间 根据函数 + 

C中 this指针 指向的内存 = 结构体  

C++对象

**结构体** 是一种数据结构 

结构体 初始化一次 内存空间 用结构体的名称 >> 内存ID >> 内存空间 

成员变量

成员函数 = 方法  只读区域 逻辑 构成一个代码块 也有一个地址 函数指针



**指针** 数据类型指针 可读 可写 函数执行 指向逻辑指令 不能修改



静态语言 访问内存块 直接操作 

Python 解释代码 运行 -- 插入 辅助逻辑代码 

静态语言:在运行之前 已经直接编译成代码 写完之后编译成可执行文件 

先解释执行 

内存效率  内存  存储  内存 桶

效率 CPU 计算 泵 

基础类型

对象 把函数 和结构体 绑定在一起 

本质上区别 编译之后符号不一样 C++ 重载 更多参数类型 C++ 支持的数据类型(一切可以传递给函数)

C 只跟 一个函数 只能支持一种参数  只能是 C的基础数据类型



C++ 接口  就是函数 (调用函数, 传参 返回结构)

函数类 接口 相当于是 使用接口 支持 一个 利用功能  **对象的接口**

JAVA 接口 实现多态  支持语言的多态性  一个编程接口  一个多态 接口 构造

**类的接口** 封装方法 定义功能 多态 

基本概念

变量与常量

# 程序基础

## gcc/g++编译器

```shell
gcc [options] [filenames]
# 参数说明
-E	Preprocess only; do not compile, assemble or link.
-E	预处理
-S	Compile only; do not assemble or link.
-S	只编译
-c	Compile and assemble, but do not link.
-c	编译并拼装, (汇编)
-o <file> 	Place the output into <file>.
-o	链接
-L	链接库文件	
-shared	Create a shared library.
-shared	创建一个共享库

# 不携带参数
gcc hello.c # 默认会输出 a.out的可执行文件
gcc hello.c -o hello  # >> 输出hello的二进制可执行文件 
# 编译并拼装 但并不是可执行文件
gcc -c hello.c  # >> hello.o


```



```shell
# 简单编译文件
gcc test.c  # 生成 test.o



# 编译为汇编文件  备选 
gcc -c test.c -o test.o

# 编译为 ELF 可执行文件
gcc -o test.o test.c

# 多个文件一步编译成可执行文件 不用 -c
gcc a.c b.c c.c -o test

# 

# 编译为动态共享库
gcc -shared -fPIC   -o test.o libtest.so
gcc  -fpic -shared hello.c -o libhello.so  # 直接从源文件到共享链接库
```

## Hello, world!

```c
#include <stdio.h>

int main()
{
    printf("hello,world\n");
    return 0;
}

```

一个C语言程序, 无论其大小如何, 都是由<u>函数</u>和<u>变量</u>组成的.

函数中包含一些语句, 以指定所要执行的计算操作; 变量则用于存储计算过程中使用的值. 

函数之间进行数据交换的一种方法是调用函数向被调用函数提供一个参数列表, 用`()`括起来. 

函数中的语句用`{}`括起来.

<u>调用函数</u>时, 只需要使用 `func_name(para_list)`即可;

`""`括起来的字符列表成为字符串或字符串常量;

`\n`表示换行符; `\n`代表一个字符, 转义字符以输入无法输入或看不见的字符为字符串的输入提供了一种通用的可扩充机制. 

printf永远不会自动换行, 即多个printf语句会打印到一行

## 编程机制

编程环境 : UNIX, Linux, Windows, MacOS

### 源代码-Source code

源代码文件

生成程序的具体过程因计算机环境而异。C是可移植性语言，因此可以在许多环境中使用，包括UNIX、Linux、MS-DOS(一些人仍在使用)、Windows和Macintosh OS。有些产品会随着时间的推移发生演变或被取代，本书无法涵盖所有环境。
首先，来看看许多C环境(包括上面提到的5种环境)共有的一些方面。虽然不必详细了解计算机内部如何运行C程序，但是，了解一下编程机制不仅能丰富编程相关的背景知识，还有助于理解为何要经过一些特殊的步骤才能得到C程序。
用C语言编写程序时，编写的内容被储存在文本文件中，该文件被称为*源代码*文件(source code file)。大部分C系统，包括之前提到的，都要求文件名以.c结尾(如，wordcount.c和budget.c)。在文件名中，点号(.)前面的部分称为*基本名*(basename)，点号后面的部分称为*扩展名*(extension)。因此，budget是基本名，c是扩展名。基本名与扩展名的组合(budget.c)就是*文件名*(filename)。文件名应该满足特定计算机操作系统的特殊要求。Linux区分大小写。
接下来，我们来看一下具体的应用，假设有一个名为concrete.c的源文件

```c
/* concrete.c */
#include <stdio.h>
int main(void)
{
   printf("Concrete contains gravel and cement.\n");

   return 0;
}
```

### 编译过程

​	C编程的基本策略是，用程序把源代码文件转换为可执行文件(其中包含可直接运行的机器语言代码)。典型的C实现通过编译和链接两个步骤来完成这一过程。**编译器把源代码转换成中间代码，链接器把中间代码和其他代码合并，生成可执行文件。**C使用这种分而治之的方法方便对程序进行*模块化*，可以独立编译单独的模块，稍后再用链接器合并已编译的模块。通过这种方式，如果只更改某个模块，不必因此重新编译其他模块。另外，**链接器还将你编写的程序和预编译的库代码合并。**

​	中间文件有多种形式。我们在这里描述的是最普遍的一种形式，即把源代码转换为机器语言代码，并把结果放在*目标代码*文件(或简称*目标文件*)中(这里假设源代码只有一个文件)。虽然目标文件中包含机器语言代码，但是并不能直接运行该文件。因为目标文件中储存的是编译器翻译的源代码，这还不是一个完整的程序。

​	目标代码文件缺失*启动代码*(startup code)。*启动代码充当着程序和操作系统之间的接口。*例如，可以在MS Windows或Linux系统下运行IBM PC兼容机。这两种情况所使用的硬件相同，所以目标代码相同，但是Windows和Linux所需的启动代码不同，因为这些系统处理程序的方式不同。

​	目标代码还缺少*库函数*(library function)。几乎所有的C程序都要使用C标准库中的函数。例如，concrete.c中就使用了printf()函数。目标代码文件并不包含该函数的代码，它只包含了使用printf()函数的指令。printf()函数真正的代码储存在另一个被称为库的文件中。**库文件中有许多函数的目标代码。**

​	**链接器的作用是，把你编写的目标代码、系统的标准启动代码和库代码这3部分合并成一个文件，即可执行文件。**对于库代码，链接器只会把程序中要用到的库函数代码提取出来(见图1.4)。

![image-20200425012614140](https://wwfyde.oss-cn-hangzhou.aliyuncs.com/images/20210426192257.png)

**简而言之，目标文件和可执行文件都由机器语言指令组成的。**然而，目标文件中只包含编译器为你编写的代码翻译的机器语言代码，可执行文件中还包含你编写的程序中使用的库函数和启动代码的机器代码。在有些系统中，必须分别运行编译程序和链接程序，而在另一些系统中，编译器会自动启动链接器，用户只需给出编译命令即可。

源文件 : `name.c`

头文件 : `name.h`:header

目标文件 : `name.o`:object

可执行文件 : `name` / `name.exe`:executable

## 基本概念

### 程序:Program

我们平时所说的程序，是指双击后就可以直接运行的程序，这样的程序被称为可执行程序(Executable Program)。在 Windows 下，可执行程序的后缀有`.exe`和`.com`(其中`.exe`比较常见)；在类 UNIX 系统(Linux、Mac OS 等)下，可执行程序没有特定的后缀，系统根据文件的头部信息来判断是否是可执行程序。

可执行程序的内部是一系列计算机指令和数据的集合，它们都是二进制形式的，CPU 可以直接识别，毫无障碍；但是对于程序员，它们非常晦涩，难以记忆和使用。

### 预处理:Preprocessing

预编译

编译之前, 对源代码文件进行预处理

### 编译:Compile

C语言代码由固定的词汇按照固定的格式组织起来，简单直观，程序员容易识别和理解，但是对于CPU，C语言代码就是天书，根本不认识，CPU只认识几百个二进制形式的指令。这就需要一个工具，将C语言代码转换成CPU能够识别的二进制指令，也就是将代码加工成 .exe 程序的格式；这个工具是一个特殊的软件，叫做**编译器(Compiler)**。

编译器能够识别代码中的词汇、句子以及各种特定的格式，并将他们转换成计算机能够识别的二进制形式，这个过程称为**编译(Compile)**。

编译器是把源代码转换成可执行代码的程序

可执行代码吗是用计算机的机器语言表示的代码: 由数字码表示的指令.

不通的计算机使用不同的机器语言方案. C编译器负责把C代码翻译成特定的机器语言.

C编译器在链接时(链接器来链接库函数), 还将源代码与C库的代码合并成最终的程序, 生成一个用户可以运行的可执行文件, 其中包含着计算机能理解的代码. 

编译器还会检查C语言程序是否有效. **程序员需要理解特定的编译器报告的错误或警告信息, 这是一项非常重要的技能**

编译过程 : 预编译 编译 汇编 链接动态库和静态库



#### C/C++编译过程

C/C++程序从源代码到可执行文件需要经理预处理(预编译)，编译，汇编，链接四个过程：

1、预处理：对源代码中的伪指令(以# 开头的指令)和特殊符号进行处理，如#include指令，预处理会将对应的头文件(即.h文件，声明全局变量和函数，相当于java中的接口类)写入到源代码文件(即.c文件，包含函数的具体实现)。预处理后生成的是.i后缀结尾的文件，依然是文本文件。

2、编译：对预处理结果文件做词法和语法分析，在确认所有的指令都符合语法规则之后，将其翻译成等价的中间代码表示或汇编代码，翻译过程中会执行两种通用的编译优化，一种是代码层面的如代码外提，复制传播等，一种是跟硬件强相关的优化，包括选择更高效的机器指令，合理分配和指派寄存器，具体优化内容可参考《编译原理》，可通过gcc的参数指定优化的强度，通常优化强度越高编译越慢。因为寄存器的种类和数量是取决于CPU架构的，通常只有对应架构下的汇编指令可以直接操作寄存器，C语言中有register关键字请求编译器尽量将某个变量放入寄存器中，但是最终是否放入寄存器由编译器根据硬件环境决定。编译过程产生的文件还是文本文件，以.s结尾，该文件是对应平台下的翻译出的汇编代码。

3、汇编：指把汇编语言代码翻译成目标机器指令的过程，该过程相对简单，将对应的汇编指令替换成数字形式的指令码即可。汇编完成后生成的文件以.o结尾，通常是可重定位目标文件。

4、链接： 编译时是以单个.c文件为单位编译的，所以会产生多个.o文件，将多个.o文件与之依赖的共享库如libc链接在一起形成可执行文件，可执行文件的后缀可以是out或者elf。Linux加载可执行文件过程中不会校验文件后缀而校验是否符合ELF文件格式。

### 目标文件-Object file

### 链接:Link

C语言代码经过编译以后，并没有生成最终的可执行文件(.exe 文件)，而是生成了一种叫做目标文件(Object File)的中间文件(或者说临时文件)。目标文件也是二进制形式的，它和可执行文件的格式是一样的。对于 Visual C++，目标文件的后缀是`.obj`；对于 GCC，目标文件的后缀是`.o`。

目标文件经过链接(Link)以后才能变成可执行文件。既然目标文件和可执行文件的格式是一样的，为什么还要再链接一次呢，直接作为可执行文件不行吗？

不行的！因为编译只是将我们自己写的代码变成了二进制形式，它还需要和系统组件(比如标准库、动态链接库等)结合起来，这些组件都是程序运行所必须的。

**链接(Link)**其实就是一个“打包”的过程，它将所有二进制形式的目标文件和系统组件组合成一个可执行文件。完成链接的过程也需要一个特殊的软件，叫做**链接器(Linker)**。

随着我们学习的深入，我们编写的代码越来越多，最终需要将它们分散到多个源文件中，编译器每次只能编译一个源文件，生成一个目标文件，这个时候，链接器除了将目标文件和系统组件组合起来，还需要将编译器生成的多个目标文件组合起来。

再次强调，编译是针对一个源文件的，有多少个源文件就需要编译多少次，就会生成多少个目标文件。

<u>总结</u>:

不管我们编写的代码有多么简单，都必须经过「编译 --> 链接」的过程才能生成可执行文件：

- 编译就是将我们编写的源代码“翻译”成计算机可以识别的二进制格式，它们以目标文件的形式存在；
- 链接就是一个“打包”的过程，它将所有的目标文件以及系统组件组合成一个可执行文件。

如果不是特别强调，一般情况下我们所说的“编译器”实际上也包括了链接器

### 装载       

## C语言概述

![image-20200425131358417](https://wwfyde.oss-cn-hangzhou.aliyuncs.com/images/20210426192302.png)

函数是C程序的构造块

### 程序简述

本节简述程序中的每行代码的作用。下一节详细讨论代码的含义。

```c
#include<stdio.h>     // ←包含另一个文件  该行告诉编译器把stdio.h中的内容包含在当前程序中。stdio.h是C编译器软件包的标准部分，它提供键盘输入和屏幕输出的支持。
// 宏预处理器, 编译时将链接的代码加载到编译代码中

int main(void)        // ←函数名  C程序包含一个或多个函数，它们是C程序的基本模块。程序清单2.1的程序中有一个名为main()的函数。圆括号表明main()是一个函数名。int表明main()函数返回一个整数，void表明main()不带任何参数。这些内容我们稍后详述。现在，只需记住int和void是标准ANSI C定义main()的一部分(如果使用ANSI C之前的编译器，请省略void；考虑到兼容的问题，请尽量使用较新的C编译器)。
    
/* 一个简单的C程序 */    // ←注释注释  在/*和*/两个符号之间，这些注释能提高程序的可读性。注意，注释只是为了帮助读者理解程序，编译器会忽略它们。

{         //←函数体开始 左花括号表示函数定义开始，右花括号(})表示函数定义结束。
    int num;  //←声明  该声明表明，将使用一个名为num的变量，而且num是int(整数)类型。
    num = 1;       //  ←赋值表达式语句语句num=1;把值1赋给名为num的变量。
    printf("I am a simple "); // ←调用一个函数  该语句使用printf()函数，在屏幕上显示Iamasimple，光标停在同一行。printf()是标准的C库函数。在程序中使用函数叫作调用函数。
    printf("computer.\n");    // ←调用另一个函数  接下来调用的这个printf()函数在上条语句打印出来的内容后面加上“computer”。代码\n告诉计算机另起一行，即把光标移至下一行。
    printf("My favorite number is %d because it is first.\n", num);  //最后调用的printf()把num的值(1)内嵌在用双引号括起来的内容中一并打印。%d告诉计算机以何种形式输出num的值，打印在何处。
    return 0;    // ←return语句 C函数可以给调用方提供(或返回)一个数。目前，可暂时把该行看作是结束main()函数的要求。
}       // ←结束
必须以右花括号表示程序结束。
```

### 程序结构

通过圆括号来识别出前面的标识符是一个函数

```c
#include <stdio.h>  // 头文件
int main(void)  // 函数头 : 返回类型:函数名:传入类型
{
    int num;  //语句
    return 0;  //返回语句
}  //函数体
```

**大部分语句都以分号结尾. **

## 调试程序

使用IDE检查代码错误, 编译时检查错误



### 语法错误

>  表示上的错误

单词拼写错误

语法结构错误

类型错误

### 语义错误

> 意思上的错误

返回结果不正确, **编译器无法洁厕语义错误**, 因为何磊错误并未违反C语言的规则. 编译器无法了解你的真正意图, 所以只能自己找出这些错误, 通过测试. 

算法错误, 逐行调试往往是解决语义错误的最好办法

你很可能按照自己所想去执行程序, 而不是根据实际写出来的代码去执行. 因此, 要尽量忠实于代码来模拟. 

### 程序状态

通过逐步跟踪程序的执行步骤，并记录每个变量，便可监视程序的状态。程序状态（program state）是在程序的执行过程中，某给定点上所有变量值的集合。它是计算机当前状态的一个快照。

我们刚刚讨论了一种跟踪程序状态的方法：自己模拟计算机逐步执行程序。但是，如果程序中有10000次循环，这种方法恐怕行不通。不过，你可以跟踪一小部分循环，看看程序是否按照预期的方式执行。另外，还要考虑一种情况：**你很可能按照自己所想去执行程序，而不是根据实际写出来的代码去执行。因此，要尽量忠实于代码来模拟。**
定位语义错误的另一种方法是：**在程序中的关键点插入额外的printf()语句，以监视制定变量值的变化。**通过查看值的变化可以了解程序的执行情况。对程序的执行满意后，便可删除额外的printf()语句，然后重新编译。

<u>不要怀疑错误是计算机造成的, 错误应该是自己的代码造成的. 不要错误的以为自己的想法, 就是程序的想法.</u>

**检测程序状态的第3种方法是使用调试器。**调试器（debugger）是一种程序，让你一步一步运行另一个程序，并检查该程序变量的值。调试器有不同的使用难度和复杂度。较高级的调试器会显示正在执行的源代码行号。这在检查有多条执行路径的程序时很方便，因为很容易知道正在执行哪条路径。如果你的编译器自带调试器，现在可以花点时间学会怎么使用它。例如，试着调试一下程序清单2.4。

### C程序总结

C程序由一个或多个C函数组成。每个C程序必须包含一个main()函数，这是C程序要调用的第1个函数。简单的函数由函数头和后面的一对花括号组成，花括号中是由声明、语句组成的函数体。
在C语言中，大部分语句都以分号结尾。声明语句为变量指定变量名，并标识该变量中储存的数据类型。变量名是一种标识符。赋值表达式语句把值赋给变量，或者更一般地说，把值赋给存储空间。函数表达式语句用于调用指定的已命名函数。调用函数执行完毕后，程序会返回到函数调用后面的语句继续执行。printf()函数用于输出想要表达的内容和变量的值。
一门语言的语法是一套规则，用于管理语言中各有效语句组合在一起的方式。语句的语义是语句要表达的意思。编译器可以检测出语法错误，但是程序里的语义错误只有在编译完之后才能从程序的行为中表现出来。检查程序是否有语义错误要跟踪程序的状态，即检查程序每执行一步后所有变量的值。最后，关键字是C语言的词汇。

# 编程技巧

## 编程风格

可读性, 保持一定的风格

提高程序的可读性, 让程序更容易理解, 以后也更容易修改和更正, 还有助于自己理清编程思路

- 选择有意义的函数名;
- 编写注释;
- 在函数中用空行分隔概念上的多个部分;
  - 把声明部分和程序的其它部分区分开来.
- 每条语句占用一行;

![image-20200425165724528](https://wwfyde.oss-cn-hangzhou.aliyuncs.com/images/20210426192311.png)

## 重要说明

编程是一件富有挑战性的事情。程序员要具备抽象和逻辑的思维，并谨慎地处理细节问题（编译器会强迫你注意细节问题）。平时和朋友交流时，可能用错几个单词，犯一两个语法错误，或者说几句不完整的句子，但是对方能明白你想说什么。而编译器不允许这样，对它而言，几乎正确仍然是错误。

编译器希望接收到特定格式的指令。作为程序员的任务是，在符合C标准的编译器框架中，表达你希望程序应该如何完成任务的想法。

即使是一个很简单的C程序也要用大量的机器语言来表示）。由于编译器不具有真正的智能，所以你必须用编译器能理解的术语表达你的意图，这些术语就是C语言标准规定的形式规则（尽管有些约束，但总比直接用机器语言方便得多）。

# Glossary

> 术语对照表, 基本的定义, 基本的模型材料

用<>包含，编译器会先在系统目录下搜索；
用” ” 包含，编译器会先在用户目录下搜索。
所以，如果使用系统标准库，要使用<>来包含头文件；使用自定义头文件用” “包含最好。

在C++工程中，只有带有main函数的cpp文件才会生成可执行程序，其他的cpp只会生成库文件。

而库文件分为静态库(.a)和共享库(.so)，这两者的差别在与，静态库每次调用都会生成一个副本，而共享库只有一个副本，更节省空间。

<u>库文件</u>是一个二进制的压缩包，只有库文件我们并不知道其作用是什么，以及如何使用它。
为了让别人以及自己如何使用这个库文件，我们需要头文件来说明它。因此有了头文件和库文件，我们就知道如何调用一个库了。

[原文链接](https://blog.csdn.net/qq_33883085/article/details/88386884?depth_1-utm_source=distribute.pc_relevant.none-task&utm_source=distribute.pc_relevant.none-task)

两者的差别仅在于程序执行时所需要的代码是在运行时动态加载的，还是编译时静态加载的。默认情况下，gcc在链接时优先使用动态链接库，只有在动态链接库不存在时，才会使用静态链接库。如果需要的话，可以在编译时加上-static选项，强制使用静态链接库。如在/home/zsx/lib目录内部由libfoo.so 和libfoo.a文件，为了让gcc只用到静态链接库，而不使用动态链接库，则可以：gcc foo.c -L /home/zsx/lib -static -lfoo -o foo         ldd命令用来显示二进制代码文件动态库的链接情况，如：ldd foo  

头文件是文本文件，是可供阅读的；库文件是二进制文件，不可直接阅读。库文件是将一系列的源文件进行编译打包，形成的二进制文件包，其中封装着函数接口，在编程中可以由其它源文件调用。库文件可分为静态库和动态库两种。

头文件在编译中使用；库文件在链接中使用。头文件中是函数或定义的声明，及少量内联函数的使用，一般不包含非静态函数实现；库文件中包含函数的实现。头文件是手动编写的，库文件是编译生成的。

虽然没有规定调用库函数必须引用头文件，但一般约定，当调用库函数的时候需要引用接口函数所在的头文件。

一个库文件均有一组头文件与其对应。库文件和对应头文件的作者应为同一个。作者必须保证头文件中所声明的函数类型及参数列表，与库文件中的实现是相同的。

具体来说，头文件中有函数的申明，库文件实现函数的定义。比如，printf函数。使用时应包括stdio.h，打开stdio.h你只能看到，printf这个函数的申明，却看不到printf具体是怎么实现的，而函数的实现在相应的C库中。而库文件一般是以二进制形式而不是C源文件形式提供给用户使用的。程序中包括了stdio.h这个头文件。链接器就能根据头件中的信息找到printf这个函数的实现并链接进这个程序代码段里。总结起来就是，库文件通过头文件向外导出接口。用户通过头文件找到库文件中函数实现的代码从而把这段代码链接到用户程序中去。





## 内存: Memory

> 内存原理

[Linu进程的虚拟内存划分](https://www.cnblogs.com/fah936861121/p/6878699.html)

![image-20200326185507637](https://wwfyde.oss-cn-hangzhou.aliyuncs.com/images/20210426192317.png)

## 变量:Variable


变量其实只不过是程序可操作的存储区的名称。C 中每个变量都有特定的类型，类型决定了变量存储的大小和布局，该范围内的值都可以存储在内存中，运算符可应用于变量上。

变量的名称可以由字母、数字和下划线字符组成。它必须以字母或下划线开头。大写字母和小写字母是不同的，因为 C 是大小写敏感的。

<u>向保松:数据类型不占用内存，声明变量或对象的时候就会分配内存！内存有三个区域：全局变量、栈变量、堆变量</u>

数据是存储在变量中，数据就是具体的值，变量就是能存储值的空间；数据类型定义了一个固定大小的内存块，而且有固定的结构；声明一个变量、对象就会分配一块内存，这个**内存首地址就是变量的指针**。

上次跟你讨论过进程空间的分布，对于地地址空间，也就是0~4kb的地址都是无效的，NULL实际值为0，是个非法内存. 指针对象不可以指向 NULL.  

指针类型与指针变量的值是两回事了；指针类型可以是任何类型，相当于类型，空间大小永远是4个字节或者8个字节；指针变量保存指向对象的地址，一般初始化为NULL，代表还没使用过；

>  <u>吴方圆 : 指定了数据类型 所以就能确定 内存空间大小 分配的这个内存空间 这个内存空间用来保存 内存地址值 也就是 指针</u>

### 底层原理

> 变量的实质

内存空间 : 一系列按照字节编码的内存单元, 每个内存地址 指向一份内存空间.

#### 变量声明 

 `int i; char a;` 

<u>根据数据类型,申请一份内存空间,变量绑定内存地址</u>

变量头部的1个字节是内存地址

内存地址 和 变量的内存地址的区别

每次我们要使用某变量时需要事先这样声明它, 它其实是内存中申请了一个名为i的整形变量宽度的空间(DOS下的16为编程中其宽度为2个字节), 和一个名为a的字符型变量宽度的空间(占1个字节).

变量是如何存在的呢? 在某个内存地址上申请相应的内存空间, 然后命名为相应的变量 相当于是 `变量 绑定 内存地址` bind绑定

#### 变量赋值

`i = 30 ; a = 't';`

将数据存到变量的内存空间, 相应的内存空间就表示是当前变量

#### 变量地址

`&i` i变量的地址编号, 语义: 返回i变量的地址编号

打印变量地址 : `printf("%x", &i);`

```c
main(){
    int i = 39;
    printf("%d\n", i);
    printf("%d\n", &i);
    return(0);
}
```



## 语句:Statement

## 指令:instruction

directive : 指示, 指令

command : 命令

## 声明:declaration

```c
int num; // 单条声明
int feet, name, age; // 多条声明
```

这行代码叫作声明(declaration)。声明是C语言最重要的特性之一。在该例中，声明完成了两件事。

其一，在函数中有一个名为num 的`变量`( variable)。

其二，int 表明 num是一个整数(即，没有小数点或小数部分的数)。

int是一种数据类型。**编译器使用这些信息为num变量在内存中分配存储空间**。分号在C语言中是大部分语句和声明的一部分，不像在Pascal中只是语句间的分隔符。 

int是C语言的一个关键字(keyword)，表示一种基本的C语言数据类型。关键字是语言定义的单词，不能做其他用途。例如，不能用int作为函数名和变量名。但是，这些关键字在该语言以外不起作用，所以把一只猫或一个可爱的小孩叫int是可以的(尽管某些地方的当地习俗或法律可能不允许)。 

示例中的num是一个*标识符*(identifier)，也就是一个变量、函数或其他实体的名称。因此，声明把特定标识符与计算机内存中的特定位置联系起来，同时也确定了储存在某位置的信息类型或数据类型。 

**声明变量的4个理由**: 把声明的变量放在一起更容易理解程序的用途; 声明变量有助于在编写程序之前做一些计划, 数据的表示; 声明变量有助于发现隐藏的小错误, 如变量名拼写错误; 如果实现为声明变量, C程序将无法通过编译.



**在C语言中，所有变量都必须先声明才能使用。**这意味着必须列出程序中用到的所有变量名及其类型。 以前的C语言，还要求把变量声明在块的顶部，其他语句不能在任何声明的前面。也就是说，main()函数体如下所示：

```c
 int main() //旧规则 
{
     int doors;     
     int dogs;
     doors = 5;
     dogs = 3;     
     // 其他语句 
}
```



 C99和C11遵循C++的惯例，可以把声明放在块中的任何位置。**尽管如此，首次使用变量之前一定要先声明它。**因此，如果编译器支持这一新特性，可以这样编写上面的代码： 

```c
int main()            // 目前的C规则
{
    // 一些语句
    int doors;
    doors = 5; // 第1次使用doors
    // 其他语句
    int dogs;
    dogs = 3; // 第1次使用dogs
    // 其他语句
}
```



## 宏:Macro

宏(英语：Macro)是一种[批量处理](https://baike.baidu.com/item/批量处理)的称谓。

[计算机科学](https://baike.baidu.com/item/计算机科学)里的宏是一种[抽象](https://baike.baidu.com/item/抽象)(Abstraction)，它根据一系列预定义的规则替换一定的文本模式。[解释器](https://baike.baidu.com/item/解释器)或[编译器](https://baike.baidu.com/item/编译器)在遇到宏时会自动进行这一模式替换。对于编译语言，宏展开在编译时发生，进行宏展开的工具常被称为宏展开器。

<u>[ 宏声明 : 模式替换 ]</u>

**1.#define** **的作用**

　　在Ｃ或C++语言源程序中允许用一个标识符来表示一个字符串，称为“宏”。被定义为“宏”的标识符称为“宏名”。在编译预处理时，对程序中所有出现的“宏名”，都用宏定义中的字符串去代换，这称为“宏代换”或“宏展开”。宏定义是由源程序中的宏定义命令完成的。宏代换是由预处理程序自动完成的。

　　在Ｃ或C++语言中，“宏”分为有参数和无参数两种。

**2.** **无参宏定义**

　　无参宏的宏名后不带参数。

　　其定义的一般形式为：

　　#define 标识符 字符串

　　其中的“#”表示这是一条预处理命令。凡是以“#”开头的均为预处理命令。“define”为宏定义命令。“标识符”为所定义的宏名。“字符串”可以是常数、表达式、格式串等。

　　例如：

　　#define M (a+b)

## I/O:input/output

基本输入\输出

## **函数**:function

### 声明函数

```c
int my_func(para1, para2)
{
	printf("hello, 世界!");
}
```

### 函数调用 = function call

### 主调函数:calling function

### 参数:parameter

### 函数原型:function prototype

也被成为函数声明, 表示函数, 一般将函数原型放置与头文件中

```c
void bulter(void);  //没有返回值,没有传入参数
```



### 函数定义:function definition

```c
int test(void);  //函数原型, 函数声明
int test(void)  //函数定义
{
	int a = 1;
}
```



### 转义字符

换行符是一个转义序列(escape sequence). 转义序列用于代表难以表示或无法输入的字符. 每个转义序列都以反斜杠字符(`\`)开始. 

| 转义字符 | 含义      | 中文      |
| -------- | --------- | --------- |
| `\n`     | Enter     | 进入,换行 |
| `\t`     | Tab       | 制表      |
| `\b`     | Backspace | 退格      |



## 运算符

->

## 分隔符

- `| |`:空格
- `

## 模块

## 数据类型:

内存如何确定数据类型? 不能确定 

内存会用专门的空间存放数据类型吗?

<u>特性</u>:

**内存不关心数据的语义**

不同的类型占用存储单端不用

**计算机怎么对待内存中存储的这些二进制数据呢？根据不同的数据类型做对应的处理。**

如果是一个**顺序列表**如下存储：**Li [7,2100,390]**

数据类型是由指令程序确定的, 而不能由内存地址确定, 内存

内存不会存储数据的数据类型, 如何存取和访问数据由控制程序(源指令)来控制

## 标识符:indentifier

> 命名

支持命名的符号有 小写字母, 大写字母, 数字和下划线(`_`). 而且名称的第一个字符不能是数字. 

## 内存地址

逻辑地址, 物理地址()

<u>逻辑地址</u>:
[机器语言](https://www.baidu.com/s?wd=机器语言&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao)指令仍用这种地址指定一个操作数的地址或一条指令的地址。这种[寻址方式](https://www.baidu.com/s?wd=寻址方式&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao)在Intel的分段结构中表现得尤为具体，它使得MS-DOS或Windows程序员把程序分为若干段。每个逻辑地址都由一个段和偏移量组成。

*[ 程序段的长度, 由源代码/控制代码确定的 ]*

内存不关心语义, 内存只负责存储

CPU也不关心语义, CPU值关心指令 

编译后 会产生逻辑地址, 准备好 指令和内存该做的一切事情, 编译时会创建 文件的链接(地址), 会创建 函数和变量的链接(地址), 运行时才会加载到内存 (将逻辑地址映射到内存)

那为什么 CPU和内存不会产生歧义呢 指令集是确定的, 所以指令不会失真, 物理地址是确定的, 所以不会出错, 逻辑地址

线性地址：
线性地址是一个32位的[无符号整数](https://www.baidu.com/s?wd=无符号整数&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao)，可以表达高达232(4GB)的地址。通常用16进制表示线性地址，其取值范围为0x00000000～0xffffffff。
物理地址：
也就是内存单元的实际地址，用于芯片级内存单元寻址。物理地址也由32位[无符号整数](https://www.baidu.com/s?wd=无符号整数&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao)表示。
MMU是一种硬件电路，它包含两个部件，一个是分段部件，一个是分页部件，在本书中，我们把它们分别叫做分段机制和分页机制，以利于从逻辑的角度来理解硬件的实现机制。分段机制把一个逻辑地址转换为线性地址；接着，分页机制把一个线性地址转换为物理地址。

是这样，[内存地址](https://www.baidu.com/s?wd=内存地址&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao)是由段地址和[偏移地址](https://www.baidu.com/s?wd=偏移地址&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao)组成的。Cpu管理内存是分段管理的，[偏移地址](https://www.baidu.com/s?wd=偏移地址&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao)就是距段首址的位移量，段地址存在cpu的段寄存器中，而[偏移地址](https://www.baidu.com/s?wd=偏移地址&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao)放在Cpu里的其它寄存器中。当Cpu调用内存某个数据时就会从内部寄存里寻找该内存内容的段地址和偏移地址，也就是它的物理地址，这个过程就是<u>寻址</u>。

### 地址

- 虚拟地址
   指由程序产生的由段选择符和段内偏移地址组成的地址。
- 逻辑地址
   指由程序产生的段内偏移。有时候直接把逻辑地址当做虚拟地址。
- 线性地址
   指虚拟地址到物理地址变换的中间层，是处理器可寻址的内存空间中的地址。程序代码会产生逻辑地址，也就是段中的偏移地址，加上相应的段基址就成了线性地址。如果开启了分页机制，那么线性地址需要再经过变换，转为为物理地址。如果无分页机制，那么线性地址就是物理地址。
- 物理地址
   指CPU外部地址总线上寻址物理内存的地址信号，是地址变换的最终结果。

虚拟地址到物理地址的转化是体系结构相关的，一般由分段和分页两种方式。以X86CPU为例，分段和分页都是支持的。内存管理单元负责从虚拟地址到物理地址的转化。逻辑地址是段标识+段内偏移的形式。MMU通过查询段表，可以将逻辑地址转化为线性地址。无分页机制时，线性地址就是物理地址，有分页时，MMU还需要查询页表来将线性地址转化为物理地址：逻辑地址(段表)->线性地址(页表)->物理地址。

映射是一种多对一的关系，即不同的逻辑地址可以映射到同一个线性地址上；不同的线性地址也可以映射到同一个物理地址上。而且，同一个线性地址在换页之后，可能被装载到另一个物理地址上，所以这种多对一的映射关系会随时间发生变化





# 基础语义

lexical elements 词法元素 

对基础符合的理解, 字符层级的理解

## `[]`:方括号:array:数组

> 数组变量, 需要声明, 一维数组

```C
// 声明一个数组变量
type arrayName[arraySize];
double balance[5];

// 初始化数组 可以省略数组大小
double balance[5] = { 1.1, 2.0, 3.4, 5.7, 1000.0};
double balance[] = { 1.1, 2.0, 3.4, 5.7, 1000.0};

// 数组赋值
balance[4] = 50.0;

// 访问数组
double salary = balance[4];

```

## `()`:圆括号

## `{}`:花括号:函数体:块

```c
{
    ...
}
```



花括号把main()函数括起来。所有的C函数都使用花括号标记函数体的开始和结束。这是规定，不能省略。只有花括号({})能起这种作用，圆括号(())和方括号([])都不行。
**花括号还可用于把函数中的多条语句合并为一个单元或块。**花括号在C语言中的作用类似于这些语言中的begin和end。

## `<>`:尖括号

## `'`:单引号

## `"`:双引号

### `'` 与 `"` 的区别

> 含义上 : <u>单引号</u>表示的字符 其实是一个代表一个整数, <u>双引号</u>引起的字符串, 代表的是一个指向无名数组起始字符的指针. 
>
> 性质上 : 用单引号引起的一个字符大小就是一个字节。而用双引号引起的字符串大小是字符的总大小+1，因为用双引号引起的字符串会在字符串末尾添加一个二进制为0的字符’\0’。

## `//`:单行注释

## `/**/`:多行注释

## `.c` 和 `.o` 与 `.h` 的区别

c, 源代码文件

o, object 一般是编译后的 汇编语言文件

h, header 头文件: 常量, 函数定义的集合, 函数声明, 函数原型

## `cpp`文件和 `h`文件的区别

C++里面编译的单位是compile unit，也就是经过预处理之后的源文件，这包括宏的处理，以及include文件的替换等。

一般来说，h文件用于函数和变量的声明，而cpp文件则用于定义。

对于C++编译环境而言，他们都不过是操作系统内的文件，h文件可以include cpp文件，cpp文件也可以include h文件。

## `main()` 函数

通常情况下, 函数没有命名限制, 但main是一个特殊的函数名一每个程序都从main函数的起点开始执行, 这意味着每个程序都必须在某个位置包含一个main函数.

main函数通常会调用其他函数来帮助完成某些工作, 被调用的含食宿可以是程序设计人员自己编写的, 也可以来自于函数库. 

程序清单2.1中的第2行表明该函数名为main。的确，main是一个极其普通的名称，但是这是唯一的选择。C程序一定从main()函数开始执行(目前不必考虑例外的情况)。除了`main()`函数，你可以任意命名其他函数，而且main()函数必须是开始的函数。

**圆括号有什么功能？用于识别main()是一个函数。**很快你将学到更多的函数。就目前而言，只需记住函数是C程序的基本模块。int是main()函数的返回类型。这表明main()函数返回的值是整数。返回到哪里？返回给操作系统。我们将在第6章中再来探讨这个问题。

通常，函数名后面的圆括号中包含一些传入函数的信息。该例中没有传递任何信息。因此，圆括号内是单词void(第11章将介绍把信息从main()函数传回操作系统的另一种形式)。

这里要注意，何时执行`butler()`函数取决于它在main()中被调用的位置，而不是butler()的定义在文件中的位置。例如，把butler()函数的定义放在main()定义之前，不会改变程序的执行顺序，butler()函数仍然在两次printf()调用之间被调用。**记住，无论main()在程序文件处于什么位置，所有的C程序都从main()开始执行。** **但是，C的惯例是把main()放在开头，因为它提供了程序的基本框架。**

<u>Python的惯例是放到文末, 放在文末也具备合理性</u>

**C标准建议，要为程序中用到的所有函数提供函数原型。**标准include文件（包含文件）为标准库函数提供了函数原型。例如，在C标准中，stdio.h文件包含了printf()的函数原型。

## `#include <stdio.h>` 预处理

> 声明 statement

*调用标准库的函数*

告诉编译器在本程序中包含标准输入/输出库的信息. 

这是程序的第1行。`#include` 的作用相当于把`stdio.h`文件中的所有内容都输入该行所在的位置。实际上，这是一种`“拷贝-粘贴”`的操作。`include`文件提供了一种方便的途径共享许多程序共有的信息。

`#include`这行代码是一条C*预处理器指令*(preprocessor directive)。通常，C编译器在编译前会对源代码做一些准备工作，即*预处理*(preprocessing)。

所有的C编译器软件包都提供`stdio.h`文件。该文件中包含了供编译器使用的输入和输出函数(如，`printf()`)信息。该文件名的含义是标准输入/输出头文件。通常，在C程序顶部的信息集合被称为*头文件*(header)。

在大多数情况下，头文件包含了编译器创建最终可执行程序要用到的信息。例如，头文件中可以定义一些常量，或者指明函数名以及如何使用它们。但是，函数的实际代码在一个预编译代码的库文件中。简而言之，**头文件帮助编译器把你的程序正确地组合在一起。**

## `#define directives`  宏定义

预处理器 preprocesser

## `Space` 和 `Enter` 与 `Tab` 在C中的含义

## *头文件* 与 *库文件*

Header Files / Library Files

头文件 是 是指 #include声明的文件部分 `stdio.h`

库文件 则是 函数库的文件 ``

## `:` 位域

## `::` 

## `#`:构串操作符

任意行 以#开始的字符串都是一个预处理程序(preprocessor)

宏(macro)  批处理 凡是使用到宏定义的变量 就会被替换为 字符串

宏的特性 标识符 语义与原义 

预处理 : 

首字节地址 : 内存 数据类型 

构串操作符#只能修饰带参数的宏的形参，它将实参的字符序列(而不是实参代表的值)转换成字符串常量

本质上 将 参数 定义为 一个字符串 然后用这个参数表示字符串

```c
#define macroname value
预先批处理定义 宏变量(宏参数参数) 的值 为 value
    宏可以作为变量 也可以作为参数
```

## `\`:转义符

## `%`:占位符

## `##` 合并操作符

合并操作符##将出现在其左右的字符序列合并成一个新的标识符

注意：
使用合并操作符##时，自身的标识符必须预先有定义，否则编译器会报“标识符未定义”的编译错误。
字符序列合并成新的标识符不是字符串。

## `&`:地址获取符



`*`:指针声明

# 语法语义

对代码的理解和解读, 语句层级的理解

## 代码理解

批处理 : 对一个相同的标识符或特定规则,进行批量处理, 也叫做宏 是个 

```c++
#define  // 预处理宏定义
#include <stdio.h>  //预处理包含

```

### 

## 关键字

关键字是C语言的词汇。它们对C而言比较特殊，不能用它们作为标识符（如，变量名）。许多关键字用于指定不同的类型，如int。还有一些关键字（如，if）用于控制程序中语句的执行顺序。在表2.2中所列的C语言关键字中，粗体表示的是C90标准新增的关键字，斜体表示的C99标准新增的关键字，粗斜体表示的是C11标准新增的关键字。

表2.2　ISO C关键字

|            |            |              |                  |
| ----------- | ---------- | -------------- | ---------------------- |
| `auto`      | `extern`   | `short`        | `while`                |
| `break`     | `float`    | **`signed`** | `_Alignas`       |
| `case`      | `for`      | `sizeof`       | `_Alignof`       |
| `char`      | `goto`     | `static`       | `_Atomic`        |
| `const` | `if`       | `struct`       | `_Bool`          |
| `continue`  | `inline` | `switch`       | `_Complex`       |
| `default`   | `int`      | `typedef`      | `_Generic`       |
| `do`        | `long`     | `union`        | `_Imaginary`     |
| `double`    | `register` | `unsigned`     | `_Noreturn`      |
| `else`      | `restrict` | `void`         | `_Static_assert` |
| **`enum`** | `return`   | `volatile` | `_Thread_local`  |

如果使用关键字不当（如，用关键字作为变量名），编译器会将其视为语法 错误。还有一些保留标识符（reserved identifier），C语言已经指定了它们的用途或保留它们的使用权，如果你使用这些标识符来表示其他意思会导致一些问题。因此，尽管它们也是有效的名称，不会引起语法错误，也不能随便使用。保留标识符包括那些以下划线字符开头的标识符和标准库函数名，如printf()。

### extern:外部声明

extern是C语言中的一个关键字, 可置于<u>变量</u>或者<u>函数</u>前，以表示变量或者函数的定义在别的文件中。提示[编译器](https://baike.baidu.com/item/编译器/8853067)遇到此变量或函数时，在其它模块中寻找其[定义](https://baike.baidu.com/item/定义/483965)，另外，extern也可用来进行链接指定。

external : 外部的

### const:常量声明

## 变量:variable

## 函数:function

### typeof():变量数据类型

## 表达式:Expression

## *语句*:Statement

### 声明语句:declaration

### 赋值语句:assignment

```c
num = 1;  // 把值1赋给变量num
```

在执行intnum;声明时，编译器在计算机内存中为变量num预留了空间，然后在执行这行赋值表达式语句时，把值储存在之前预留的位置。可以给num赋不同的值，这就是num之所以被称为变量（variable）的原因。注意，该赋值表达式语句从右侧把值赋到左侧。另外，该语句以分号结尾. 

### return语句:return

```c
return 0;
```

​	return语句是程序清单2.1的最后一条语句。`int main(void)`中的int表明main()函数应返回一个整数。C标准要求main()这样做。有返回值的C函数要有return语句。该语句以return关键字开始，后面是待返回的值，并以分号结尾。如果遗漏main()函数中的return语句，程序在运行至最外面的右花括号`}`时会返回0。因此，可以省略`main()`函数末尾的return语句。但是，不要在其他有返回值的函数中漏掉它。因此，强烈建议读者养成在main()函数中保留return语句的好习惯。在这种情况下，可将其看作是统一代码风格。**但对于某些操作系统(包括Linux和UNIX)，return语句有实际的用途。**



# 数据模型

## 指针:Pointer

> C语言的一种特性, 指向变量内存地址的变量  有点像索引 
>
> 变量的地址, 变量的位置 来表示这个变量 在需要时 获取变量的值
>
> 指针 也是一个变量
>
> **Python中的变量就相当于一个指针**

### 常见问题

- 访问 变量的内存地址 &
- 定义 指向变量的指定 变量指向内存中的一个存储区

### 底层原理

内存是按照字节进行编址的

现代计算机大部分都是按 <u>字节</u> 划分内存的, 每个字节都有唯一地址, C语言中所有的指针操作都是基于这些地址的. 在C程序中一个变量会占用一个或多个字节, 第一个字节的地址就是该变量的地址, 将该地址赋值给某个变量后,就称其为 <u>指针</u>.

#### 声明指针

`int *pi;` pi 是一个指针, 也是一个变量. 在内存中的实质和变量是一样的.(实际上在32为系统中指针宽度是 4个字节宽的, 即 32位.)

在内存的某处声明一个固定宽度的内存空间, 并把它命名为pi. 本质上 指针还是一个变量. 

**关键区别** : 变量存储的是数据, 指针是存储内存地址的变量. 区别是 <u>存储的内容不同</u>

#### 指针赋值

`pi = &i;` 语义: 将变量i的内存地址赋值给指针变量 pi.

pi 和 i 的区别是 一个记录了 数据的索引, 一个记录了数据

#### 指针数据

`*pi` : 指针变量的数据内容; 语义 : 返回pi 指针指向的地址的数据.

*C里面可以用 指针进行检索 也可以用变量进行检索*

`pi` : 指针变量的内存地址; 语义 : 指针类型的变量

### 基础语义

> 定义, 理解, 认知, 特性, 作用, 优势, 应用场景

其他表征 : 变量, 

指针是一种**保存变量地址**的变量.指针常常是表达某个计算的唯一途径, 使用指针通常可以生成高效,更紧凑的代码. 

*指向内存的值的控制结构* 

*不同于普通变量 是 直接访问内存的 变量*

通过指针来表达一个 流(stream)

一元运算符 `&` 可以用于获取对象的地址: `p = &c;` 将把 `c` 的地址复制给变量 `p` , 我们称 `p` 为 <u>指向</u> `c` 的 <u>指针</u> . **地址运算符&只能应用与内存中的对象, 即变量与数组元素. ** 它不能作用于表达式, 常量或register类型的变量. 

一元运算符 `*` 是间接寻址或间接引用运算符. **当它作用于指针对象时, 将访问指针所指向的对象.** 

*指针的类型 由指向的变量类型决定*

```C
int x=1, y = 2, z[10];
int *ip; //ip is a pointer to int
ip = &x;  //ip now points to x
y = *ip;  //y is now 0
*ip = 0;  //x is now 0
ip = &z[0]  // ip now points to z[0]
```

通过指针，可以简化一些 C 编程任务的执行，还有一些任务，如动态内存分配，没有指针是无法执行的。所以，想要成为一名优秀的 C 程序员，学习指针是很有必要的。



正如您所知道的，每一个变量都有一个内存位置，每一个内存位置都定义了可使用连字号(&)运算符访问的地址，它表示了在内存中的一个地址。请看下面的实例，它将输出定义的变量地址：

```c
#include <stdio.h>
 
int main ()
{
   int  var1;
   char var2[10];
 
   printf("var1 变量的地址： %p\n", &var1  );
   printf("var2 变量的地址： %p\n", &var2  );
 
   return 0;
}
```





### 原理解析

> 常见问题
>
> 操纵指针的规则
>
> 

<u>内存的组织原理</u> : 机器都有一系列连续编号地址的存储单元, 这些存储单元可以进行单个操纵也可以以联系成组的方式操纵.

*不同层次的封装,可以增加复杂度, 同时也产生了更多的功能*

### 最佳实践

> 优秀人员的建议, 实践的经验总结, 基于原理的最佳解决方案
>
> 用法示例

使用 类型 `void *` (指向void的指针) 代替 `char *` 作为通用指针的类型

#### 应用场景

```c
// 通过指针修改指向变量的值
char a, *pa; a = 10; pa = &a;
*pa = 20; printf("%d", a);
```



## 结构体:Srtucture

> 关键字 : struct, union, typedef
>
> 运算符 : .  ->
>
> 什么是C结构, 如何创建结构模板和结构变量
>
> 如何访问结构的成员, 如何编写处理结构的函数
>
> 联合和指向函数的指针

设计程序时, 最终要的步骤之一是选择<u>表示数据的方法</u>. 在许多情况下, 简单变量甚至是数组还不够. 为此, C提供了 <u>结构变量</u>(structure variable)提高编程时表示数据的能力, 创造新的形式. 

*作用: 产生一种新的数据结构来方便表示数据*



## 数组:Array

### 声明数组

`int a[]={3,4,5,6,7,3,7,6,4,3};`

# 常见问题

## C与C++的区别

C++是 C 的超集, 这意味着一个有效的C程序也是一个有效的C++程序. C和C++的主要区别是, C++支持许多附加特性. 但是, C++中有许多规则与C少有不同. 







# 编程实例

# 应用实践